SCRIPT  /usr/share/vim/vim90/syntax/typescript.vim
Sourced 3 times
Total time:   0.000021
 Self time:   0.000021

count  total (s)   self (s)
                            " Vim syntax file
                            " Language:     TypeScript
                            " Maintainer:   Bram Moolenaar, Herrington Darkholme
                            " Last Change:	2019 Nov 30
                            " Based On:     Herrington Darkholme's yats.vim
                            " Changes:      Go to https:github.com/HerringtonDarkholme/yats.vim for recent changes.
                            " Origin:       https://github.com/othree/yajs
                            " Credits:      Kao Wei-Ko(othree), Jose Elera Campana, Zhao Yi, Claudio Fleiner, Scott Shattuck
                            "               (This file is based on their hard work), gumnos (From the #vim
                            "               IRC Channel in Freenode)
                            
                            " This is the same syntax that is in yats.vim, but:
                            " - flattened into one file
                            " - HiLink commands changed to "hi def link"
                            " - Setting 'cpo' to the Vim value
                            
    3              0.000004 if !exists("main_syntax")
    3              0.000003   if exists("b:current_syntax")
    3              0.000000     finish
                              endif
                              let main_syntax = 'typescript'
                            endif
                            
                            let s:cpo_save = &cpo
                            set cpo&vim
                            
                            " this region is NOT used in TypeScriptReact
                            " nextgroup doesn't contain objectLiteral, let outer region contains it
                            syntax region typescriptTypeCast matchgroup=typescriptTypeBrackets
                              \ start=/< \@!/ end=/>/
                              \ contains=@typescriptType
                              \ nextgroup=@typescriptExpression
                              \ contained skipwhite oneline
                            
                            
                            """""""""""""""""""""""""""""""""""""""""""""""""""
                            " Source the part common with typescriptreact.vim
                            source <sfile>:h/shared/typescriptcommon.vim
                            
                            
                            let b:current_syntax = "typescript"
                            if main_syntax == 'typescript'
                              unlet main_syntax
                            endif
                            
                            let &cpo = s:cpo_save
                            unlet s:cpo_save

SCRIPT  /home/pyericz/.vimgo/plugged/yats.vim/syntax/typescript.vim
Sourced 3 times
Total time:   0.032157
 Self time:   0.032155

count  total (s)   self (s)
                            " Vim syntax file
                            " Language:     TypeScript
                            " Maintainer:   Herrington Darkholme
                            " Last Change:  2016-04-05
                            " Version:      1.0
                            " Changes:      Go to https:github.com/HerringtonDarkholme/yats.vim for recent changes.
                            " Origin:       https://github.com/othree/yajs
                            " Credits:      Kao Wei-Ko(othree), Jose Elera Campana, Zhao Yi, Claudio Fleiner, Scott Shattuck
                            "               (This file is based on their hard work), gumnos (From the #vim
                            "               IRC Channel in Freenode)
                            
                            
    3              0.000005 if !exists("main_syntax")
    3              0.000004   if exists("b:current_syntax")
                                finish
    3              0.000001   endif
    3              0.000003   let main_syntax = 'typescript'
    3              0.000002 endif
                            
                            " nextgroup doesn't contain objectLiteral, let outer region contains it
    3              0.000069 syntax region typescriptTypeCast matchgroup=typescriptTypeBrackets
                              \ start=/< \@!/ end=/>/
                              \ contains=@typescriptType
                              \ nextgroup=@typescriptExpression
                              \ contained skipwhite oneline
                            
    3   0.032029   0.032027 runtime syntax/common.vim
                            
    3              0.000006 let b:current_syntax = "typescript"
    3              0.000006 if main_syntax == 'typescript'
    3              0.000001   unlet main_syntax
    3              0.000003 endif

SCRIPT  /home/pyericz/.vimgo/plugged/yats.vim/syntax/common.vim
Sourced 3 times
Total time:   0.031900
 Self time:   0.031899

count  total (s)   self (s)
                            " Define the default highlighting.
                            " For version 5.8 and later: only when an item doesn't have highlighting yet
    3              0.000003 let did_typescript_hilink = 1
                            
    3              0.000003 syntax sync fromstart
    3              0.000029 command -nargs=+ HiLink hi def link <args>
                            
                            "Dollar sign is permitted anywhere in an identifier
    3              0.000043 setlocal iskeyword-=$
    3              0.000006 if main_syntax == 'typescript' || main_syntax == 'typescriptreact'
    3              0.000031   setlocal iskeyword+=$
                              " syntax cluster htmlJavaScript                 contains=TOP
    3              0.000000 endif
                            " For private field added from TypeScript 3.8
    3              0.000028 setlocal iskeyword+=#
                            
                            " lowest priority on least used feature
    3              0.000037 syntax match   typescriptLabel                /[a-zA-Z_$]\k*:/he=e-1 contains=typescriptReserved nextgroup=@typescriptStatement skipwhite skipempty
                            
                            " other keywords like return,case,yield uses containedin
    3              0.000026 syntax region  typescriptBlock                 matchgroup=typescriptBraces start=/{/ end=/}/ contains=@typescriptStatement,@typescriptComments fold
                            
                            
    3   0.000870   0.000869 runtime syntax/basic/identifiers.vim
    3              0.000588 runtime syntax/basic/literal.vim
    3              0.000425 runtime syntax/basic/object.vim
                            
    3              0.000366 runtime syntax/basic/symbols.vim
                            " runtime syntax/basic/reserved.vim
    3              0.001074 runtime syntax/basic/keyword.vim
    3              0.001073 runtime syntax/basic/doc.vim
    3              0.001359 runtime syntax/basic/type.vim
                            
                            " extension
    3              0.000007 if get(g:, 'yats_host_keyword', 1)
    3              0.021833   runtime syntax/yats.vim
    3              0.000002 endif
                            
                            " patch
    3              0.000263 runtime syntax/basic/patch.vim
    3              0.000435 runtime syntax/basic/members.vim
    3              0.000691 runtime syntax/basic/class.vim
    3              0.000653 runtime syntax/basic/cluster.vim
    3              0.000605 runtime syntax/basic/function.vim
    3              0.000190 runtime syntax/basic/decorator.vim
                            
    3              0.000005 if exists("did_typescript_hilink")
    3              0.000026   HiLink typescriptReserved             Error
                            
    3              0.000015   HiLink typescriptEndColons            Exception
    3              0.000012   HiLink typescriptSymbols              Normal
    3              0.000013   HiLink typescriptBraces               Function
    3              0.000012   HiLink typescriptParens               Normal
    3              0.000012   HiLink typescriptComment              Comment
    3              0.000012   HiLink typescriptLineComment          Comment
    3              0.000011   HiLink typescriptDocComment           Comment
    3              0.000012   HiLink typescriptCommentTodo          Todo
    3              0.000011   HiLink typescriptMagicComment         SpecialComment
    3              0.000011   HiLink typescriptRef                  Include
    3              0.000011   HiLink typescriptDocNotation          SpecialComment
    3              0.000010   HiLink typescriptDocTags              SpecialComment
    3              0.000010   HiLink typescriptDocNGParam           typescriptDocParam
    3              0.000010   HiLink typescriptDocParam             Function
    3              0.000010   HiLink typescriptDocNumParam          Function
    3              0.000010   HiLink typescriptDocEventRef          Function
    3              0.000011   HiLink typescriptDocNamedParamType    Type
    3              0.000012   HiLink typescriptDocParamName         Type
    3              0.000009   HiLink typescriptDocParamType         Type
    3              0.000012   HiLink typescriptString               String
    3              0.000011   HiLink typescriptSpecial              Special
    3              0.000010   HiLink typescriptStringLiteralType    String
    3              0.000011   HiLink typescriptTemplateLiteralType  String
    3              0.000010   HiLink typescriptStringMember         String
    3              0.000011   HiLink typescriptTemplate             String
    3              0.000011   HiLink typescriptEventString          String
    3              0.000011   HiLink typescriptDestructureString    String
    3              0.000011   HiLink typescriptASCII                Special
    3              0.000011   HiLink typescriptTemplateSB           Label
    3              0.000012   HiLink typescriptRegexpString         String
    3              0.000011   HiLink typescriptGlobal               Constant
    3              0.000009   HiLink typescriptTestGlobal           Function
    3              0.000011   HiLink typescriptPrototype            Type
    3              0.000011   HiLink typescriptConditional          Conditional
    3              0.000012   HiLink typescriptConditionalElse      Conditional
    3              0.000009   HiLink typescriptCase                 Conditional
    3              0.000012   HiLink typescriptDefault              typescriptCase
    3              0.000009   HiLink typescriptBranch               Conditional
    3              0.000012   HiLink typescriptIdentifier           Structure
    3              0.000011   HiLink typescriptVariable             Identifier
    3              0.000010   HiLink typescriptDestructureVariable  PreProc
    3              0.000012   HiLink typescriptEnumKeyword          Identifier
    3              0.000010   HiLink typescriptRepeat               Repeat
    3              0.000011   HiLink typescriptForOperator          Repeat
    3              0.000011   HiLink typescriptStatementKeyword     Statement
    3              0.000012   HiLink typescriptMessage              Keyword
    3              0.000014   HiLink typescriptOperator             Identifier
    3              0.000013   HiLink typescriptKeywordOp            Identifier
    3              0.000012   HiLink typescriptCastKeyword          Special
    3              0.000009   HiLink typescriptType                 Type
    3              0.000011   HiLink typescriptNull                 Boolean
    3              0.000012   HiLink typescriptNumber               Number
    3              0.000012   HiLink typescriptBoolean              Boolean
    3              0.000011   HiLink typescriptObjectLabel          typescriptLabel
    3              0.000011   HiLink typescriptDestructureLabel     Function
    3              0.000011   HiLink typescriptLabel                Label
    3              0.000010   HiLink typescriptTupleLable           Label
    3              0.000011   HiLink typescriptStringProperty       String
    3              0.000010   HiLink typescriptImport               Special
    3              0.000011   HiLink typescriptImportType           Special
    3              0.000011   HiLink typescriptAmbientDeclaration   Special
    3              0.000011   HiLink typescriptExport               Special
    3              0.000010   HiLink typescriptExportType           Special
    3              0.000012   HiLink typescriptModule               Special
    3              0.000009   HiLink typescriptTry                  Special
    3              0.000011   HiLink typescriptExceptions           Special
                            
    3              0.000009   HiLink typescriptMember              Function
    3              0.000009   HiLink typescriptMethodAccessor       Operator
                            
    3              0.000009   HiLink typescriptAsyncFuncKeyword     Keyword
    3              0.000011   HiLink typescriptObjectAsyncKeyword   Keyword
    3              0.000011   HiLink typescriptAsyncFor             Keyword
    3              0.000010   HiLink typescriptFuncKeyword          Keyword
    3              0.000010   HiLink typescriptAsyncFunc            Keyword
    3              0.000009   HiLink typescriptArrowFunc            Type
    3              0.000009   HiLink typescriptFuncName             Function
    3              0.000009   HiLink typescriptFuncArg              PreProc
    3              0.000010   HiLink typescriptArrowFuncArg         PreProc
    3              0.000011   HiLink typescriptFuncComma            Operator
                            
    3              0.000009   HiLink typescriptClassKeyword         Keyword
    3              0.000010   HiLink typescriptClassExtends         Keyword
                              " HiLink typescriptClassName            Function
    3              0.000009   HiLink typescriptAbstract             Special
                              " HiLink typescriptClassHeritage        Function
                              " HiLink typescriptInterfaceHeritage    Function
    3              0.000009   HiLink typescriptClassStatic          StorageClass
    3              0.000010   HiLink typescriptReadonlyModifier     Keyword
    3              0.000012   HiLink typescriptInterfaceKeyword     Keyword
    3              0.000009   HiLink typescriptInterfaceExtends     Keyword
    3              0.000009   HiLink typescriptInterfaceName        Function
                            
    3              0.000012   HiLink shellbang                      Comment
                            
    3              0.000011   HiLink typescriptTypeParameter         Identifier
    3              0.000010   HiLink typescriptConstraint            Keyword
    3              0.000010   HiLink typescriptPredefinedType        Type
    3              0.000010   HiLink typescriptReadonlyArrayKeyword  Keyword
    3              0.000011   HiLink typescriptUnion                 Operator
    3              0.000010   HiLink typescriptFuncTypeArrow         Function
    3              0.000011   HiLink typescriptConstructorType       Function
    3              0.000011   HiLink typescriptTypeQuery             Keyword
    3              0.000010   HiLink typescriptAccessibilityModifier Keyword
    3              0.000011   HiLink typescriptOptionalMark          PreProc
    3              0.000009   HiLink typescriptFuncType              Special
    3              0.000011   HiLink typescriptMappedIn              Special
    3              0.000010   HiLink typescriptCall                  PreProc
    3              0.000009   HiLink typescriptParamImpl             PreProc
    3              0.000011   HiLink typescriptConstructSignature    Identifier
    3              0.000010   HiLink typescriptAliasDeclaration      Identifier
    3              0.000010   HiLink typescriptAliasKeyword          Keyword
    3              0.000011   HiLink typescriptUserDefinedType       Keyword
    3              0.000009   HiLink typescriptTypeReference         Identifier
    3              0.000010   HiLink typescriptConstructor           Keyword
    3              0.000011   HiLink typescriptDecorator             Special
    3              0.000009   HiLink typescriptAssertType            Keyword
                            
    3              0.000007   highlight link typeScript             NONE
                            
    3              0.000005   delcommand HiLink
    3              0.000004   unlet did_typescript_hilink
    3              0.000002 endif

SCRIPT  /home/pyericz/.vimgo/plugged/yats.vim/syntax/basic/identifiers.vim
Sourced 3 times
Total time:   0.000726
 Self time:   0.000726

count  total (s)   self (s)
    3              0.000071 syntax cluster afterIdentifier contains=
                              \ typescriptDotNotation,
                              \ typescriptFuncCallArg,
                              \ typescriptTemplate,
                              \ typescriptIndexExpr,
                              \ @typescriptSymbols,
                              \ typescriptTypeArguments
                            
    3              0.000024 syntax match   typescriptIdentifierName        /\<\K\k*/
                              \ nextgroup=@afterIdentifier
                              \ transparent
                              \ contains=@_semantic
                              \ skipnl skipwhite
                            
    3              0.000018 syntax match   typescriptProp contained /\K\k*!\?/
                              \ transparent
                              \ contains=@props
                              \ nextgroup=@afterIdentifier
                              \ skipwhite skipempty
                            
    3              0.000069 syntax region  typescriptIndexExpr      contained matchgroup=typescriptProperty start=/\[/ end=/]/ contains=@typescriptValue,typescriptCastKeyword nextgroup=@typescriptSymbols,typescriptDotNotation,typescriptFuncCallArg skipwhite skipempty
                            
    3              0.000033 syntax match   typescriptDotNotation           /\.\|?\.\|!\./ nextgroup=typescriptProp skipnl
    3              0.000027 syntax match   typescriptDotStyleNotation      /\.style\./ nextgroup=typescriptDOMStyle transparent
                            " syntax match   typescriptFuncCall              contained /[a-zA-Z]\k*\ze(/ nextgroup=typescriptFuncCallArg
    3              0.000038 syntax region  typescriptParenExp              matchgroup=typescriptParens start=/(/ end=/)/ contains=@typescriptComments,@typescriptValue,typescriptCastKeyword nextgroup=@typescriptSymbols skipwhite skipempty
    3              0.000040 syntax region  typescriptFuncCallArg           contained matchgroup=typescriptParens start=/(/ end=/)/ contains=@typescriptValue,@typescriptComments,typescriptCastKeyword nextgroup=@typescriptSymbols,typescriptDotNotation skipwhite skipempty skipnl
    3              0.000019 syntax region  typescriptEventFuncCallArg      contained matchgroup=typescriptParens start=/(/ end=/)/ contains=@typescriptEventExpression
    3              0.000030 syntax region  typescriptEventString           contained start=/\z(["']\)/  skip=/\\\\\|\\\z1\|\\\n/  end=/\z1\|$/ contains=typescriptASCII,@events
                            
    3              0.000037 syntax region  typescriptDestructureString
                              \ start=/\z(["']\)/  skip=/\\\\\|\\\z1\|\\\n/  end=/\z1\|$/
                              \ contains=typescriptASCII
                              \ nextgroup=typescriptDestructureAs
                              \ contained skipwhite skipempty
                            
    3              0.000032 syntax cluster typescriptVariableDeclarations
                              \ contains=typescriptVariableDeclaration,@typescriptDestructures
                            
    3              0.000039 syntax match typescriptVariableDeclaration /[A-Za-z_$]\k*/
                              \ nextgroup=typescriptTypeAnnotation,typescriptAssign
                              \ contained skipwhite skipempty
                            
    3              0.000044 syntax cluster typescriptDestructureVariables contains=
                              \ typescriptRestOrSpread,
                              \ typescriptDestructureComma,
                              \ typescriptDestructureLabel,
                              \ typescriptDestructureVariable,
                              \ @typescriptDestructures
                            
    3              0.000021 syntax match typescriptDestructureVariable    /[A-Za-z_$]\k*/ contained
                              \ nextgroup=typescriptDefaultParam
                              \ contained skipwhite skipempty
                            
    3              0.000023 syntax match typescriptDestructureLabel       /[A-Za-z_$]\k*\ze\_s*:/
                              \ nextgroup=typescriptDestructureAs
                              \ contained skipwhite skipempty
                            
    3              0.000021 syntax match typescriptDestructureAs /:/
                              \ nextgroup=typescriptDestructureVariable,@typescriptDestructures
                              \ contained skipwhite skipempty
                            
    3              0.000008 syntax match typescriptDestructureComma /,/ contained
                            
    3              0.000022 syntax cluster typescriptDestructures contains=
                              \ typescriptArrayDestructure,
                              \ typescriptObjectDestructure
                            
    3              0.000045 syntax region typescriptArrayDestructure matchgroup=typescriptBraces
                              \ start=/\[/ end=/]/
                              \ contains=@typescriptDestructureVariables,@typescriptComments
                              \ nextgroup=typescriptTypeAnnotation,typescriptAssign
                              \ transparent contained skipwhite skipempty fold
                            
    3              0.000052 syntax region typescriptObjectDestructure matchgroup=typescriptBraces
                              \ start=/{/ end=/}/
                              \ contains=typescriptDestructureString,@typescriptDestructureVariables,@typescriptComments
                              \ nextgroup=typescriptTypeAnnotation,typescriptAssign
                              \ transparent contained skipwhite skipempty fold

SCRIPT  /home/pyericz/.vimgo/plugged/yats.vim/syntax/basic/literal.vim
Sourced 3 times
Total time:   0.000455
 Self time:   0.000455

count  total (s)   self (s)
                            "Syntax in the JavaScript code
                            
                            " String
    3              0.000012 syntax match   typescriptASCII                 contained /\\\d\d\d/
                            
    3              0.000030 syntax region  typescriptTemplateSubstitution matchgroup=typescriptTemplateSB
                              \ start=/\${/ end=/}/
                              \ contains=@typescriptValue,typescriptCastKeyword
                              \ contained
                            
                            
    3              0.000030 syntax region  typescriptString
                              \ start=+\z(["']\)+  skip=+\\\%(\z1\|$\)+  end=+\z1+ end=+$+
                              \ contains=typescriptSpecial,@Spell
                              \ nextgroup=@typescriptSymbols
                              \ skipwhite skipempty
                              \ extend
                            
    3              0.000019 syntax match   typescriptSpecial            contained "\v\\%(x\x\x|u%(\x{4}|\{\x{1,6}})|c\u|.)"
                            
                            " From pangloss/vim-javascript
                            " <https://github.com/pangloss/vim-javascript/blob/d6e137563c47fb59f26ed25d044c0c7532304f18/syntax/javascript.vim#L64-L72>
    3              0.000021 syntax region  typescriptRegexpCharClass    contained start=+\[+ skip=+\\.+ end=+\]+ contains=typescriptSpecial extend
    3              0.000007 syntax match   typescriptRegexpBoundary     contained "\v\c[$^]|\\b"
    3              0.000007 syntax match   typescriptRegexpBackRef      contained "\v\\[1-9]\d*"
    3              0.000017 syntax match   typescriptRegexpQuantifier   contained "\v[^\\]%([?*+]|\{\d+%(,\d*)?})\??"lc=1
    3              0.000005 syntax match   typescriptRegexpOr           contained "|"
    3              0.000007 syntax match   typescriptRegexpMod          contained "\v\(\?[:=!>]"lc=1
    3              0.000023 syntax region  typescriptRegexpGroup        contained start="[^\\]("lc=1 skip="\\.\|\[\(\\.\|[^]]\+\)\]" end=")" contains=typescriptRegexpCharClass,@typescriptRegexpSpecial keepend
    3              0.000044 syntax region  typescriptRegexpString
                              \ start=+\%(\%(\<return\|\<typeof\|\_[^)\]'"[:blank:][:alnum:]_$]\)\s*\)\@<=/\ze[^*/]+ skip=+\\.\|\[[^]]\{1,}\]+ end=+/[gimyus]\{,6}+
                              \ contains=typescriptRegexpCharClass,typescriptRegexpGroup,@typescriptRegexpSpecial
                              \ oneline keepend extend
    3              0.000039 syntax cluster typescriptRegexpSpecial    contains=typescriptSpecial,typescriptRegexpBoundary,typescriptRegexpBackRef,typescriptRegexpQuantifier,typescriptRegexpOr,typescriptRegexpMod
                            
    3              0.000069 syntax region  typescriptTemplate
                              \ start=/`/  skip=/\\\\\|\\`\|\n/  end=/`\|$/
                              \ contains=typescriptTemplateSubstitution,typescriptSpecial,@Spell
                              \ nextgroup=@typescriptSymbols
                              \ skipwhite skipempty
                            
                            "Array
    3              0.000048 syntax region  typescriptArray matchgroup=typescriptBraces
                              \ start=/\[/ end=/]/
                              \ contains=@typescriptValue,@typescriptComments,typescriptCastKeyword
                              \ nextgroup=@typescriptSymbols,typescriptDotNotation
                              \ skipwhite skipempty fold
                            
                            " Number
    3              0.000016 syntax match typescriptNumber /\<0[bB][01][01_]*\>/        nextgroup=@typescriptSymbols skipwhite skipempty
    3              0.000012 syntax match typescriptNumber /\<0[oO][0-7][0-7_]*\>/       nextgroup=@typescriptSymbols skipwhite skipempty
    3              0.000012 syntax match typescriptNumber /\<0[xX][0-9a-fA-F][0-9a-fA-F_]*\>/ nextgroup=@typescriptSymbols skipwhite skipempty
    3              0.000022 syntax match typescriptNumber /\<\%(\d[0-9_]*\%(\.\d[0-9_]*\)\=\|\.\d[0-9_]*\)\%([eE][+-]\=\d[0-9_]*\)\=\>/
                              \ nextgroup=@typescriptSymbols skipwhite skipempty

SCRIPT  /home/pyericz/.vimgo/plugged/yats.vim/syntax/basic/object.vim
Sourced 3 times
Total time:   0.000263
 Self time:   0.000263

count  total (s)   self (s)
    3              0.000085 syntax region  typescriptObjectLiteral         matchgroup=typescriptBraces
                              \ start=/{/ end=/}/
                              \ contains=@typescriptComments,typescriptObjectLabel,typescriptStringProperty,typescriptComputedPropertyName,typescriptObjectAsyncKeyword,typescriptTernary,typescriptCastKeyword
                              \ fold contained
                            
    3              0.000018 syntax keyword typescriptObjectAsyncKeyword async contained
                            
    3              0.000029 syntax match   typescriptObjectLabel  contained /\k\+\_s*/
                              \ nextgroup=typescriptObjectColon,@typescriptCallImpl
                              \ skipwhite skipempty
                            
    3              0.000040 syntax region  typescriptStringProperty   contained
                              \ start=/\z(["']\)/  skip=/\\\\\|\\\z1\|\\\n/  end=/\z1/
                              \ nextgroup=typescriptObjectColon,@typescriptCallImpl
                              \ skipwhite skipempty
                            
                            " syntax region  typescriptPropertyName    contained start=/\z(["']\)/  skip=/\\\\\|\\\z1\|\\\n/  end=/\z1(/me=e-1 nextgroup=@typescriptCallSignature skipwhite skipempty oneline
    3              0.000031 syntax region  typescriptComputedPropertyName  contained matchgroup=typescriptBraces
                              \ start=/\[/rs=s+1 end=/]/
                              \ contains=@typescriptValue
                              \ nextgroup=typescriptObjectColon,@typescriptCallImpl
                              \ skipwhite skipempty
                            
                            " syntax region  typescriptComputedPropertyName  contained matchgroup=typescriptPropertyName start=/\[/rs=s+1 end=/]\_s*:/he=e-1 contains=@typescriptValue nextgroup=@typescriptValue skipwhite skipempty
                            " syntax region  typescriptComputedPropertyName  contained matchgroup=typescriptPropertyName start=/\[/rs=s+1 end=/]\_s*(/me=e-1 contains=@typescriptValue nextgroup=@typescriptCallSignature skipwhite skipempty
                            " Value for object, statement for label statement
    3              0.000009 syntax match typescriptRestOrSpread /\.\.\./ contained
    3              0.000032 syntax match typescriptObjectSpread /\.\.\./ contained containedin=typescriptObjectLiteral,typescriptArray nextgroup=@typescriptValue
                            
    3              0.000009 syntax match typescriptObjectColon contained /:/ nextgroup=@typescriptValue skipwhite skipempty

SCRIPT  /home/pyericz/.vimgo/plugged/yats.vim/syntax/basic/symbols.vim
Sourced 3 times
Total time:   0.000237
 Self time:   0.000237

count  total (s)   self (s)
                            " + - ^ ~
    3              0.000013 syntax match typescriptUnaryOp /[+\-~!]/
                             \ nextgroup=@typescriptValue
                             \ skipwhite
                            
    3              0.000021 syntax region typescriptTernary matchgroup=typescriptTernaryOp start=/?[.?]\@!/ end=/:/ contained contains=@typescriptValue,@typescriptComments nextgroup=@typescriptValue skipwhite skipempty
                            
    3              0.000010 syntax match   typescriptAssign  /=/ nextgroup=@typescriptValue
                              \ skipwhite skipempty
                            
                            " 2: ==, ===
    3              0.000009 syntax match   typescriptBinaryOp contained /===\?/ nextgroup=@typescriptValue skipwhite skipempty
                            " 6: >>>=, >>>, >>=, >>, >=, >
    3              0.000012 syntax match   typescriptBinaryOp contained />\(>>=\|>>\|>=\|>\|=\)\?/ nextgroup=@typescriptValue skipwhite skipempty
                            " 4: <<=, <<, <=, <
    3              0.000009 syntax match   typescriptBinaryOp contained /<\(<=\|<\|=\)\?/ nextgroup=@typescriptValue skipwhite skipempty
                            " 3: ||, |=, |, ||=
    3              0.000009 syntax match   typescriptBinaryOp contained /||\?=\?/ nextgroup=@typescriptValue skipwhite skipempty
                            " 4: &&, &=, &, &&=
    3              0.000009 syntax match   typescriptBinaryOp contained /&&\?=\?/ nextgroup=@typescriptValue skipwhite skipempty
                            " 2: ??, ??=
    3              0.000009 syntax match   typescriptBinaryOp contained /??=\?/ nextgroup=@typescriptValue skipwhite skipempty
                            " 2: *=, *
    3              0.000009 syntax match   typescriptBinaryOp contained /\*=\?/ nextgroup=@typescriptValue skipwhite skipempty
                            " 2: %=, %
    3              0.000007 syntax match   typescriptBinaryOp contained /%=\?/ nextgroup=@typescriptValue skipwhite skipempty
                            " 2: /=, /
    3              0.000010 syntax match   typescriptBinaryOp contained +/\(=\|[^\*/]\@=\)+ nextgroup=@typescriptValue skipwhite skipempty
    3              0.000008 syntax match   typescriptBinaryOp contained /!==\?/ nextgroup=@typescriptValue skipwhite skipempty
                            " 2: !=, !==
    3              0.000008 syntax match   typescriptBinaryOp contained /+\(+\|=\)\?/ nextgroup=@typescriptValue skipwhite skipempty
                            " 3: +, ++, +=
    3              0.000008 syntax match   typescriptBinaryOp contained /-\(-\|=\)\?/ nextgroup=@typescriptValue skipwhite skipempty
                            " 3: -, --, -=
                            
                            " exponentiation operator
                            " 2: **, **=
    3              0.000009 syntax match typescriptBinaryOp contained /\*\*=\?/ nextgroup=@typescriptValue
                            
    3              0.000057 syntax cluster typescriptSymbols               contains=typescriptBinaryOp,typescriptKeywordOp,typescriptTernary,typescriptAssign,typescriptCastKeyword

SCRIPT  /home/pyericz/.vimgo/plugged/yats.vim/syntax/basic/keyword.vim
Sourced 3 times
Total time:   0.000942
 Self time:   0.000942

count  total (s)   self (s)
                            "Import
    3              0.000016 syntax keyword typescriptImport                from as
    3              0.000043 syntax keyword typescriptImport                import
                              \ nextgroup=typescriptImportType,typescriptTypeBlock,typescriptDefaultImportName
                              \ skipwhite
    3              0.000010 syntax keyword typescriptImportType            type
                              \ contained
    3              0.000021 syntax keyword typescriptExport                export
                              \ nextgroup=typescriptExportType
                              \ skipwhite
    3              0.000015 syntax match typescriptExportType              /\<type\s*{\@=/
                              \ contained skipwhite skipempty skipnl
    3              0.000010 syntax keyword typescriptModule                namespace module
                            
                            
    3              0.000012 syntax keyword typescriptCastKeyword           as satisfies
                              \ nextgroup=@typescriptType
                              \ skipwhite
                            
    3              0.000010 syntax keyword typescriptVariable              let var
                              \ nextgroup=@typescriptVariableDeclarations
                              \ skipwhite skipempty
                            
    3              0.000021 syntax keyword typescriptVariable const
                              \ nextgroup=typescriptEnum,@typescriptVariableDeclarations
                              \ skipwhite skipempty
                            
    3              0.000039 syntax region typescriptEnum matchgroup=typescriptEnumKeyword start=/enum / end=/\ze{/
                              \ nextgroup=typescriptBlock
                              \ skipwhite
                            
    3              0.000009 syntax keyword typescriptKeywordOp
                              \ contained in instanceof nextgroup=@typescriptValue
    3              0.000013 syntax keyword typescriptOperator              delete new typeof void
                              \ nextgroup=@typescriptValue
                              \ skipwhite skipempty
                            
    3              0.000008 syntax keyword typescriptForOperator           contained in of
    3              0.000010 syntax keyword typescriptBoolean               true false nextgroup=@typescriptSymbols skipwhite skipempty
    3              0.000034 syntax keyword typescriptMessage               alert confirm prompt status
                              \ nextgroup=typescriptDotNotation,typescriptFuncCallArg
    3              0.000011 syntax keyword typescriptGlobal                self top parent
                              \ nextgroup=@afterIdentifier
                            
                            "Statement Keywords
    3              0.000020 syntax keyword typescriptConditional           if else switch
                              \ nextgroup=typescriptConditionalParen
                              \ skipwhite skipempty skipnl
    3              0.000008 syntax keyword typescriptConditionalElse       else
    3              0.000018 syntax keyword typescriptRepeat                do while for nextgroup=typescriptLoopParen skipwhite skipempty
    3              0.000027 syntax keyword typescriptRepeat                for nextgroup=typescriptLoopParen,typescriptAsyncFor skipwhite skipempty
    3              0.000020 syntax keyword typescriptBranch                break continue containedin=typescriptBlock
    3              0.000020 syntax keyword typescriptCase                  case nextgroup=@typescriptPrimitive skipwhite containedin=typescriptBlock
    3              0.000038 syntax keyword typescriptDefault               default containedin=typescriptBlock nextgroup=@typescriptValue,typescriptClassKeyword,typescriptInterfaceKeyword skipwhite oneline
    3              0.000008 syntax keyword typescriptStatementKeyword      with
    3              0.000019 syntax keyword typescriptStatementKeyword      yield skipwhite nextgroup=@typescriptValue containedin=typescriptBlock
                            
    3              0.000008 syntax keyword typescriptTry                   try
    3              0.000015 syntax keyword typescriptExceptions            catch throw finally
    3              0.000012 syntax keyword typescriptDebugger              debugger
                            
    3              0.000018 syntax keyword typescriptAsyncFor              await nextgroup=typescriptLoopParen skipwhite skipempty contained
                            
    3              0.000070 syntax region  typescriptLoopParen             contained matchgroup=typescriptParens
                              \ start=/(/ end=/)/
                              \ contains=typescriptVariable,typescriptForOperator,typescriptEndColons,@typescriptValue,@typescriptComments
                              \ nextgroup=typescriptBlock
                              \ skipwhite skipempty
    3              0.000030 syntax region  typescriptConditionalParen             contained matchgroup=typescriptParens
                              \ start=/(/ end=/)/
                              \ contains=@typescriptValue,@typescriptComments
                              \ nextgroup=typescriptBlock
                              \ skipwhite skipempty
    3              0.000013 syntax match   typescriptEndColons             /[;,]/ contained
                            
    3              0.000013 syntax keyword typescriptAmbientDeclaration declare nextgroup=@typescriptAmbients
                              \ skipwhite skipempty
                            
    3              0.000078 syntax cluster typescriptAmbients contains=
                              \ typescriptVariable,
                              \ typescriptFuncKeyword,
                              \ typescriptClassKeyword,
                              \ typescriptAbstract,
                              \ typescriptEnumKeyword,typescriptEnum,
                              \ typescriptModule
                            
    3              0.000014 syntax keyword typescriptIdentifier            arguments  nextgroup=@afterIdentifier
    3              0.000029 syntax match typescriptDefaultImportName /\v\h\k*( |,)/
                              \ contained
                              \ nextgroup=typescriptTypeBlock
                              \ skipwhite skipempty
                            
    3              0.000041 syntax region  typescriptTypeBlock
                              \ matchgroup=typescriptBraces
                              \ start=/{/ end=/}/
                              \ contained
                              \ contains=typescriptIdentifierName,typescriptImportType
                              \ fold
                            
                            "Program Keywords
    3              0.000028 exec 'syntax keyword typescriptNull null '.(exists('g:typescript_conceal_null') ? 'conceal cchar='.g:typescript_conceal_null : '').' nextgroup=@typescriptSymbols skipwhite skipempty'
    3              0.000020 exec 'syntax keyword typescriptNull undefined '.(exists('g:typescript_conceal_undefined') ? 'conceal cchar='.g:typescript_conceal_undefined : '').' nextgroup=@typescriptSymbols skipwhite skipempty'
                            "this
    3              0.000018 exec 'syntax keyword typescriptIdentifier this '.(exists('g:typescript_conceal_this') ? 'conceal cchar='.g:typescript_conceal_this : '').' nextgroup=@afterIdentifier'
    3              0.000015 exec 'syntax keyword typescriptIdentifier super '.(exists('g:typescript_conceal_super') ? 'conceal cchar='.g:typescript_conceal_super : '').' nextgroup=@afterIdentifier'
                            "JavaScript Prototype
    3              0.000016 exec 'syntax keyword typescriptPrototype prototype '.(exists('g:typescript_conceal_prototype') ? 'conceal cchar='.g:typescript_conceal_prototype : '').' nextgroup=@afterIdentifier'
    3              0.000027 exec 'syntax keyword typescriptStatementKeyword return '.(exists('g:typescript_conceal_return') ? 'conceal cchar='.g:typescript_conceal_return : '').' skipwhite contained nextgroup=@typescriptValue containedin=typescriptBlock'

SCRIPT  /home/pyericz/.vimgo/plugged/yats.vim/syntax/basic/doc.vim
Sourced 3 times
Total time:   0.000950
 Self time:   0.000950

count  total (s)   self (s)
                            "Syntax coloring for Node.js shebang line
    3              0.000016 syntax match   shellbang "^#!.*node\>"
    3              0.000012 syntax match   shellbang "^#!.*iojs\>"
                            
                            
                            "JavaScript comments
    3              0.000012 syntax keyword typescriptCommentTodo TODO FIXME XXX TBD
    3              0.000015 syntax match typescriptMagicComment "@ts-\%(ignore\|expect-error\)\>"
    3              0.000049 syntax match   typescriptLineComment "//.*"
                              \ contains=@Spell,typescriptCommentTodo,typescriptRef,typescriptMagicComment
    3              0.000027 syntax region  typescriptComment
                              \ start="/\*"  end="\*/"
                              \ contains=@Spell,typescriptCommentTodo extend
    3              0.000034 syntax cluster typescriptComments
                              \ contains=typescriptDocComment,typescriptComment,typescriptLineComment
                            
    3              0.000028 syntax match   typescriptRef  +///\s*<reference\s\+.*\/>$+
                              \ contains=typescriptString
    3              0.000024 syntax match   typescriptRef  +///\s*<amd-dependency\s\+.*\/>$+
                              \ contains=typescriptString
    3              0.000022 syntax match   typescriptRef  +///\s*<amd-module\s\+.*\/>$+
                              \ contains=typescriptString
                            
                            "JSDoc
    3              0.000003 syntax case ignore
                            
    3              0.000043 syntax region  typescriptDocComment            matchgroup=typescriptComment
                              \ start="/\*\*"  end="\*/"
                              \ contains=typescriptDocNotation,typescriptCommentTodo,@Spell
                              \ fold keepend
    3              0.000018 syntax match   typescriptDocNotation           contained /@/ nextgroup=typescriptDocTags
                            
    3              0.000017 syntax keyword typescriptDocTags               contained constant constructor constructs function ignore inner private public readonly static
    3              0.000014 syntax keyword typescriptDocTags               contained const dict expose inheritDoc interface nosideeffects override protected struct internal
    3              0.000009 syntax keyword typescriptDocTags               contained example global
    3              0.000009 syntax keyword typescriptDocTags               contained alpha beta defaultValue eventProperty experimental label
    3              0.000009 syntax keyword typescriptDocTags               contained packageDocumentation privateRemarks remarks sealed typeParam
                            
                            " syntax keyword typescriptDocTags               contained ngdoc nextgroup=typescriptDocNGDirective
    3              0.000009 syntax keyword typescriptDocTags               contained ngdoc scope priority animations
    3              0.000023 syntax keyword typescriptDocTags               contained ngdoc restrict methodOf propertyOf eventOf eventType nextgroup=typescriptDocParam skipwhite
    3              0.000024 syntax keyword typescriptDocNGDirective        contained overview service object function method property event directive filter inputType error
                            
    3              0.000007 syntax keyword typescriptDocTags               contained abstract virtual access augments
                            
    3              0.000022 syntax keyword typescriptDocTags               contained arguments callback lends memberOf name type kind link mixes mixin tutorial nextgroup=typescriptDocParam skipwhite
    3              0.000017 syntax keyword typescriptDocTags               contained variation nextgroup=typescriptDocNumParam skipwhite
                            
    3              0.000018 syntax keyword typescriptDocTags               contained author class classdesc copyright default defaultvalue nextgroup=typescriptDocDesc skipwhite
    3              0.000018 syntax keyword typescriptDocTags               contained deprecated description external host nextgroup=typescriptDocDesc skipwhite
    3              0.000019 syntax keyword typescriptDocTags               contained file fileOverview overview namespace requires since version nextgroup=typescriptDocDesc skipwhite
    3              0.000017 syntax keyword typescriptDocTags               contained summary todo license preserve nextgroup=typescriptDocDesc skipwhite
                            
    3              0.000015 syntax keyword typescriptDocTags               contained borrows exports nextgroup=typescriptDocA skipwhite
    3              0.000027 syntax keyword typescriptDocTags               contained param arg argument property prop module nextgroup=typescriptDocNamedParamType,typescriptDocParamName skipwhite
    3              0.000018 syntax keyword typescriptDocTags               contained define enum extends implements this typedef nextgroup=typescriptDocParamType skipwhite
    3              0.000025 syntax keyword typescriptDocTags               contained return returns throws exception nextgroup=typescriptDocParamType,typescriptDocParamName skipwhite
    3              0.000015 syntax keyword typescriptDocTags               contained see nextgroup=typescriptDocRef skipwhite
                            
    3              0.000016 syntax keyword typescriptDocTags               contained function func method nextgroup=typescriptDocName skipwhite
    3              0.000010 syntax match   typescriptDocName               contained /\h\w*/
                            
    3              0.000015 syntax keyword typescriptDocTags               contained fires event nextgroup=typescriptDocEventRef skipwhite
    3              0.000014 syntax match   typescriptDocEventRef           contained /\h\w*#\(\h\w*\:\)\?\h\w*/
                            
    3              0.000021 syntax match   typescriptDocNamedParamType     contained /{.\+}/ nextgroup=typescriptDocParamName skipwhite
    3              0.000022 syntax match   typescriptDocParamName          contained /\[\?0-9a-zA-Z_\.]\+\]\?/ nextgroup=typescriptDocDesc skipwhite
    3              0.000017 syntax match   typescriptDocParamType          contained /{.\+}/ nextgroup=typescriptDocDesc skipwhite
    3              0.000020 syntax match   typescriptDocA                  contained /\%(#\|\w\|\.\|:\|\/\)\+/ nextgroup=typescriptDocAs skipwhite
    3              0.000017 syntax match   typescriptDocAs                 contained /\s*as\s*/ nextgroup=typescriptDocB skipwhite
    3              0.000009 syntax match   typescriptDocB                  contained /\%(#\|\w\|\.\|:\|\/\)\+/
    3              0.000010 syntax match   typescriptDocParam              contained /\%(#\|\w\|\.\|:\|\/\|-\)\+/
    3              0.000009 syntax match   typescriptDocNumParam           contained /\d\+/
    3              0.000009 syntax match   typescriptDocRef                contained /\%(#\|\w\|\.\|:\|\/\)\+/
    3              0.000035 syntax region  typescriptDocLinkTag            contained matchgroup=typescriptDocLinkTag start=/{/ end=/}/ contains=typescriptDocTags
                            
    3              0.000040 syntax cluster typescriptDocs                  contains=typescriptDocParamType,typescriptDocNamedParamType,typescriptDocParam
                            
    3              0.000007 if exists("main_syntax") && main_syntax == "typescript"
    3              0.000004   syntax sync clear
    3              0.000006   syntax sync ccomment typescriptComment minlines=200
    3              0.000002 endif
                            
    3              0.000001 syntax case match

SCRIPT  /home/pyericz/.vimgo/plugged/yats.vim/syntax/basic/type.vim
Sourced 3 times
Total time:   0.001228
 Self time:   0.001228

count  total (s)   self (s)
                            " Types
    3              0.000010 syntax match typescriptOptionalMark /?/ contained
                            
    3              0.000024 syntax cluster typescriptTypeParameterCluster contains=
                              \ typescriptTypeParameter,
                              \ typescriptGenericDefault
                            
    3              0.000020 syntax region typescriptTypeParameters matchgroup=typescriptTypeBrackets
                              \ start=/</ end=/>/
                              \ contains=@typescriptTypeParameterCluster
                              \ contained
                            
    3              0.000020 syntax match typescriptTypeParameter /\K\k*/
                              \ nextgroup=typescriptConstraint
                              \ contained skipwhite skipnl
                            
    3              0.000013 syntax keyword typescriptConstraint extends
                              \ nextgroup=@typescriptType
                              \ contained skipwhite skipnl
                            
    3              0.000009 syntax match typescriptGenericDefault /=/
                              \ nextgroup=@typescriptType
                              \ contained skipwhite
                            
                            "><
                            " class A extend B<T> {} // ClassBlock
                            " func<T>() // FuncCallArg
    3              0.000040 syntax region typescriptTypeArguments matchgroup=typescriptTypeBrackets
                              \ start=/\></ end=/>/
                              \ contains=@typescriptType
                              \ nextgroup=typescriptFuncCallArg,@typescriptTypeOperator
                              \ contained skipwhite
                            
                            
    3              0.000027 syntax cluster typescriptType contains=
                              \ @typescriptPrimaryType,
                              \ typescriptUnion,
                              \ @typescriptFunctionType,
                              \ typescriptConstructorType
                            
                            " array type: A[]
                            " type indexing A['key']
    3              0.000035 syntax region typescriptTypeBracket contained
                              \ start=/\[/ end=/\]/
                              \ contains=typescriptString,typescriptNumber
                              \ nextgroup=@typescriptTypeOperator
                              \ skipwhite skipempty
                            
    3              0.000089 syntax cluster typescriptPrimaryType contains=
                              \ typescriptParenthesizedType,
                              \ typescriptPredefinedType,
                              \ typescriptTypeReference,
                              \ typescriptObjectType,
                              \ typescriptTupleType,
                              \ typescriptTypeQuery,
                              \ typescriptStringLiteralType,
                              \ typescriptTemplateLiteralType,
                              \ typescriptReadonlyArrayKeyword,
                              \ typescriptAssertType
                            
    3              0.000029 syntax region  typescriptStringLiteralType contained
                              \ start=/\z(["']\)/  skip=/\\\\\|\\\z1\|\\\n/  end=/\z1\|$/
                              \ nextgroup=typescriptUnion
                              \ skipwhite skipempty
                            
    3              0.000032 syntax region  typescriptTemplateLiteralType contained
                              \ start=/`/  skip=/\\\\\|\\`\|\n/  end=/`\|$/
                              \ contains=typescriptTemplateSubstitutionType
                              \ nextgroup=typescriptTypeOperator
                              \ skipwhite skipempty
                            
    3              0.000018 syntax region  typescriptTemplateSubstitutionType matchgroup=typescriptTemplateSB
                              \ start=/\${/ end=/}/
                              \ contains=@typescriptType
                              \ contained
                            
    3              0.000018 syntax region typescriptParenthesizedType matchgroup=typescriptParens
                              \ start=/(/ end=/)/
                              \ contains=@typescriptType
                              \ nextgroup=@typescriptTypeOperator
                              \ contained skipwhite skipempty fold
                            
    3              0.000037 syntax match typescriptTypeReference /\K\k*\(\.\K\k*\)*/
                              \ nextgroup=typescriptTypeArguments,@typescriptTypeOperator,typescriptUserDefinedType
                              \ skipwhite contained skipempty
                            
    3              0.000015 syntax keyword typescriptPredefinedType any number boolean string void never undefined null object unknown
                              \ nextgroup=@typescriptTypeOperator
                              \ contained skipwhite skipempty
                            
    3              0.000011 syntax match typescriptPredefinedType /unique symbol/
                              \ nextgroup=@typescriptTypeOperator
                              \ contained skipwhite skipempty
                            
    3              0.000064 syntax region typescriptObjectType matchgroup=typescriptBraces
                              \ start=/{/ end=/}/
                              \ contains=@typescriptTypeMember,typescriptEndColons,@typescriptComments,typescriptAccessibilityModifier,typescriptReadonlyModifier
                              \ nextgroup=@typescriptTypeOperator
                              \ contained skipwhite skipnl fold
                            
    3              0.000024 syntax cluster typescriptTypeMember contains=
                              \ @typescriptCallSignature,
                              \ typescriptConstructSignature,
                              \ typescriptIndexSignature,
                              \ @typescriptMembers
                            
    3              0.000010 syntax match typescriptTupleLable /\K\k*?\?:/
                                \ contained
                            
    3              0.000054 syntax region typescriptTupleType matchgroup=typescriptBraces
                              \ start=/\[/ end=/\]/
                              \ contains=@typescriptType,@typescriptComments,typescriptRestOrSpread,typescriptTupleLable
                              \ contained skipwhite
                            
    3              0.000038 syntax cluster typescriptTypeOperator
                              \ contains=typescriptUnion,typescriptTypeBracket,typescriptConstraint,typescriptConditionalType
                            
    3              0.000011 syntax match typescriptUnion /|\|&/ contained nextgroup=@typescriptPrimaryType skipwhite skipempty
                            
    3              0.000009 syntax match typescriptConditionalType /?\|:/ contained nextgroup=@typescriptPrimaryType skipwhite skipempty
                            
    3              0.000018 syntax cluster typescriptFunctionType contains=typescriptGenericFunc,typescriptFuncType
    3              0.000048 syntax region typescriptGenericFunc matchgroup=typescriptTypeBrackets
                              \ start=/</ end=/>/
                              \ contains=typescriptTypeParameter
                              \ nextgroup=typescriptFuncType
                              \ containedin=typescriptFunctionType
                              \ contained skipwhite skipnl
                            
    3              0.000033 syntax region typescriptFuncType matchgroup=typescriptParens
                              \ start=/(\(\k\+:\|)\)\@=/ end=/)\s*=>/me=e-2
                              \ contains=@typescriptParameterList
                              \ nextgroup=typescriptFuncTypeArrow
                              \ contained skipwhite skipnl oneline
                            
    3              0.000021 syntax match typescriptFuncTypeArrow /=>/
                              \ nextgroup=@typescriptType
                              \ containedin=typescriptFuncType
                              \ contained skipwhite skipnl
                            
    3              0.000012 syntax keyword typescriptConstructorType new
                              \ nextgroup=@typescriptFunctionType
                              \ contained skipwhite skipnl
                            
    3              0.000010 syntax keyword typescriptUserDefinedType is
                              \ contained nextgroup=@typescriptType skipwhite skipempty
                            
    3              0.000024 syntax keyword typescriptTypeQuery typeof keyof
                              \ nextgroup=typescriptTypeReference
                              \ contained skipwhite skipnl
                            
    3              0.000018 syntax keyword typescriptAssertType asserts
                              \ nextgroup=typescriptTypeReference
                              \ contained skipwhite skipnl
                            
    3              0.000022 syntax cluster typescriptCallSignature contains=typescriptGenericCall,typescriptCall
    3              0.000037 syntax region typescriptGenericCall matchgroup=typescriptTypeBrackets
                              \ start=/</ end=/>/
                              \ contains=typescriptTypeParameter
                              \ nextgroup=typescriptCall
                              \ contained skipwhite skipnl
    3              0.000047 syntax region typescriptCall matchgroup=typescriptParens
                              \ start=/(/ end=/)/
                              \ contains=typescriptDecorator,@typescriptParameterList,@typescriptComments
                              \ nextgroup=typescriptTypeAnnotation,typescriptBlock
                              \ contained skipwhite skipnl
                            
    3              0.000013 syntax match typescriptTypeAnnotation /:/
                              \ nextgroup=@typescriptType
                              \ contained skipwhite skipnl
                            
    3              0.000071 syntax cluster typescriptParameterList contains=
                              \ typescriptTypeAnnotation,
                              \ typescriptAccessibilityModifier,
                              \ typescriptReadonlyModifier,
                              \ typescriptOptionalMark,
                              \ typescriptRestOrSpread,
                              \ typescriptFuncComma,
                              \ typescriptDefaultParam
                            
    3              0.000008 syntax match typescriptFuncComma /,/ contained
                            
    3              0.000010 syntax match typescriptDefaultParam /=/
                              \ nextgroup=@typescriptValue
                              \ contained skipwhite
                            
    3              0.000011 syntax keyword typescriptConstructSignature new
                              \ nextgroup=@typescriptCallSignature
                              \ contained skipwhite
                            
    3              0.000054 syntax region typescriptIndexSignature matchgroup=typescriptBraces
                              \ start=/\[/ end=/\]/
                              \ contains=typescriptPredefinedType,typescriptMappedIn,typescriptString
                              \ nextgroup=typescriptTypeAnnotation
                              \ contained skipwhite oneline
                            
    3              0.000010 syntax keyword typescriptMappedIn in
                              \ nextgroup=@typescriptType
                              \ contained skipwhite skipnl skipempty
                            
    3              0.000023 syntax keyword typescriptAliasKeyword type
                              \ nextgroup=typescriptAliasDeclaration
                              \ skipwhite skipnl skipempty
                            
    3              0.000035 syntax region typescriptAliasDeclaration matchgroup=typescriptUnion
                              \ start=/ / end=/=/
                              \ nextgroup=@typescriptType
                              \ contains=typescriptConstraint,typescriptTypeParameters
                              \ contained skipwhite skipempty
                            
    3              0.000012 syntax keyword typescriptReadonlyArrayKeyword readonly
                              \ nextgroup=@typescriptPrimaryType
                              \ skipwhite

SCRIPT  /home/pyericz/.vimgo/plugged/yats.vim/syntax/yats.vim
Sourced 3 times
Total time:   0.021708
 Self time:   0.021707

count  total (s)   self (s)
    3   0.000737   0.000736 runtime syntax/yats/typescript.vim
    3              0.000357 runtime syntax/yats/es6-number.vim
    3              0.000370 runtime syntax/yats/es6-string.vim
    3              0.000470 runtime syntax/yats/es6-array.vim
    3              0.000430 runtime syntax/yats/es6-object.vim
    3              0.000267 runtime syntax/yats/es6-symbol.vim
    3              0.000190 runtime syntax/yats/es6-function.vim
    3              0.000329 runtime syntax/yats/es6-math.vim
    3              0.000441 runtime syntax/yats/es6-date.vim
    3              0.000210 runtime syntax/yats/es6-json.vim
    3              0.000277 runtime syntax/yats/es6-regexp.vim
    3              0.000231 runtime syntax/yats/es6-map.vim
    3              0.000224 runtime syntax/yats/es6-set.vim
    3              0.000184 runtime syntax/yats/es6-proxy.vim
    3              0.000258 runtime syntax/yats/es6-promise.vim
    3              0.000251 runtime syntax/yats/es6-reflect.vim
    3              0.000201 runtime syntax/yats/ecma-402.vim
    3              0.000250 runtime syntax/yats/node.vim
    3              0.000230 runtime syntax/yats/test.vim
    3              0.004575 runtime syntax/yats/web.vim
    3              0.002956 runtime syntax/yats/web-window.vim
    3              0.000347 runtime syntax/yats/web-navigator.vim
    3              0.000220 runtime syntax/yats/web-location.vim
    3              0.000210 runtime syntax/yats/web-history.vim
    3              0.000249 runtime syntax/yats/web-console.vim
    3              0.000255 runtime syntax/yats/web-xhr.vim
    3              0.000541 runtime syntax/yats/web-blob.vim
    3              0.000282 runtime syntax/yats/web-crypto.vim
    3              0.000431 runtime syntax/yats/web-fetch.vim
    3              0.000291 runtime syntax/yats/web-service-worker.vim
    3              0.000254 runtime syntax/yats/web-encoding.vim
    3              0.000196 runtime syntax/yats/web-geo.vim
    3              0.000189 runtime syntax/yats/web-network.vim
    3              0.000455 runtime syntax/yats/web-payment.vim
    3              0.000352 runtime syntax/yats/dom-node.vim
    3              0.000255 runtime syntax/yats/dom-elem.vim
    3              0.000480 runtime syntax/yats/dom-document.vim
    3              0.000997 runtime syntax/yats/dom-event.vim
    3              0.000239 runtime syntax/yats/dom-storage.vim
    3              0.000204 runtime syntax/yats/dom-form.vim
    3              0.000589 runtime syntax/yats/css.vim
                            
                            
    3              0.000007 let typescript_props = 1
                            
    3              0.001195 runtime syntax/yats/event.vim

SCRIPT  /home/pyericz/.vimgo/plugged/yats.vim/syntax/yats/typescript.vim
Sourced 3 times
Total time:   0.000600
 Self time:   0.000600

count  total (s)   self (s)
    3              0.000022 syntax keyword typescriptGlobal containedin=typescriptIdentifierName Function Boolean
    3              0.000018 syntax keyword typescriptGlobal containedin=typescriptIdentifierName Error EvalError
    3              0.000018 syntax keyword typescriptGlobal containedin=typescriptIdentifierName InternalError
    3              0.000018 syntax keyword typescriptGlobal containedin=typescriptIdentifierName RangeError ReferenceError
    3              0.000016 syntax keyword typescriptGlobal containedin=typescriptIdentifierName StopIteration
    3              0.000018 syntax keyword typescriptGlobal containedin=typescriptIdentifierName SyntaxError TypeError
    3              0.000017 syntax keyword typescriptGlobal containedin=typescriptIdentifierName URIError Date
    3              0.000016 syntax keyword typescriptGlobal containedin=typescriptIdentifierName Float32Array
    3              0.000017 syntax keyword typescriptGlobal containedin=typescriptIdentifierName Float64Array
    3              0.000015 syntax keyword typescriptGlobal containedin=typescriptIdentifierName Int16Array Int32Array
    3              0.000018 syntax keyword typescriptGlobal containedin=typescriptIdentifierName Int8Array Uint16Array
    3              0.000016 syntax keyword typescriptGlobal containedin=typescriptIdentifierName Uint32Array Uint8Array
    3              0.000016 syntax keyword typescriptGlobal containedin=typescriptIdentifierName Uint8ClampedArray
    3              0.000017 syntax keyword typescriptGlobal containedin=typescriptIdentifierName ParallelArray
    3              0.000015 syntax keyword typescriptGlobal containedin=typescriptIdentifierName ArrayBuffer DataView
    3              0.000018 syntax keyword typescriptGlobal containedin=typescriptIdentifierName Iterator Generator
    3              0.000017 syntax keyword typescriptGlobal containedin=typescriptIdentifierName Reflect Proxy
    3              0.000017 syntax keyword typescriptGlobal containedin=typescriptIdentifierName arguments
    3              0.000039 if exists("did_typescript_hilink") | HiLink typescriptGlobal Structure
    3              0.000001 endif
    3              0.000029 syntax keyword typescriptGlobalMethod containedin=typescriptIdentifierName eval uneval nextgroup=typescriptFuncCallArg
    3              0.000025 syntax keyword typescriptGlobalMethod containedin=typescriptIdentifierName isFinite nextgroup=typescriptFuncCallArg
    3              0.000027 syntax keyword typescriptGlobalMethod containedin=typescriptIdentifierName isNaN parseFloat nextgroup=typescriptFuncCallArg
    3              0.000025 syntax keyword typescriptGlobalMethod containedin=typescriptIdentifierName parseInt nextgroup=typescriptFuncCallArg
    3              0.000025 syntax keyword typescriptGlobalMethod containedin=typescriptIdentifierName decodeURI nextgroup=typescriptFuncCallArg
    3              0.000026 syntax keyword typescriptGlobalMethod containedin=typescriptIdentifierName decodeURIComponent nextgroup=typescriptFuncCallArg
    3              0.000026 syntax keyword typescriptGlobalMethod containedin=typescriptIdentifierName encodeURI nextgroup=typescriptFuncCallArg
    3              0.000025 syntax keyword typescriptGlobalMethod containedin=typescriptIdentifierName encodeURIComponent nextgroup=typescriptFuncCallArg
    3              0.000013 syntax cluster props add=typescriptGlobalMethod
    3              0.000021 if exists("did_typescript_hilink") | HiLink typescriptGlobalMethod Structure
    3              0.000002 endif

SCRIPT  /home/pyericz/.vimgo/plugged/yats.vim/syntax/yats/es6-number.vim
Sourced 3 times
Total time:   0.000221
 Self time:   0.000221

count  total (s)   self (s)
    3              0.000036 syntax keyword typescriptGlobal containedin=typescriptIdentifierName Number nextgroup=typescriptGlobalNumberDot,typescriptFuncCallArg
    3              0.000033 syntax match   typescriptGlobalNumberDot /\./ contained nextgroup=typescriptNumberStaticProp,typescriptNumberStaticMethod,typescriptProp
    3              0.000008 syntax keyword typescriptNumberStaticProp contained EPSILON MAX_SAFE_INTEGER MAX_VALUE
    3              0.000006 syntax keyword typescriptNumberStaticProp contained MIN_SAFE_INTEGER MIN_VALUE NEGATIVE_INFINITY
    3              0.000005 syntax keyword typescriptNumberStaticProp contained NaN POSITIVE_INFINITY
    3              0.000019 if exists("did_typescript_hilink") | HiLink typescriptNumberStaticProp Keyword
    3              0.000002 endif
    3              0.000016 syntax keyword typescriptNumberStaticMethod contained isFinite isInteger isNaN isSafeInteger nextgroup=typescriptFuncCallArg
    3              0.000015 syntax keyword typescriptNumberStaticMethod contained parseFloat parseInt nextgroup=typescriptFuncCallArg
    3              0.000015 if exists("did_typescript_hilink") | HiLink typescriptNumberStaticMethod Keyword
    3              0.000002 endif
    3              0.000015 syntax keyword typescriptNumberMethod contained toExponential toFixed toLocaleString nextgroup=typescriptFuncCallArg
    3              0.000015 syntax keyword typescriptNumberMethod contained toPrecision toSource toString valueOf nextgroup=typescriptFuncCallArg
    3              0.000011 syntax cluster props add=typescriptNumberMethod
    3              0.000017 if exists("did_typescript_hilink") | HiLink typescriptNumberMethod Keyword
    3              0.000000 endif

SCRIPT  /home/pyericz/.vimgo/plugged/yats.vim/syntax/yats/es6-string.vim
Sourced 3 times
Total time:   0.000244
 Self time:   0.000244

count  total (s)   self (s)
    3              0.000034 syntax keyword typescriptGlobal containedin=typescriptIdentifierName String nextgroup=typescriptGlobalStringDot,typescriptFuncCallArg
    3              0.000024 syntax match   typescriptGlobalStringDot /\./ contained nextgroup=typescriptStringStaticMethod,typescriptProp
    3              0.000015 syntax keyword typescriptStringStaticMethod contained fromCharCode fromCodePoint raw nextgroup=typescriptFuncCallArg
    3              0.000016 if exists("did_typescript_hilink") | HiLink typescriptStringStaticMethod Keyword
    3              0.000002 endif
    3              0.000015 syntax keyword typescriptStringMethod contained anchor charAt charCodeAt codePointAt nextgroup=typescriptFuncCallArg
    3              0.000016 syntax keyword typescriptStringMethod contained concat endsWith includes indexOf lastIndexOf nextgroup=typescriptFuncCallArg
    3              0.000016 syntax keyword typescriptStringMethod contained link localeCompare match matchAll normalize nextgroup=typescriptFuncCallArg
    3              0.000015 syntax keyword typescriptStringMethod contained padStart padEnd repeat replace replaceAll search nextgroup=typescriptFuncCallArg
    3              0.000015 syntax keyword typescriptStringMethod contained slice split startsWith substr substring nextgroup=typescriptFuncCallArg
    3              0.000015 syntax keyword typescriptStringMethod contained toLocaleLowerCase toLocaleUpperCase nextgroup=typescriptFuncCallArg
    3              0.000015 syntax keyword typescriptStringMethod contained toLowerCase toString toUpperCase trim nextgroup=typescriptFuncCallArg
    3              0.000014 syntax keyword typescriptStringMethod contained trimEnd trimStart valueOf nextgroup=typescriptFuncCallArg
    3              0.000010 syntax cluster props add=typescriptStringMethod
    3              0.000015 if exists("did_typescript_hilink") | HiLink typescriptStringMethod Keyword
    3              0.000003 endif

SCRIPT  /home/pyericz/.vimgo/plugged/yats.vim/syntax/yats/es6-array.vim
Sourced 3 times
Total time:   0.000344
 Self time:   0.000344

count  total (s)   self (s)
    3              0.000033 syntax keyword typescriptGlobal containedin=typescriptIdentifierName Array nextgroup=typescriptGlobalArrayDot,typescriptFuncCallArg
    3              0.000023 syntax match   typescriptGlobalArrayDot /\./ contained nextgroup=typescriptArrayStaticMethod,typescriptProp
    3              0.000015 syntax keyword typescriptArrayStaticMethod contained from isArray of nextgroup=typescriptFuncCallArg
    3              0.000015 if exists("did_typescript_hilink") | HiLink typescriptArrayStaticMethod Keyword
    3              0.000001 endif
    3              0.000017 syntax keyword typescriptArrayMethod contained concat copyWithin entries every fill nextgroup=typescriptFuncCallArg
    3              0.000098 syntax keyword typescriptArrayMethod contained filter find findIndex flat flatMap forEach nextgroup=typescriptFuncCallArg
    3              0.000028 syntax keyword typescriptArrayMethod contained includes indexOf join keys lastIndexOf map nextgroup=typescriptFuncCallArg
    3              0.000029 syntax keyword typescriptArrayMethod contained pop push reduce reduceRight reverse nextgroup=typescriptFuncCallArg
    3              0.000026 syntax keyword typescriptArrayMethod contained shift slice some sort splice toLocaleString nextgroup=typescriptFuncCallArg
    3              0.000018 syntax keyword typescriptArrayMethod contained toSource toString unshift values nextgroup=typescriptFuncCallArg
    3              0.000016 syntax cluster props add=typescriptArrayMethod
    3              0.000017 if exists("did_typescript_hilink") | HiLink typescriptArrayMethod Keyword
    3              0.000003 endif

SCRIPT  /home/pyericz/.vimgo/plugged/yats.vim/syntax/yats/es6-object.vim
Sourced 3 times
Total time:   0.000299
 Self time:   0.000299

count  total (s)   self (s)
    3              0.000040 syntax keyword typescriptGlobal containedin=typescriptIdentifierName Object nextgroup=typescriptGlobalObjectDot,typescriptFuncCallArg
    3              0.000024 syntax match   typescriptGlobalObjectDot /\./ contained nextgroup=typescriptObjectStaticMethod,typescriptProp
    3              0.000022 syntax keyword typescriptObjectStaticMethod contained create defineProperties defineProperty nextgroup=typescriptFuncCallArg
    3              0.000023 syntax keyword typescriptObjectStaticMethod contained entries freeze fromEntries getOwnPropertyDescriptors nextgroup=typescriptFuncCallArg
    3              0.000020 syntax keyword typescriptObjectStaticMethod contained getOwnPropertyDescriptor getOwnPropertyNames nextgroup=typescriptFuncCallArg
    3              0.000020 syntax keyword typescriptObjectStaticMethod contained getOwnPropertySymbols getPrototypeOf nextgroup=typescriptFuncCallArg
    3              0.000022 syntax keyword typescriptObjectStaticMethod contained is isExtensible isFrozen isSealed nextgroup=typescriptFuncCallArg
    3              0.000017 syntax keyword typescriptObjectStaticMethod contained keys preventExtensions values nextgroup=typescriptFuncCallArg
    3              0.000017 if exists("did_typescript_hilink") | HiLink typescriptObjectStaticMethod Keyword
    3              0.000000 endif
    3              0.000019 syntax keyword typescriptObjectMethod contained getOwnPropertyDescriptors hasOwnProperty nextgroup=typescriptFuncCallArg
    3              0.000014 syntax keyword typescriptObjectMethod contained isPrototypeOf propertyIsEnumerable nextgroup=typescriptFuncCallArg
    3              0.000016 syntax keyword typescriptObjectMethod contained toLocaleString toString valueOf seal nextgroup=typescriptFuncCallArg
    3              0.000013 syntax keyword typescriptObjectMethod contained setPrototypeOf nextgroup=typescriptFuncCallArg
    3              0.000011 syntax cluster props add=typescriptObjectMethod
    3              0.000015 if exists("did_typescript_hilink") | HiLink typescriptObjectMethod Keyword
    3              0.000002 endif

SCRIPT  /home/pyericz/.vimgo/plugged/yats.vim/syntax/yats/es6-symbol.vim
Sourced 3 times
Total time:   0.000140
 Self time:   0.000140

count  total (s)   self (s)
    3              0.000033 syntax keyword typescriptGlobal containedin=typescriptIdentifierName Symbol nextgroup=typescriptGlobalSymbolDot,typescriptFuncCallArg
    3              0.000031 syntax match   typescriptGlobalSymbolDot /\./ contained nextgroup=typescriptSymbolStaticProp,typescriptSymbolStaticMethod,typescriptProp
    3              0.000007 syntax keyword typescriptSymbolStaticProp contained description length iterator match matchAll replace
    3              0.000006 syntax keyword typescriptSymbolStaticProp contained search split hasInstance isConcatSpreadable
    3              0.000006 syntax keyword typescriptSymbolStaticProp contained unscopables species toPrimitive
    3              0.000006 syntax keyword typescriptSymbolStaticProp contained toStringTag
    3              0.000016 if exists("did_typescript_hilink") | HiLink typescriptSymbolStaticProp Keyword
    3              0.000000 endif
    3              0.000015 syntax keyword typescriptSymbolStaticMethod contained for keyFor nextgroup=typescriptFuncCallArg
    3              0.000014 if exists("did_typescript_hilink") | HiLink typescriptSymbolStaticMethod Keyword
    3              0.000002 endif

SCRIPT  /home/pyericz/.vimgo/plugged/yats.vim/syntax/yats/es6-function.vim
Sourced 3 times
Total time:   0.000063
 Self time:   0.000063

count  total (s)   self (s)
    3              0.000018 syntax keyword typescriptGlobal containedin=typescriptIdentifierName Function
    3              0.000014 syntax keyword typescriptFunctionMethod contained apply bind call nextgroup=typescriptFuncCallArg
    3              0.000012 syntax cluster props add=typescriptFunctionMethod
    3              0.000014 if exists("did_typescript_hilink") | HiLink typescriptFunctionMethod Keyword
    3              0.000002 endif

SCRIPT  /home/pyericz/.vimgo/plugged/yats.vim/syntax/yats/es6-math.vim
Sourced 3 times
Total time:   0.000206
 Self time:   0.000206

count  total (s)   self (s)
    3              0.000034 syntax keyword typescriptGlobal containedin=typescriptIdentifierName Math nextgroup=typescriptGlobalMathDot,typescriptFuncCallArg
    3              0.000029 syntax match   typescriptGlobalMathDot /\./ contained nextgroup=typescriptMathStaticProp,typescriptMathStaticMethod,typescriptProp
    3              0.000009 syntax keyword typescriptMathStaticProp contained E LN10 LN2 LOG10E LOG2E PI SQRT1_2
    3              0.000005 syntax keyword typescriptMathStaticProp contained SQRT2
    3              0.000015 if exists("did_typescript_hilink") | HiLink typescriptMathStaticProp Keyword
    3              0.000000 endif
    3              0.000016 syntax keyword typescriptMathStaticMethod contained abs acos acosh asin asinh atan nextgroup=typescriptFuncCallArg
    3              0.000015 syntax keyword typescriptMathStaticMethod contained atan2 atanh cbrt ceil clz32 cos nextgroup=typescriptFuncCallArg
    3              0.000017 syntax keyword typescriptMathStaticMethod contained cosh exp expm1 floor fround hypot nextgroup=typescriptFuncCallArg
    3              0.000015 syntax keyword typescriptMathStaticMethod contained imul log log10 log1p log2 max nextgroup=typescriptFuncCallArg
    3              0.000016 syntax keyword typescriptMathStaticMethod contained min pow random round sign sin nextgroup=typescriptFuncCallArg
    3              0.000015 syntax keyword typescriptMathStaticMethod contained sinh sqrt tan tanh trunc nextgroup=typescriptFuncCallArg
    3              0.000013 if exists("did_typescript_hilink") | HiLink typescriptMathStaticMethod Keyword
    3              0.000003 endif

SCRIPT  /home/pyericz/.vimgo/plugged/yats.vim/syntax/yats/es6-date.vim
Sourced 3 times
Total time:   0.000316
 Self time:   0.000316

count  total (s)   self (s)
    3              0.000033 syntax keyword typescriptGlobal containedin=typescriptIdentifierName Date nextgroup=typescriptGlobalDateDot,typescriptFuncCallArg
    3              0.000022 syntax match   typescriptGlobalDateDot /\./ contained nextgroup=typescriptDateStaticMethod,typescriptProp
    3              0.000015 syntax keyword typescriptDateStaticMethod contained UTC now parse nextgroup=typescriptFuncCallArg
    3              0.000014 if exists("did_typescript_hilink") | HiLink typescriptDateStaticMethod Keyword
    3              0.000001 endif
    3              0.000015 syntax keyword typescriptDateMethod contained getDate getDay getFullYear getHours nextgroup=typescriptFuncCallArg
    3              0.000015 syntax keyword typescriptDateMethod contained getMilliseconds getMinutes getMonth nextgroup=typescriptFuncCallArg
    3              0.000015 syntax keyword typescriptDateMethod contained getSeconds getTime getTimezoneOffset nextgroup=typescriptFuncCallArg
    3              0.000014 syntax keyword typescriptDateMethod contained getUTCDate getUTCDay getUTCFullYear nextgroup=typescriptFuncCallArg
    3              0.000013 syntax keyword typescriptDateMethod contained getUTCHours getUTCMilliseconds getUTCMinutes nextgroup=typescriptFuncCallArg
    3              0.000015 syntax keyword typescriptDateMethod contained getUTCMonth getUTCSeconds setDate setFullYear nextgroup=typescriptFuncCallArg
    3              0.000015 syntax keyword typescriptDateMethod contained setHours setMilliseconds setMinutes nextgroup=typescriptFuncCallArg
    3              0.000014 syntax keyword typescriptDateMethod contained setMonth setSeconds setTime setUTCDate nextgroup=typescriptFuncCallArg
    3              0.000013 syntax keyword typescriptDateMethod contained setUTCFullYear setUTCHours setUTCMilliseconds nextgroup=typescriptFuncCallArg
    3              0.000015 syntax keyword typescriptDateMethod contained setUTCMinutes setUTCMonth setUTCSeconds nextgroup=typescriptFuncCallArg
    3              0.000015 syntax keyword typescriptDateMethod contained toDateString toISOString toJSON toLocaleDateString nextgroup=typescriptFuncCallArg
    3              0.000014 syntax keyword typescriptDateMethod contained toLocaleFormat toLocaleString toLocaleTimeString nextgroup=typescriptFuncCallArg
    3              0.000014 syntax keyword typescriptDateMethod contained toSource toString toTimeString toUTCString nextgroup=typescriptFuncCallArg
    3              0.000015 syntax keyword typescriptDateMethod contained valueOf nextgroup=typescriptFuncCallArg
    3              0.000010 syntax cluster props add=typescriptDateMethod
    3              0.000015 if exists("did_typescript_hilink") | HiLink typescriptDateMethod Keyword
    3              0.000000 endif

SCRIPT  /home/pyericz/.vimgo/plugged/yats.vim/syntax/yats/es6-json.vim
Sourced 3 times
Total time:   0.000088
 Self time:   0.000088

count  total (s)   self (s)
    3              0.000032 syntax keyword typescriptGlobal containedin=typescriptIdentifierName JSON nextgroup=typescriptGlobalJSONDot,typescriptFuncCallArg
    3              0.000022 syntax match   typescriptGlobalJSONDot /\./ contained nextgroup=typescriptJSONStaticMethod,typescriptProp
    3              0.000014 syntax keyword typescriptJSONStaticMethod contained parse stringify nextgroup=typescriptFuncCallArg
    3              0.000015 if exists("did_typescript_hilink") | HiLink typescriptJSONStaticMethod Keyword
    3              0.000002 endif

SCRIPT  /home/pyericz/.vimgo/plugged/yats.vim/syntax/yats/es6-regexp.vim
Sourced 3 times
Total time:   0.000153
 Self time:   0.000153

count  total (s)   self (s)
    3              0.000032 syntax keyword typescriptGlobal containedin=typescriptIdentifierName RegExp nextgroup=typescriptGlobalRegExpDot,typescriptFuncCallArg
    3              0.000023 syntax match   typescriptGlobalRegExpDot /\./ contained nextgroup=typescriptRegExpStaticProp,typescriptProp
    3              0.000004 syntax keyword typescriptRegExpStaticProp contained lastIndex
    3              0.000015 if exists("did_typescript_hilink") | HiLink typescriptRegExpStaticProp Keyword
    3              0.000002 endif
    3              0.000006 syntax keyword typescriptRegExpProp contained dotAll global ignoreCase multiline source sticky
    3              0.000010 syntax cluster props add=typescriptRegExpProp
    3              0.000015 if exists("did_typescript_hilink") | HiLink typescriptRegExpProp Keyword
    3              0.000001 endif
    3              0.000013 syntax keyword typescriptRegExpMethod contained exec test nextgroup=typescriptFuncCallArg
    3              0.000010 syntax cluster props add=typescriptRegExpMethod
    3              0.000014 if exists("did_typescript_hilink") | HiLink typescriptRegExpMethod Keyword
    3              0.000001 endif

SCRIPT  /home/pyericz/.vimgo/plugged/yats.vim/syntax/yats/es6-map.vim
Sourced 3 times
Total time:   0.000110
 Self time:   0.000110

count  total (s)   self (s)
    3              0.000019 syntax keyword typescriptGlobal containedin=typescriptIdentifierName Map WeakMap
    3              0.000004 syntax keyword typescriptES6MapProp contained size
    3              0.000011 syntax cluster props add=typescriptES6MapProp
    3              0.000013 if exists("did_typescript_hilink") | HiLink typescriptES6MapProp Keyword
    3              0.000003 endif
    3              0.000016 syntax keyword typescriptES6MapMethod contained clear delete entries forEach get has nextgroup=typescriptFuncCallArg
    3              0.000015 syntax keyword typescriptES6MapMethod contained keys set values nextgroup=typescriptFuncCallArg
    3              0.000010 syntax cluster props add=typescriptES6MapMethod
    3              0.000015 if exists("did_typescript_hilink") | HiLink typescriptES6MapMethod Keyword
    3              0.000000 endif

SCRIPT  /home/pyericz/.vimgo/plugged/yats.vim/syntax/yats/es6-set.vim
Sourced 3 times
Total time:   0.000104
 Self time:   0.000104

count  total (s)   self (s)
    3              0.000018 syntax keyword typescriptGlobal containedin=typescriptIdentifierName Set WeakSet
    3              0.000006 syntax keyword typescriptES6SetProp contained size
    3              0.000009 syntax cluster props add=typescriptES6SetProp
    3              0.000015 if exists("did_typescript_hilink") | HiLink typescriptES6SetProp Keyword
    3              0.000000 endif
    3              0.000016 syntax keyword typescriptES6SetMethod contained add clear delete entries forEach has nextgroup=typescriptFuncCallArg
    3              0.000015 syntax keyword typescriptES6SetMethod contained values nextgroup=typescriptFuncCallArg
    3              0.000009 syntax cluster props add=typescriptES6SetMethod
    3              0.000014 if exists("did_typescript_hilink") | HiLink typescriptES6SetMethod Keyword
    3              0.000001 endif

SCRIPT  /home/pyericz/.vimgo/plugged/yats.vim/syntax/yats/es6-proxy.vim
Sourced 3 times
Total time:   0.000062
 Self time:   0.000062

count  total (s)   self (s)
    3              0.000016 syntax keyword typescriptGlobal containedin=typescriptIdentifierName Proxy
    3              0.000006 syntax keyword typescriptProxyAPI contained getOwnPropertyDescriptor getOwnPropertyNames
    3              0.000008 syntax keyword typescriptProxyAPI contained defineProperty deleteProperty freeze seal
    3              0.000006 syntax keyword typescriptProxyAPI contained preventExtensions has hasOwn get set enumerate
    3              0.000006 syntax keyword typescriptProxyAPI contained iterate ownKeys apply construct
    3              0.000014 if exists("did_typescript_hilink") | HiLink typescriptProxyAPI Keyword
    3              0.000002 endif

SCRIPT  /home/pyericz/.vimgo/plugged/yats.vim/syntax/yats/es6-promise.vim
Sourced 3 times
Total time:   0.000131
 Self time:   0.000131

count  total (s)   self (s)
    3              0.000033 syntax keyword typescriptGlobal containedin=typescriptIdentifierName Promise nextgroup=typescriptGlobalPromiseDot,typescriptFuncCallArg
    3              0.000023 syntax match   typescriptGlobalPromiseDot /\./ contained nextgroup=typescriptPromiseStaticMethod,typescriptProp
    3              0.000016 syntax keyword typescriptPromiseStaticMethod contained all allSettled any race reject resolve nextgroup=typescriptFuncCallArg
    3              0.000015 if exists("did_typescript_hilink") | HiLink typescriptPromiseStaticMethod Keyword
    3              0.000000 endif
    3              0.000016 syntax keyword typescriptPromiseMethod contained then catch finally nextgroup=typescriptFuncCallArg
    3              0.000009 syntax cluster props add=typescriptPromiseMethod
    3              0.000014 if exists("did_typescript_hilink") | HiLink typescriptPromiseMethod Keyword
    3              0.000001 endif

SCRIPT  /home/pyericz/.vimgo/plugged/yats.vim/syntax/yats/es6-reflect.vim
Sourced 3 times
Total time:   0.000125
 Self time:   0.000125

count  total (s)   self (s)
    3              0.000016 syntax keyword typescriptGlobal containedin=typescriptIdentifierName Reflect
    3              0.000016 syntax keyword typescriptReflectMethod contained apply construct defineProperty deleteProperty nextgroup=typescriptFuncCallArg
    3              0.000030 syntax keyword typescriptReflectMethod contained enumerate get getOwnPropertyDescriptor nextgroup=typescriptFuncCallArg
    3              0.000016 syntax keyword typescriptReflectMethod contained getPrototypeOf has isExtensible ownKeys nextgroup=typescriptFuncCallArg
    3              0.000015 syntax keyword typescriptReflectMethod contained preventExtensions set setPrototypeOf nextgroup=typescriptFuncCallArg
    3              0.000011 syntax cluster props add=typescriptReflectMethod
    3              0.000015 if exists("did_typescript_hilink") | HiLink typescriptReflectMethod Keyword
    3              0.000002 endif

SCRIPT  /home/pyericz/.vimgo/plugged/yats.vim/syntax/yats/ecma-402.vim
Sourced 3 times
Total time:   0.000076
 Self time:   0.000076

count  total (s)   self (s)
    3              0.000017 syntax keyword typescriptGlobal containedin=typescriptIdentifierName Intl
    3              0.000015 syntax keyword typescriptIntlMethod contained Collator DateTimeFormat NumberFormat nextgroup=typescriptFuncCallArg
    3              0.000015 syntax keyword typescriptIntlMethod contained PluralRules nextgroup=typescriptFuncCallArg
    3              0.000010 syntax cluster props add=typescriptIntlMethod
    3              0.000015 if exists("did_typescript_hilink") | HiLink typescriptIntlMethod Keyword
    3              0.000001 endif

SCRIPT  /home/pyericz/.vimgo/plugged/yats.vim/syntax/yats/node.vim
Sourced 3 times
Total time:   0.000134
 Self time:   0.000134

count  total (s)   self (s)
    3              0.000018 syntax keyword typescriptNodeGlobal containedin=typescriptIdentifierName global process
    3              0.000016 syntax keyword typescriptNodeGlobal containedin=typescriptIdentifierName console Buffer
    3              0.000017 syntax keyword typescriptNodeGlobal containedin=typescriptIdentifierName module exports
    3              0.000015 syntax keyword typescriptNodeGlobal containedin=typescriptIdentifierName setTimeout
    3              0.000016 syntax keyword typescriptNodeGlobal containedin=typescriptIdentifierName clearTimeout
    3              0.000015 syntax keyword typescriptNodeGlobal containedin=typescriptIdentifierName setInterval
    3              0.000015 syntax keyword typescriptNodeGlobal containedin=typescriptIdentifierName clearInterval
    3              0.000014 if exists("did_typescript_hilink") | HiLink typescriptNodeGlobal Structure
    3              0.000003 endif

SCRIPT  /home/pyericz/.vimgo/plugged/yats.vim/syntax/yats/test.vim
Sourced 3 times
Total time:   0.000115
 Self time:   0.000115

count  total (s)   self (s)
    3              0.000015 syntax keyword typescriptTestGlobal containedin=typescriptIdentifierName describe
    3              0.000017 syntax keyword typescriptTestGlobal containedin=typescriptIdentifierName it test before
    3              0.000016 syntax keyword typescriptTestGlobal containedin=typescriptIdentifierName after beforeEach
    3              0.000016 syntax keyword typescriptTestGlobal containedin=typescriptIdentifierName afterEach
    3              0.000015 syntax keyword typescriptTestGlobal containedin=typescriptIdentifierName beforeAll
    3              0.000015 syntax keyword typescriptTestGlobal containedin=typescriptIdentifierName afterAll
    3              0.000017 syntax keyword typescriptTestGlobal containedin=typescriptIdentifierName expect assert

SCRIPT  /home/pyericz/.vimgo/plugged/yats.vim/syntax/yats/web.vim
Sourced 3 times
Total time:   0.004460
 Self time:   0.004460

count  total (s)   self (s)
    3              0.000017 syntax keyword typescriptBOM containedin=typescriptIdentifierName AbortController
    3              0.000016 syntax keyword typescriptBOM containedin=typescriptIdentifierName AbstractWorker AnalyserNode
    3              0.000015 syntax keyword typescriptBOM containedin=typescriptIdentifierName App Apps ArrayBuffer
    3              0.000017 syntax keyword typescriptBOM containedin=typescriptIdentifierName ArrayBufferView
    3              0.000016 syntax keyword typescriptBOM containedin=typescriptIdentifierName Attr AudioBuffer
    3              0.000015 syntax keyword typescriptBOM containedin=typescriptIdentifierName AudioBufferSourceNode
    3              0.000016 syntax keyword typescriptBOM containedin=typescriptIdentifierName AudioContext AudioDestinationNode
    3              0.000015 syntax keyword typescriptBOM containedin=typescriptIdentifierName AudioListener AudioNode
    3              0.000016 syntax keyword typescriptBOM containedin=typescriptIdentifierName AudioParam BatteryManager
    3              0.000016 syntax keyword typescriptBOM containedin=typescriptIdentifierName BiquadFilterNode
    3              0.000016 syntax keyword typescriptBOM containedin=typescriptIdentifierName BlobEvent BluetoothAdapter
    3              0.000015 syntax keyword typescriptBOM containedin=typescriptIdentifierName BluetoothDevice
    3              0.000016 syntax keyword typescriptBOM containedin=typescriptIdentifierName BluetoothManager
    3              0.000015 syntax keyword typescriptBOM containedin=typescriptIdentifierName CameraCapabilities
    3              0.000016 syntax keyword typescriptBOM containedin=typescriptIdentifierName CameraControl CameraManager
    3              0.000016 syntax keyword typescriptBOM containedin=typescriptIdentifierName CanvasGradient CanvasImageSource
    3              0.000016 syntax keyword typescriptBOM containedin=typescriptIdentifierName CanvasPattern CanvasRenderingContext2D
    3              0.000016 syntax keyword typescriptBOM containedin=typescriptIdentifierName CaretPosition CDATASection
    3              0.000015 syntax keyword typescriptBOM containedin=typescriptIdentifierName ChannelMergerNode
    3              0.000016 syntax keyword typescriptBOM containedin=typescriptIdentifierName ChannelSplitterNode
    3              0.000015 syntax keyword typescriptBOM containedin=typescriptIdentifierName CharacterData ChildNode
    3              0.000015 syntax keyword typescriptBOM containedin=typescriptIdentifierName ChromeWorker Comment
    3              0.000016 syntax keyword typescriptBOM containedin=typescriptIdentifierName Connection Console
    3              0.000016 syntax keyword typescriptBOM containedin=typescriptIdentifierName ContactManager Contacts
    3              0.000015 syntax keyword typescriptBOM containedin=typescriptIdentifierName ConvolverNode Coordinates
    3              0.000023 syntax keyword typescriptBOM containedin=typescriptIdentifierName CSS CSSConditionRule
    3              0.000015 syntax keyword typescriptBOM containedin=typescriptIdentifierName CSSGroupingRule
    3              0.000014 syntax keyword typescriptBOM containedin=typescriptIdentifierName CSSKeyframeRule
    3              0.000016 syntax keyword typescriptBOM containedin=typescriptIdentifierName CSSKeyframesRule
    3              0.000015 syntax keyword typescriptBOM containedin=typescriptIdentifierName CSSMediaRule CSSNamespaceRule
    3              0.000015 syntax keyword typescriptBOM containedin=typescriptIdentifierName CSSPageRule CSSRule
    3              0.000017 syntax keyword typescriptBOM containedin=typescriptIdentifierName CSSRuleList CSSStyleDeclaration
    3              0.000015 syntax keyword typescriptBOM containedin=typescriptIdentifierName CSSStyleRule CSSStyleSheet
    3              0.000016 syntax keyword typescriptBOM containedin=typescriptIdentifierName CSSSupportsRule
    3              0.000017 syntax keyword typescriptBOM containedin=typescriptIdentifierName DataTransfer DataView
    3              0.000015 syntax keyword typescriptBOM containedin=typescriptIdentifierName DedicatedWorkerGlobalScope
    3              0.000017 syntax keyword typescriptBOM containedin=typescriptIdentifierName DelayNode DeviceAcceleration
    3              0.000015 syntax keyword typescriptBOM containedin=typescriptIdentifierName DeviceRotationRate
    3              0.000016 syntax keyword typescriptBOM containedin=typescriptIdentifierName DeviceStorage DirectoryEntry
    3              0.000015 syntax keyword typescriptBOM containedin=typescriptIdentifierName DirectoryEntrySync
    3              0.000015 syntax keyword typescriptBOM containedin=typescriptIdentifierName DirectoryReader
    3              0.000015 syntax keyword typescriptBOM containedin=typescriptIdentifierName DirectoryReaderSync
    3              0.000016 syntax keyword typescriptBOM containedin=typescriptIdentifierName Document DocumentFragment
    3              0.000015 syntax keyword typescriptBOM containedin=typescriptIdentifierName DocumentTouch DocumentType
    3              0.000015 syntax keyword typescriptBOM containedin=typescriptIdentifierName DOMCursor DOMError
    3              0.000018 syntax keyword typescriptBOM containedin=typescriptIdentifierName DOMException DOMHighResTimeStamp
    3              0.000016 syntax keyword typescriptBOM containedin=typescriptIdentifierName DOMImplementation
    3              0.000015 syntax keyword typescriptBOM containedin=typescriptIdentifierName DOMImplementationRegistry
    3              0.000015 syntax keyword typescriptBOM containedin=typescriptIdentifierName DOMParser DOMRequest
    3              0.000016 syntax keyword typescriptBOM containedin=typescriptIdentifierName DOMString DOMStringList
    3              0.000015 syntax keyword typescriptBOM containedin=typescriptIdentifierName DOMStringMap DOMTimeStamp
    3              0.000016 syntax keyword typescriptBOM containedin=typescriptIdentifierName DOMTokenList DynamicsCompressorNode
    3              0.000017 syntax keyword typescriptBOM containedin=typescriptIdentifierName Element Entry EntrySync
    3              0.000021 syntax keyword typescriptBOM containedin=typescriptIdentifierName Extensions FileException
    3              0.000018 syntax keyword typescriptBOM containedin=typescriptIdentifierName Float32Array Float64Array
    3              0.000016 syntax keyword typescriptBOM containedin=typescriptIdentifierName FMRadio FormData
    3              0.000016 syntax keyword typescriptBOM containedin=typescriptIdentifierName GainNode Gamepad
    3              0.000016 syntax keyword typescriptBOM containedin=typescriptIdentifierName GamepadButton Geolocation
    3              0.000016 syntax keyword typescriptBOM containedin=typescriptIdentifierName History HTMLAnchorElement
    3              0.000015 syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLAreaElement
    3              0.000015 syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLAudioElement
    3              0.000014 syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLBaseElement
    3              0.000016 syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLBodyElement
    3              0.000016 syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLBRElement HTMLButtonElement
    3              0.000015 syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLCanvasElement
    3              0.000015 syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLCollection HTMLDataElement
    3              0.000016 syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLDataListElement
    3              0.000015 syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLDivElement HTMLDListElement
    3              0.000015 syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLDocument HTMLElement
    3              0.000015 syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLEmbedElement
    3              0.000016 syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLFieldSetElement
    3              0.000015 syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLFormControlsCollection
    3              0.000015 syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLFormElement
    3              0.000015 syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLHeadElement
    3              0.000015 syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLHeadingElement
    3              0.000016 syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLHRElement HTMLHtmlElement
    3              0.000015 syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLIFrameElement
    3              0.000015 syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLImageElement
    3              0.000015 syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLInputElement
    3              0.000017 syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLKeygenElement
    3              0.000015 syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLLabelElement
    3              0.000015 syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLLegendElement
    3              0.000015 syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLLIElement HTMLLinkElement
    3              0.000015 syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLMapElement HTMLMediaElement
    3              0.000016 syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLMetaElement
    3              0.000015 syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLMeterElement
    3              0.000015 syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLModElement HTMLObjectElement
    3              0.000016 syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLOListElement
    3              0.000015 syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLOptGroupElement
    3              0.000016 syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLOptionElement
    3              0.000015 syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLOptionsCollection
    3              0.000017 syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLOutputElement
    3              0.000016 syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLParagraphElement
    3              0.000015 syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLParamElement
    3              0.000015 syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLPreElement HTMLProgressElement
    3              0.000016 syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLQuoteElement
    3              0.000015 syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLScriptElement
    3              0.000015 syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLSelectElement
    3              0.000015 syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLSourceElement
    3              0.000015 syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLSpanElement
    3              0.000014 syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLStyleElement
    3              0.000016 syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLTableCaptionElement
    3              0.000015 syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLTableCellElement
    3              0.000015 syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLTableColElement
    3              0.000015 syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLTableDataCellElement
    3              0.000016 syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLTableElement
    3              0.000015 syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLTableHeaderCellElement
    3              0.000015 syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLTableRowElement
    3              0.000015 syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLTableSectionElement
    3              0.000016 syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLTextAreaElement
    3              0.000015 syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLTimeElement
    3              0.000015 syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLTitleElement
    3              0.000015 syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLTrackElement
    3              0.000015 syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLUListElement
    3              0.000015 syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLUnknownElement
    3              0.000015 syntax keyword typescriptBOM containedin=typescriptIdentifierName HTMLVideoElement
    3              0.000015 syntax keyword typescriptBOM containedin=typescriptIdentifierName IDBCursor IDBCursorSync
    3              0.000015 syntax keyword typescriptBOM containedin=typescriptIdentifierName IDBCursorWithValue
    3              0.000015 syntax keyword typescriptBOM containedin=typescriptIdentifierName IDBDatabase IDBDatabaseSync
    3              0.000016 syntax keyword typescriptBOM containedin=typescriptIdentifierName IDBEnvironment IDBEnvironmentSync
    3              0.000016 syntax keyword typescriptBOM containedin=typescriptIdentifierName IDBFactory IDBFactorySync
    3              0.000015 syntax keyword typescriptBOM containedin=typescriptIdentifierName IDBIndex IDBIndexSync
    3              0.000015 syntax keyword typescriptBOM containedin=typescriptIdentifierName IDBKeyRange IDBObjectStore
    3              0.000016 syntax keyword typescriptBOM containedin=typescriptIdentifierName IDBObjectStoreSync
    3              0.000015 syntax keyword typescriptBOM containedin=typescriptIdentifierName IDBOpenDBRequest
    3              0.000015 syntax keyword typescriptBOM containedin=typescriptIdentifierName IDBRequest IDBTransaction
    3              0.000014 syntax keyword typescriptBOM containedin=typescriptIdentifierName IDBTransactionSync
    3              0.000063 syntax keyword typescriptBOM containedin=typescriptIdentifierName IDBVersionChangeEvent
    3              0.000016 syntax keyword typescriptBOM containedin=typescriptIdentifierName ImageData IndexedDB
    3              0.000016 syntax keyword typescriptBOM containedin=typescriptIdentifierName Int16Array Int32Array
    3              0.000017 syntax keyword typescriptBOM containedin=typescriptIdentifierName Int8Array L10n LinkStyle
    3              0.000015 syntax keyword typescriptBOM containedin=typescriptIdentifierName LocalFileSystem
    3              0.000015 syntax keyword typescriptBOM containedin=typescriptIdentifierName LocalFileSystemSync
    3              0.000015 syntax keyword typescriptBOM containedin=typescriptIdentifierName Location LockedFile
    3              0.000016 syntax keyword typescriptBOM containedin=typescriptIdentifierName MediaQueryList MediaQueryListListener
    3              0.000016 syntax keyword typescriptBOM containedin=typescriptIdentifierName MediaRecorder MediaSource
    3              0.000016 syntax keyword typescriptBOM containedin=typescriptIdentifierName MediaStream MediaStreamTrack
    3              0.000015 syntax keyword typescriptBOM containedin=typescriptIdentifierName MutationObserver
    3              0.000018 syntax keyword typescriptBOM containedin=typescriptIdentifierName Navigator NavigatorGeolocation
    3              0.000016 syntax keyword typescriptBOM containedin=typescriptIdentifierName NavigatorID NavigatorLanguage
    3              0.000015 syntax keyword typescriptBOM containedin=typescriptIdentifierName NavigatorOnLine
    3              0.000015 syntax keyword typescriptBOM containedin=typescriptIdentifierName NavigatorPlugins
    3              0.000016 syntax keyword typescriptBOM containedin=typescriptIdentifierName Node NodeFilter
    3              0.000019 syntax keyword typescriptBOM containedin=typescriptIdentifierName NodeIterator NodeList
    3              0.000016 syntax keyword typescriptBOM containedin=typescriptIdentifierName Notification OfflineAudioContext
    3              0.000016 syntax keyword typescriptBOM containedin=typescriptIdentifierName OscillatorNode PannerNode
    3              0.000015 syntax keyword typescriptBOM containedin=typescriptIdentifierName ParentNode Performance
    3              0.000015 syntax keyword typescriptBOM containedin=typescriptIdentifierName PerformanceNavigation
    3              0.000015 syntax keyword typescriptBOM containedin=typescriptIdentifierName PerformanceTiming
    3              0.000016 syntax keyword typescriptBOM containedin=typescriptIdentifierName Permissions PermissionSettings
    3              0.000016 syntax keyword typescriptBOM containedin=typescriptIdentifierName Plugin PluginArray
    3              0.000049 syntax keyword typescriptBOM containedin=typescriptIdentifierName Position PositionError
    3              0.000017 syntax keyword typescriptBOM containedin=typescriptIdentifierName PositionOptions
    3              0.000016 syntax keyword typescriptBOM containedin=typescriptIdentifierName PowerManager ProcessingInstruction
    3              0.000015 syntax keyword typescriptBOM containedin=typescriptIdentifierName PromiseResolver
    3              0.000016 syntax keyword typescriptBOM containedin=typescriptIdentifierName PushManager Range
    3              0.000014 syntax keyword typescriptBOM containedin=typescriptIdentifierName RTCConfiguration
    3              0.000017 syntax keyword typescriptBOM containedin=typescriptIdentifierName RTCPeerConnection
    3              0.000015 syntax keyword typescriptBOM containedin=typescriptIdentifierName RTCPeerConnectionErrorCallback
    3              0.000015 syntax keyword typescriptBOM containedin=typescriptIdentifierName RTCSessionDescription
    3              0.000016 syntax keyword typescriptBOM containedin=typescriptIdentifierName RTCSessionDescriptionCallback
    3              0.000015 syntax keyword typescriptBOM containedin=typescriptIdentifierName ScriptProcessorNode
    3              0.000015 syntax keyword typescriptBOM containedin=typescriptIdentifierName Selection SettingsLock
    3              0.000016 syntax keyword typescriptBOM containedin=typescriptIdentifierName SettingsManager
    3              0.000016 syntax keyword typescriptBOM containedin=typescriptIdentifierName SharedWorker StyleSheet
    3              0.000015 syntax keyword typescriptBOM containedin=typescriptIdentifierName StyleSheetList SVGAElement
    3              0.000016 syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGAngle SVGAnimateColorElement
    3              0.000015 syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGAnimatedAngle
    3              0.000015 syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGAnimatedBoolean
    3              0.000015 syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGAnimatedEnumeration
    3              0.000016 syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGAnimatedInteger
    3              0.000015 syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGAnimatedLength
    3              0.000015 syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGAnimatedLengthList
    3              0.000015 syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGAnimatedNumber
    3              0.000016 syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGAnimatedNumberList
    3              0.000016 syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGAnimatedPoints
    3              0.000015 syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGAnimatedPreserveAspectRatio
    3              0.000015 syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGAnimatedRect
    3              0.000015 syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGAnimatedString
    3              0.000016 syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGAnimatedTransformList
    3              0.000015 syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGAnimateElement
    3              0.000015 syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGAnimateMotionElement
    3              0.000016 syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGAnimateTransformElement
    3              0.000014 syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGAnimationElement
    3              0.000016 syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGCircleElement
    3              0.000016 syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGClipPathElement
    3              0.000015 syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGCursorElement
    3              0.000015 syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGDefsElement SVGDescElement
    3              0.000017 syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGElement SVGEllipseElement
    3              0.000015 syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGFilterElement
    3              0.000015 syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGFontElement SVGFontFaceElement
    3              0.000017 syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGFontFaceFormatElement
    3              0.000014 syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGFontFaceNameElement
    3              0.000014 syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGFontFaceSrcElement
    3              0.000015 syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGFontFaceUriElement
    3              0.000015 syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGForeignObjectElement
    3              0.000015 syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGGElement SVGGlyphElement
    3              0.000015 syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGGradientElement
    3              0.000016 syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGHKernElement
    3              0.000015 syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGImageElement
    3              0.000016 syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGLength SVGLengthList
    3              0.000015 syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGLinearGradientElement
    3              0.000016 syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGLineElement SVGMaskElement
    3              0.000016 syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGMatrix SVGMissingGlyphElement
    3              0.000015 syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGMPathElement
    3              0.000016 syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGNumber SVGNumberList
    3              0.000015 syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGPathElement SVGPatternElement
    3              0.000016 syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGPoint SVGPolygonElement
    3              0.000015 syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGPolylineElement
    3              0.000015 syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGPreserveAspectRatio
    3              0.000016 syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGRadialGradientElement
    3              0.000015 syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGRect SVGRectElement
    3              0.000015 syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGScriptElement
    3              0.000017 syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGSetElement SVGStopElement
    3              0.000015 syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGStringList SVGStylable
    3              0.000015 syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGStyleElement
    3              0.000016 syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGSVGElement SVGSwitchElement
    3              0.000015 syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGSymbolElement
    3              0.000015 syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGTests SVGTextElement
    3              0.000016 syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGTextPositioningElement
    3              0.000015 syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGTitleElement
    3              0.000016 syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGTransform SVGTransformable
    3              0.000013 syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGTransformList
    3              0.000050 syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGTRefElement SVGTSpanElement
    3              0.000111 syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGUseElement SVGViewElement
    3              0.000033 syntax keyword typescriptBOM containedin=typescriptIdentifierName SVGVKernElement
    3              0.000031 syntax keyword typescriptBOM containedin=typescriptIdentifierName TCPServerSocket
    3              0.000040 syntax keyword typescriptBOM containedin=typescriptIdentifierName TCPSocket Telephony
    3              0.000038 syntax keyword typescriptBOM containedin=typescriptIdentifierName TelephonyCall Text
    3              0.000037 syntax keyword typescriptBOM containedin=typescriptIdentifierName TextDecoder TextEncoder
    3              0.000038 syntax keyword typescriptBOM containedin=typescriptIdentifierName TextMetrics TimeRanges
    3              0.000035 syntax keyword typescriptBOM containedin=typescriptIdentifierName Touch TouchList
    3              0.000034 syntax keyword typescriptBOM containedin=typescriptIdentifierName Transferable TreeWalker
    3              0.000017 syntax keyword typescriptBOM containedin=typescriptIdentifierName Uint16Array Uint32Array
    3              0.000015 syntax keyword typescriptBOM containedin=typescriptIdentifierName Uint8Array Uint8ClampedArray
    3              0.000025 syntax keyword typescriptBOM containedin=typescriptIdentifierName URLSearchParams
    3              0.000025 syntax keyword typescriptBOM containedin=typescriptIdentifierName URLUtilsReadOnly
    3              0.000025 syntax keyword typescriptBOM containedin=typescriptIdentifierName UserProximityEvent
    3              0.000037 syntax keyword typescriptBOM containedin=typescriptIdentifierName ValidityState VideoPlaybackQuality
    3              0.000034 syntax keyword typescriptBOM containedin=typescriptIdentifierName WaveShaperNode WebBluetooth
    3              0.000025 syntax keyword typescriptBOM containedin=typescriptIdentifierName WebGLRenderingContext
    3              0.000033 syntax keyword typescriptBOM containedin=typescriptIdentifierName WebSMS WebSocket
    3              0.000034 syntax keyword typescriptBOM containedin=typescriptIdentifierName WebVTT WifiManager
    3              0.000044 syntax keyword typescriptBOM containedin=typescriptIdentifierName Window Worker WorkerConsole
    3              0.000035 syntax keyword typescriptBOM containedin=typescriptIdentifierName WorkerLocation WorkerNavigator
    3              0.000034 syntax keyword typescriptBOM containedin=typescriptIdentifierName XDomainRequest XMLDocument
    3              0.000024 syntax keyword typescriptBOM containedin=typescriptIdentifierName XMLHttpRequestEventTarget
    3              0.000026 if exists("did_typescript_hilink") | HiLink typescriptBOM Structure
    3              0.000002 endif

SCRIPT  /home/pyericz/.vimgo/plugged/yats.vim/syntax/yats/web-window.vim
Sourced 3 times
Total time:   0.002811
 Self time:   0.002811

count  total (s)   self (s)
    3              0.000028 syntax keyword typescriptBOMWindowProp containedin=typescriptIdentifierName applicationCache
    3              0.000026 syntax keyword typescriptBOMWindowProp containedin=typescriptIdentifierName closed
    3              0.000026 syntax keyword typescriptBOMWindowProp containedin=typescriptIdentifierName Components
    3              0.000024 syntax keyword typescriptBOMWindowProp containedin=typescriptIdentifierName controllers
    3              0.000025 syntax keyword typescriptBOMWindowProp containedin=typescriptIdentifierName dialogArguments
    3              0.000024 syntax keyword typescriptBOMWindowProp containedin=typescriptIdentifierName document
    3              0.000024 syntax keyword typescriptBOMWindowProp containedin=typescriptIdentifierName frameElement
    3              0.000024 syntax keyword typescriptBOMWindowProp containedin=typescriptIdentifierName frames
    3              0.000026 syntax keyword typescriptBOMWindowProp containedin=typescriptIdentifierName fullScreen
    3              0.000023 syntax keyword typescriptBOMWindowProp containedin=typescriptIdentifierName history
    3              0.000025 syntax keyword typescriptBOMWindowProp containedin=typescriptIdentifierName innerHeight
    3              0.000024 syntax keyword typescriptBOMWindowProp containedin=typescriptIdentifierName innerWidth
    3              0.000016 syntax keyword typescriptBOMWindowProp containedin=typescriptIdentifierName length
    3              0.000024 syntax keyword typescriptBOMWindowProp containedin=typescriptIdentifierName location
    3              0.000023 syntax keyword typescriptBOMWindowProp containedin=typescriptIdentifierName locationbar
    3              0.000024 syntax keyword typescriptBOMWindowProp containedin=typescriptIdentifierName menubar
    3              0.000024 syntax keyword typescriptBOMWindowProp containedin=typescriptIdentifierName messageManager
    3              0.000033 syntax keyword typescriptBOMWindowProp containedin=typescriptIdentifierName name navigator
    3              0.000023 syntax keyword typescriptBOMWindowProp containedin=typescriptIdentifierName opener
    3              0.000024 syntax keyword typescriptBOMWindowProp containedin=typescriptIdentifierName outerHeight
    3              0.000023 syntax keyword typescriptBOMWindowProp containedin=typescriptIdentifierName outerWidth
    3              0.000023 syntax keyword typescriptBOMWindowProp containedin=typescriptIdentifierName pageXOffset
    3              0.000024 syntax keyword typescriptBOMWindowProp containedin=typescriptIdentifierName pageYOffset
    3              0.000016 syntax keyword typescriptBOMWindowProp containedin=typescriptIdentifierName parent
    3              0.000026 syntax keyword typescriptBOMWindowProp containedin=typescriptIdentifierName performance
    3              0.000024 syntax keyword typescriptBOMWindowProp containedin=typescriptIdentifierName personalbar
    3              0.000024 syntax keyword typescriptBOMWindowProp containedin=typescriptIdentifierName returnValue
    3              0.000025 syntax keyword typescriptBOMWindowProp containedin=typescriptIdentifierName screen
    3              0.000024 syntax keyword typescriptBOMWindowProp containedin=typescriptIdentifierName screenX
    3              0.000024 syntax keyword typescriptBOMWindowProp containedin=typescriptIdentifierName screenY
    3              0.000024 syntax keyword typescriptBOMWindowProp containedin=typescriptIdentifierName scrollbars
    3              0.000024 syntax keyword typescriptBOMWindowProp containedin=typescriptIdentifierName scrollMaxX
    3              0.000024 syntax keyword typescriptBOMWindowProp containedin=typescriptIdentifierName scrollMaxY
    3              0.000024 syntax keyword typescriptBOMWindowProp containedin=typescriptIdentifierName scrollX
    3              0.000024 syntax keyword typescriptBOMWindowProp containedin=typescriptIdentifierName scrollY
    3              0.000024 syntax keyword typescriptBOMWindowProp containedin=typescriptIdentifierName self sidebar
    3              0.000016 syntax keyword typescriptBOMWindowProp containedin=typescriptIdentifierName status
    3              0.000024 syntax keyword typescriptBOMWindowProp containedin=typescriptIdentifierName statusbar
    3              0.000024 syntax keyword typescriptBOMWindowProp containedin=typescriptIdentifierName toolbar
    3              0.000024 syntax keyword typescriptBOMWindowProp containedin=typescriptIdentifierName top visualViewport
    3              0.000024 syntax keyword typescriptBOMWindowProp containedin=typescriptIdentifierName window
    3              0.000012 syntax cluster props add=typescriptBOMWindowProp
    3              0.000018 if exists("did_typescript_hilink") | HiLink typescriptBOMWindowProp Structure
    3              0.000003 endif
    3              0.000025 syntax keyword typescriptBOMWindowMethod containedin=typescriptIdentifierName alert nextgroup=typescriptFuncCallArg
    3              0.000034 syntax keyword typescriptBOMWindowMethod containedin=typescriptIdentifierName atob nextgroup=typescriptFuncCallArg
    3              0.000035 syntax keyword typescriptBOMWindowMethod containedin=typescriptIdentifierName blur nextgroup=typescriptFuncCallArg
    3              0.000033 syntax keyword typescriptBOMWindowMethod containedin=typescriptIdentifierName btoa nextgroup=typescriptFuncCallArg
    3              0.000035 syntax keyword typescriptBOMWindowMethod containedin=typescriptIdentifierName clearImmediate nextgroup=typescriptFuncCallArg
    3              0.000024 syntax keyword typescriptBOMWindowMethod containedin=typescriptIdentifierName clearInterval nextgroup=typescriptFuncCallArg
    3              0.000023 syntax keyword typescriptBOMWindowMethod containedin=typescriptIdentifierName clearTimeout nextgroup=typescriptFuncCallArg
    3              0.000033 syntax keyword typescriptBOMWindowMethod containedin=typescriptIdentifierName close nextgroup=typescriptFuncCallArg
    3              0.000024 syntax keyword typescriptBOMWindowMethod containedin=typescriptIdentifierName confirm nextgroup=typescriptFuncCallArg
    3              0.000033 syntax keyword typescriptBOMWindowMethod containedin=typescriptIdentifierName dispatchEvent nextgroup=typescriptFuncCallArg
    3              0.000024 syntax keyword typescriptBOMWindowMethod containedin=typescriptIdentifierName find nextgroup=typescriptFuncCallArg
    3              0.000033 syntax keyword typescriptBOMWindowMethod containedin=typescriptIdentifierName focus nextgroup=typescriptFuncCallArg
    3              0.000032 syntax keyword typescriptBOMWindowMethod containedin=typescriptIdentifierName getAttention nextgroup=typescriptFuncCallArg
    3              0.000034 syntax keyword typescriptBOMWindowMethod containedin=typescriptIdentifierName getAttentionWithCycleCount nextgroup=typescriptFuncCallArg
    3              0.000033 syntax keyword typescriptBOMWindowMethod containedin=typescriptIdentifierName getComputedStyle nextgroup=typescriptFuncCallArg
    3              0.000032 syntax keyword typescriptBOMWindowMethod containedin=typescriptIdentifierName getDefaulComputedStyle nextgroup=typescriptFuncCallArg
    3              0.000034 syntax keyword typescriptBOMWindowMethod containedin=typescriptIdentifierName getSelection nextgroup=typescriptFuncCallArg
    3              0.000034 syntax keyword typescriptBOMWindowMethod containedin=typescriptIdentifierName matchMedia nextgroup=typescriptFuncCallArg
    3              0.000033 syntax keyword typescriptBOMWindowMethod containedin=typescriptIdentifierName maximize nextgroup=typescriptFuncCallArg
    3              0.000033 syntax keyword typescriptBOMWindowMethod containedin=typescriptIdentifierName moveBy nextgroup=typescriptFuncCallArg
    3              0.000033 syntax keyword typescriptBOMWindowMethod containedin=typescriptIdentifierName moveTo nextgroup=typescriptFuncCallArg
    3              0.000032 syntax keyword typescriptBOMWindowMethod containedin=typescriptIdentifierName open nextgroup=typescriptFuncCallArg
    3              0.000032 syntax keyword typescriptBOMWindowMethod containedin=typescriptIdentifierName openDialog nextgroup=typescriptFuncCallArg
    3              0.000033 syntax keyword typescriptBOMWindowMethod containedin=typescriptIdentifierName postMessage nextgroup=typescriptFuncCallArg
    3              0.000033 syntax keyword typescriptBOMWindowMethod containedin=typescriptIdentifierName print nextgroup=typescriptFuncCallArg
    3              0.000023 syntax keyword typescriptBOMWindowMethod containedin=typescriptIdentifierName prompt nextgroup=typescriptFuncCallArg
    3              0.000034 syntax keyword typescriptBOMWindowMethod containedin=typescriptIdentifierName removeEventListener nextgroup=typescriptFuncCallArg
    3              0.000033 syntax keyword typescriptBOMWindowMethod containedin=typescriptIdentifierName resizeBy nextgroup=typescriptFuncCallArg
    3              0.000031 syntax keyword typescriptBOMWindowMethod containedin=typescriptIdentifierName resizeTo nextgroup=typescriptFuncCallArg
    3              0.000032 syntax keyword typescriptBOMWindowMethod containedin=typescriptIdentifierName restore nextgroup=typescriptFuncCallArg
    3              0.000033 syntax keyword typescriptBOMWindowMethod containedin=typescriptIdentifierName scroll nextgroup=typescriptFuncCallArg
    3              0.000032 syntax keyword typescriptBOMWindowMethod containedin=typescriptIdentifierName scrollBy nextgroup=typescriptFuncCallArg
    3              0.000033 syntax keyword typescriptBOMWindowMethod containedin=typescriptIdentifierName scrollByLines nextgroup=typescriptFuncCallArg
    3              0.000033 syntax keyword typescriptBOMWindowMethod containedin=typescriptIdentifierName scrollByPages nextgroup=typescriptFuncCallArg
    3              0.000033 syntax keyword typescriptBOMWindowMethod containedin=typescriptIdentifierName scrollTo nextgroup=typescriptFuncCallArg
    3              0.000032 syntax keyword typescriptBOMWindowMethod containedin=typescriptIdentifierName setCursor nextgroup=typescriptFuncCallArg
    3              0.000035 syntax keyword typescriptBOMWindowMethod containedin=typescriptIdentifierName setImmediate nextgroup=typescriptFuncCallArg
    3              0.000024 syntax keyword typescriptBOMWindowMethod containedin=typescriptIdentifierName setInterval nextgroup=typescriptFuncCallArg
    3              0.000032 syntax keyword typescriptBOMWindowMethod containedin=typescriptIdentifierName setResizable nextgroup=typescriptFuncCallArg
    3              0.000024 syntax keyword typescriptBOMWindowMethod containedin=typescriptIdentifierName setTimeout nextgroup=typescriptFuncCallArg
    3              0.000032 syntax keyword typescriptBOMWindowMethod containedin=typescriptIdentifierName showModalDialog nextgroup=typescriptFuncCallArg
    3              0.000032 syntax keyword typescriptBOMWindowMethod containedin=typescriptIdentifierName sizeToContent nextgroup=typescriptFuncCallArg
    3              0.000032 syntax keyword typescriptBOMWindowMethod containedin=typescriptIdentifierName stop nextgroup=typescriptFuncCallArg
    3              0.000033 syntax keyword typescriptBOMWindowMethod containedin=typescriptIdentifierName updateCommands nextgroup=typescriptFuncCallArg
    3              0.000011 syntax cluster props add=typescriptBOMWindowMethod
    3              0.000017 if exists("did_typescript_hilink") | HiLink typescriptBOMWindowMethod Structure
    3              0.000001 endif
    3              0.000043 syntax keyword typescriptBOMWindowEvent contained onabort onbeforeunload onblur onchange
    3              0.000042 syntax keyword typescriptBOMWindowEvent contained onclick onclose oncontextmenu ondevicelight
    3              0.000023 syntax keyword typescriptBOMWindowEvent contained ondevicemotion ondeviceorientation
    3              0.000032 syntax keyword typescriptBOMWindowEvent contained ondeviceproximity ondragdrop onerror
    3              0.000041 syntax keyword typescriptBOMWindowEvent contained onfocus onhashchange onkeydown onkeypress
    3              0.000042 syntax keyword typescriptBOMWindowEvent contained onkeyup onload onmousedown onmousemove
    3              0.000035 syntax keyword typescriptBOMWindowEvent contained onmouseout onmouseover onmouseup
    3              0.000015 syntax keyword typescriptBOMWindowEvent contained onmozbeforepaint onpaint onpopstate
    3              0.000006 syntax keyword typescriptBOMWindowEvent contained onreset onresize onscroll onselect
    3              0.000005 syntax keyword typescriptBOMWindowEvent contained onsubmit onunload onuserproximity
    3              0.000006 syntax keyword typescriptBOMWindowEvent contained onpageshow onpagehide
    3              0.000016 if exists("did_typescript_hilink") | HiLink typescriptBOMWindowEvent Keyword
    3              0.000002 endif
    3              0.000016 syntax keyword typescriptBOMWindowCons containedin=typescriptIdentifierName DOMParser
    3              0.000017 syntax keyword typescriptBOMWindowCons containedin=typescriptIdentifierName QueryInterface
    3              0.000016 syntax keyword typescriptBOMWindowCons containedin=typescriptIdentifierName XMLSerializer
    3              0.000015 if exists("did_typescript_hilink") | HiLink typescriptBOMWindowCons Structure
    3              0.000001 endif

SCRIPT  /home/pyericz/.vimgo/plugged/yats.vim/syntax/yats/web-navigator.vim
Sourced 3 times
Total time:   0.000211
 Self time:   0.000211

count  total (s)   self (s)
    3              0.000008 syntax keyword typescriptBOMNavigatorProp contained battery buildID connection cookieEnabled
    3              0.000006 syntax keyword typescriptBOMNavigatorProp contained doNotTrack maxTouchPoints oscpu
    3              0.000006 syntax keyword typescriptBOMNavigatorProp contained productSub push serviceWorker
    3              0.000005 syntax keyword typescriptBOMNavigatorProp contained vendor vendorSub
    3              0.000012 syntax cluster props add=typescriptBOMNavigatorProp
    3              0.000015 if exists("did_typescript_hilink") | HiLink typescriptBOMNavigatorProp Keyword
    3              0.000001 endif
    3              0.000015 syntax keyword typescriptBOMNavigatorMethod contained addIdleObserver geolocation nextgroup=typescriptFuncCallArg
    3              0.000015 syntax keyword typescriptBOMNavigatorMethod contained getDeviceStorage getDeviceStorages nextgroup=typescriptFuncCallArg
    3              0.000015 syntax keyword typescriptBOMNavigatorMethod contained getGamepads getUserMedia registerContentHandler nextgroup=typescriptFuncCallArg
    3              0.000014 syntax keyword typescriptBOMNavigatorMethod contained removeIdleObserver requestWakeLock nextgroup=typescriptFuncCallArg
    3              0.000015 syntax keyword typescriptBOMNavigatorMethod contained share vibrate watch registerProtocolHandler nextgroup=typescriptFuncCallArg
    3              0.000014 syntax keyword typescriptBOMNavigatorMethod contained sendBeacon nextgroup=typescriptFuncCallArg
    3              0.000010 syntax cluster props add=typescriptBOMNavigatorMethod
    3              0.000015 if exists("did_typescript_hilink") | HiLink typescriptBOMNavigatorMethod Keyword
    3              0.000001 endif
    3              0.000014 syntax keyword typescriptServiceWorkerMethod contained register nextgroup=typescriptFuncCallArg
    3              0.000010 syntax cluster props add=typescriptServiceWorkerMethod
    3              0.000015 if exists("did_typescript_hilink") | HiLink typescriptServiceWorkerMethod Keyword
    3              0.000001 endif

SCRIPT  /home/pyericz/.vimgo/plugged/yats.vim/syntax/yats/web-location.vim
Sourced 3 times
Total time:   0.000089
 Self time:   0.000089

count  total (s)   self (s)
    3              0.000007 syntax keyword typescriptBOMLocationProp contained href protocol host hostname port
    3              0.000006 syntax keyword typescriptBOMLocationProp contained pathname search hash username password
    3              0.000005 syntax keyword typescriptBOMLocationProp contained origin
    3              0.000010 syntax cluster props add=typescriptBOMLocationProp
    3              0.000015 if exists("did_typescript_hilink") | HiLink typescriptBOMLocationProp Keyword
    3              0.000000 endif
    3              0.000016 syntax keyword typescriptBOMLocationMethod contained assign reload replace toString nextgroup=typescriptFuncCallArg
    3              0.000010 syntax cluster props add=typescriptBOMLocationMethod
    3              0.000014 if exists("did_typescript_hilink") | HiLink typescriptBOMLocationMethod Keyword
    3              0.000002 endif

SCRIPT  /home/pyericz/.vimgo/plugged/yats.vim/syntax/yats/web-history.vim
Sourced 3 times
Total time:   0.000082
 Self time:   0.000082

count  total (s)   self (s)
    3              0.000008 syntax keyword typescriptBOMHistoryProp contained length current next previous state
    3              0.000004 syntax keyword typescriptBOMHistoryProp contained scrollRestoration
    3              0.000012 syntax cluster props add=typescriptBOMHistoryProp
    3              0.000012 if exists("did_typescript_hilink") | HiLink typescriptBOMHistoryProp Keyword
    3              0.000003 endif
    3              0.000015 syntax keyword typescriptBOMHistoryMethod contained back forward go pushState replaceState nextgroup=typescriptFuncCallArg
    3              0.000010 syntax cluster props add=typescriptBOMHistoryMethod
    3              0.000014 if exists("did_typescript_hilink") | HiLink typescriptBOMHistoryMethod Keyword
    3              0.000001 endif

SCRIPT  /home/pyericz/.vimgo/plugged/yats.vim/syntax/yats/web-console.vim
Sourced 3 times
Total time:   0.000122
 Self time:   0.000122

count  total (s)   self (s)
    3              0.000023 syntax keyword typescriptGlobal containedin=typescriptIdentifierName console nextgroup=typescriptGlobalConsoleDot
    3              0.000025 syntax match   typescriptGlobalConsoleDot /\./ contained nextgroup=typescriptConsoleMethod,typescriptProp
    3              0.000015 syntax keyword typescriptConsoleMethod contained count dir error group groupCollapsed nextgroup=typescriptFuncCallArg
    3              0.000017 syntax keyword typescriptConsoleMethod contained groupEnd info log time timeEnd trace nextgroup=typescriptFuncCallArg
    3              0.000013 syntax keyword typescriptConsoleMethod contained warn nextgroup=typescriptFuncCallArg
    3              0.000010 syntax cluster props add=typescriptConsoleMethod
    3              0.000015 if exists("did_typescript_hilink") | HiLink typescriptConsoleMethod Keyword
    3              0.000001 endif

SCRIPT  /home/pyericz/.vimgo/plugged/yats.vim/syntax/yats/web-xhr.vim
Sourced 3 times
Total time:   0.000136
 Self time:   0.000136

count  total (s)   self (s)
    3              0.000017 syntax keyword typescriptXHRGlobal containedin=typescriptIdentifierName XMLHttpRequest
    3              0.000014 if exists("did_typescript_hilink") | HiLink typescriptXHRGlobal Structure
    3              0.000001 endif
    3              0.000007 syntax keyword typescriptXHRProp contained onreadystatechange readyState response
    3              0.000006 syntax keyword typescriptXHRProp contained responseText responseType responseXML status
    3              0.000007 syntax keyword typescriptXHRProp contained statusText timeout ontimeout upload withCredentials
    3              0.000009 syntax cluster props add=typescriptXHRProp
    3              0.000014 if exists("did_typescript_hilink") | HiLink typescriptXHRProp Keyword
    3              0.000000 endif
    3              0.000016 syntax keyword typescriptXHRMethod contained abort getAllResponseHeaders getResponseHeader nextgroup=typescriptFuncCallArg
    3              0.000014 syntax keyword typescriptXHRMethod contained open overrideMimeType send setRequestHeader nextgroup=typescriptFuncCallArg
    3              0.000009 syntax cluster props add=typescriptXHRMethod
    3              0.000014 if exists("did_typescript_hilink") | HiLink typescriptXHRMethod Keyword
    3              0.000002 endif

SCRIPT  /home/pyericz/.vimgo/plugged/yats.vim/syntax/yats/web-blob.vim
Sourced 3 times
Total time:   0.000418
 Self time:   0.000418

count  total (s)   self (s)
    3              0.000018 syntax keyword typescriptGlobal containedin=typescriptIdentifierName Blob BlobBuilder
    3              0.000018 syntax keyword typescriptGlobal containedin=typescriptIdentifierName File FileReader
    3              0.000017 syntax keyword typescriptGlobal containedin=typescriptIdentifierName FileReaderSync
    3              0.000032 syntax keyword typescriptGlobal containedin=typescriptIdentifierName URL nextgroup=typescriptGlobalURLDot,typescriptFuncCallArg
    3              0.000023 syntax match   typescriptGlobalURLDot /\./ contained nextgroup=typescriptURLStaticMethod,typescriptProp
    3              0.000017 syntax keyword typescriptGlobal containedin=typescriptIdentifierName URLUtils
    3              0.000015 syntax keyword typescriptFileMethod contained readAsArrayBuffer readAsBinaryString nextgroup=typescriptFuncCallArg
    3              0.000014 syntax keyword typescriptFileMethod contained readAsDataURL readAsText nextgroup=typescriptFuncCallArg
    3              0.000010 syntax cluster props add=typescriptFileMethod
    3              0.000014 if exists("did_typescript_hilink") | HiLink typescriptFileMethod Keyword
    3              0.000001 endif
    3              0.000006 syntax keyword typescriptFileReaderProp contained error readyState result
    3              0.000009 syntax cluster props add=typescriptFileReaderProp
    3              0.000014 if exists("did_typescript_hilink") | HiLink typescriptFileReaderProp Keyword
    3              0.000002 endif
    3              0.000014 syntax keyword typescriptFileReaderMethod contained abort readAsArrayBuffer readAsBinaryString nextgroup=typescriptFuncCallArg
    3              0.000015 syntax keyword typescriptFileReaderMethod contained readAsDataURL readAsText nextgroup=typescriptFuncCallArg
    3              0.000009 syntax cluster props add=typescriptFileReaderMethod
    3              0.000015 if exists("did_typescript_hilink") | HiLink typescriptFileReaderMethod Keyword
    3              0.000000 endif
    3              0.000014 syntax keyword typescriptFileListMethod contained item nextgroup=typescriptFuncCallArg
    3              0.000011 syntax cluster props add=typescriptFileListMethod
    3              0.000012 if exists("did_typescript_hilink") | HiLink typescriptFileListMethod Keyword
    3              0.000002 endif
    3              0.000013 syntax keyword typescriptBlobMethod contained append getBlob getFile nextgroup=typescriptFuncCallArg
    3              0.000011 syntax cluster props add=typescriptBlobMethod
    3              0.000013 if exists("did_typescript_hilink") | HiLink typescriptBlobMethod Keyword
    3              0.000001 endif
    3              0.000008 syntax keyword typescriptURLUtilsProp contained hash host hostname href origin password
    3              0.000006 syntax keyword typescriptURLUtilsProp contained pathname port protocol search searchParams
    3              0.000005 syntax keyword typescriptURLUtilsProp contained username
    3              0.000010 syntax cluster props add=typescriptURLUtilsProp
    3              0.000012 if exists("did_typescript_hilink") | HiLink typescriptURLUtilsProp Keyword
    3              0.000002 endif
    3              0.000014 syntax keyword typescriptURLStaticMethod contained createObjectURL revokeObjectURL nextgroup=typescriptFuncCallArg
    3              0.000013 if exists("did_typescript_hilink") | HiLink typescriptURLStaticMethod Keyword
    3              0.000002 endif

SCRIPT  /home/pyericz/.vimgo/plugged/yats.vim/syntax/yats/web-crypto.vim
Sourced 3 times
Total time:   0.000158
 Self time:   0.000158

count  total (s)   self (s)
    3              0.000018 syntax keyword typescriptCryptoGlobal containedin=typescriptIdentifierName crypto
    3              0.000014 if exists("did_typescript_hilink") | HiLink typescriptCryptoGlobal Structure
    3              0.000000 endif
    3              0.000015 syntax keyword typescriptSubtleCryptoMethod contained encrypt decrypt sign verify nextgroup=typescriptFuncCallArg
    3              0.000015 syntax keyword typescriptSubtleCryptoMethod contained digest nextgroup=typescriptFuncCallArg
    3              0.000010 syntax cluster props add=typescriptSubtleCryptoMethod
    3              0.000013 if exists("did_typescript_hilink") | HiLink typescriptSubtleCryptoMethod Keyword
    3              0.000001 endif
    3              0.000004 syntax keyword typescriptCryptoProp contained subtle
    3              0.000011 syntax cluster props add=typescriptCryptoProp
    3              0.000013 if exists("did_typescript_hilink") | HiLink typescriptCryptoProp Keyword
    3              0.000001 endif
    3              0.000014 syntax keyword typescriptCryptoMethod contained getRandomValues nextgroup=typescriptFuncCallArg
    3              0.000011 syntax cluster props add=typescriptCryptoMethod
    3              0.000013 if exists("did_typescript_hilink") | HiLink typescriptCryptoMethod Keyword
    3              0.000002 endif

SCRIPT  /home/pyericz/.vimgo/plugged/yats.vim/syntax/yats/web-fetch.vim
Sourced 3 times
Total time:   0.000304
 Self time:   0.000304

count  total (s)   self (s)
    3              0.000018 syntax keyword typescriptGlobal containedin=typescriptIdentifierName Headers Request
    3              0.000016 syntax keyword typescriptGlobal containedin=typescriptIdentifierName Response
    3              0.000025 syntax keyword typescriptGlobalMethod containedin=typescriptIdentifierName fetch nextgroup=typescriptFuncCallArg
    3              0.000011 syntax cluster props add=typescriptGlobalMethod
    3              0.000015 if exists("did_typescript_hilink") | HiLink typescriptGlobalMethod Structure
    3              0.000001 endif
    3              0.000016 syntax keyword typescriptHeadersMethod contained append delete get getAll has set nextgroup=typescriptFuncCallArg
    3              0.000011 syntax cluster props add=typescriptHeadersMethod
    3              0.000029 if exists("did_typescript_hilink") | HiLink typescriptHeadersMethod Keyword
    3              0.000002 endif
    3              0.000008 syntax keyword typescriptRequestProp contained method url headers context referrer
    3              0.000006 syntax keyword typescriptRequestProp contained mode credentials cache
    3              0.000011 syntax cluster props add=typescriptRequestProp
    3              0.000015 if exists("did_typescript_hilink") | HiLink typescriptRequestProp Keyword
    3              0.000000 endif
    3              0.000014 syntax keyword typescriptRequestMethod contained clone nextgroup=typescriptFuncCallArg
    3              0.000010 syntax cluster props add=typescriptRequestMethod
    3              0.000015 if exists("did_typescript_hilink") | HiLink typescriptRequestMethod Keyword
    3              0.000000 endif
    3              0.000007 syntax keyword typescriptResponseProp contained type url status statusText headers
    3              0.000005 syntax keyword typescriptResponseProp contained redirected
    3              0.000011 syntax cluster props add=typescriptResponseProp
    3              0.000012 if exists("did_typescript_hilink") | HiLink typescriptResponseProp Keyword
    3              0.000001 endif
    3              0.000014 syntax keyword typescriptResponseMethod contained clone nextgroup=typescriptFuncCallArg
    3              0.000011 syntax cluster props add=typescriptResponseMethod
    3              0.000014 if exists("did_typescript_hilink") | HiLink typescriptResponseMethod Keyword
    3              0.000001 endif

SCRIPT  /home/pyericz/.vimgo/plugged/yats.vim/syntax/yats/web-service-worker.vim
Sourced 3 times
Total time:   0.000147
 Self time:   0.000147

count  total (s)   self (s)
    3              0.000005 syntax keyword typescriptServiceWorkerProp contained controller ready
    3              0.000010 syntax cluster props add=typescriptServiceWorkerProp
    3              0.000015 if exists("did_typescript_hilink") | HiLink typescriptServiceWorkerProp Keyword
    3              0.000001 endif
    3              0.000015 syntax keyword typescriptServiceWorkerMethod contained register getRegistration nextgroup=typescriptFuncCallArg
    3              0.000011 syntax cluster props add=typescriptServiceWorkerMethod
    3              0.000014 if exists("did_typescript_hilink") | HiLink typescriptServiceWorkerMethod Keyword
    3              0.000001 endif
    3              0.000018 syntax keyword typescriptGlobal containedin=typescriptIdentifierName Cache
    3              0.000015 syntax keyword typescriptCacheMethod contained match matchAll add addAll put delete nextgroup=typescriptFuncCallArg
    3              0.000014 syntax keyword typescriptCacheMethod contained keys nextgroup=typescriptFuncCallArg
    3              0.000010 syntax cluster props add=typescriptCacheMethod
    3              0.000013 if exists("did_typescript_hilink") | HiLink typescriptCacheMethod Keyword
    3              0.000002 endif

SCRIPT  /home/pyericz/.vimgo/plugged/yats.vim/syntax/yats/web-encoding.vim
Sourced 3 times
Total time:   0.000125
 Self time:   0.000125

count  total (s)   self (s)
    3              0.000018 syntax keyword typescriptEncodingGlobal containedin=typescriptIdentifierName TextEncoder
    3              0.000016 syntax keyword typescriptEncodingGlobal containedin=typescriptIdentifierName TextDecoder
    3              0.000013 if exists("did_typescript_hilink") | HiLink typescriptEncodingGlobal Structure
    3              0.000002 endif
    3              0.000006 syntax keyword typescriptEncodingProp contained encoding fatal ignoreBOM
    3              0.000011 syntax cluster props add=typescriptEncodingProp
    3              0.000016 if exists("did_typescript_hilink") | HiLink typescriptEncodingProp Keyword
    3              0.000001 endif
    3              0.000014 syntax keyword typescriptEncodingMethod contained encode decode nextgroup=typescriptFuncCallArg
    3              0.000010 syntax cluster props add=typescriptEncodingMethod
    3              0.000013 if exists("did_typescript_hilink") | HiLink typescriptEncodingMethod Keyword
    3              0.000002 endif

SCRIPT  /home/pyericz/.vimgo/plugged/yats.vim/syntax/yats/web-geo.vim
Sourced 3 times
Total time:   0.000074
 Self time:   0.000074

count  total (s)   self (s)
    3              0.000018 syntax keyword typescriptGlobal containedin=typescriptIdentifierName Geolocation
    3              0.000015 syntax keyword typescriptGeolocationMethod contained getCurrentPosition watchPosition nextgroup=typescriptFuncCallArg
    3              0.000014 syntax keyword typescriptGeolocationMethod contained clearWatch nextgroup=typescriptFuncCallArg
    3              0.000010 syntax cluster props add=typescriptGeolocationMethod
    3              0.000014 if exists("did_typescript_hilink") | HiLink typescriptGeolocationMethod Keyword
    3              0.000000 endif

SCRIPT  /home/pyericz/.vimgo/plugged/yats.vim/syntax/yats/web-network.vim
Sourced 3 times
Total time:   0.000061
 Self time:   0.000061

count  total (s)   self (s)
    3              0.000017 syntax keyword typescriptGlobal containedin=typescriptIdentifierName NetworkInformation
    3              0.000008 syntax keyword typescriptBOMNetworkProp contained downlink downlinkMax effectiveType
    3              0.000004 syntax keyword typescriptBOMNetworkProp contained rtt type
    3              0.000012 syntax cluster props add=typescriptBOMNetworkProp
    3              0.000012 if exists("did_typescript_hilink") | HiLink typescriptBOMNetworkProp Keyword
    3              0.000003 endif

SCRIPT  /home/pyericz/.vimgo/plugged/yats.vim/syntax/yats/web-payment.vim
Sourced 3 times
Total time:   0.000331
 Self time:   0.000331

count  total (s)   self (s)
    3              0.000018 syntax keyword typescriptGlobal containedin=typescriptIdentifierName PaymentRequest
    3              0.000014 syntax keyword typescriptPaymentMethod contained show abort canMakePayment nextgroup=typescriptFuncCallArg
    3              0.000011 syntax cluster props add=typescriptPaymentMethod
    3              0.000012 if exists("did_typescript_hilink") | HiLink typescriptPaymentMethod Keyword
    3              0.000002 endif
    3              0.000006 syntax keyword typescriptPaymentProp contained shippingAddress shippingOption result
    3              0.000010 syntax cluster props add=typescriptPaymentProp
    3              0.000014 if exists("did_typescript_hilink") | HiLink typescriptPaymentProp Keyword
    3              0.000002 endif
    3              0.000007 syntax keyword typescriptPaymentEvent contained onshippingaddresschange onshippingoptionchange
    3              0.000017 if exists("did_typescript_hilink") | HiLink typescriptPaymentEvent Keyword
    3              0.000001 endif
    3              0.000015 syntax keyword typescriptPaymentResponseMethod contained complete nextgroup=typescriptFuncCallArg
    3              0.000011 syntax cluster props add=typescriptPaymentResponseMethod
    3              0.000014 if exists("did_typescript_hilink") | HiLink typescriptPaymentResponseMethod Keyword
    3              0.000001 endif
    3              0.000006 syntax keyword typescriptPaymentResponseProp contained details methodName payerEmail
    3              0.000006 syntax keyword typescriptPaymentResponseProp contained payerPhone shippingAddress
    3              0.000005 syntax keyword typescriptPaymentResponseProp contained shippingOption
    3              0.000011 syntax cluster props add=typescriptPaymentResponseProp
    3              0.000019 if exists("did_typescript_hilink") | HiLink typescriptPaymentResponseProp Keyword
    3              0.000000 endif
    3              0.000006 syntax keyword typescriptPaymentAddressProp contained addressLine careOf city country
    3              0.000006 syntax keyword typescriptPaymentAddressProp contained country dependentLocality languageCode
    3              0.000005 syntax keyword typescriptPaymentAddressProp contained organization phone postalCode
    3              0.000006 syntax keyword typescriptPaymentAddressProp contained recipient region sortingCode
    3              0.000011 syntax cluster props add=typescriptPaymentAddressProp
    3              0.000014 if exists("did_typescript_hilink") | HiLink typescriptPaymentAddressProp Keyword
    3              0.000000 endif
    3              0.000007 syntax keyword typescriptPaymentShippingOptionProp contained id label amount selected
    3              0.000010 syntax cluster props add=typescriptPaymentShippingOptionProp
    3              0.000015 if exists("did_typescript_hilink") | HiLink typescriptPaymentShippingOptionProp Keyword
    3              0.000001 endif

SCRIPT  /home/pyericz/.vimgo/plugged/yats.vim/syntax/yats/dom-node.vim
Sourced 3 times
Total time:   0.000223
 Self time:   0.000223

count  total (s)   self (s)
    3              0.000006 syntax keyword typescriptDOMNodeProp contained attributes baseURI baseURIObject childNodes
    3              0.000006 syntax keyword typescriptDOMNodeProp contained firstChild lastChild localName namespaceURI
    3              0.000006 syntax keyword typescriptDOMNodeProp contained nextSibling nodeName nodePrincipal
    3              0.000006 syntax keyword typescriptDOMNodeProp contained nodeType nodeValue ownerDocument parentElement
    3              0.000006 syntax keyword typescriptDOMNodeProp contained parentNode prefix previousSibling textContent
    3              0.000011 syntax cluster props add=typescriptDOMNodeProp
    3              0.000013 if exists("did_typescript_hilink") | HiLink typescriptDOMNodeProp Keyword
    3              0.000001 endif
    3              0.000015 syntax keyword typescriptDOMNodeMethod contained appendChild cloneNode compareDocumentPosition nextgroup=typescriptFuncCallArg
    3              0.000015 syntax keyword typescriptDOMNodeMethod contained getUserData hasAttributes hasChildNodes nextgroup=typescriptFuncCallArg
    3              0.000013 syntax keyword typescriptDOMNodeMethod contained insertBefore isDefaultNamespace isEqualNode nextgroup=typescriptFuncCallArg
    3              0.000014 syntax keyword typescriptDOMNodeMethod contained isSameNode isSupported lookupNamespaceURI nextgroup=typescriptFuncCallArg
    3              0.000015 syntax keyword typescriptDOMNodeMethod contained lookupPrefix normalize removeChild nextgroup=typescriptFuncCallArg
    3              0.000014 syntax keyword typescriptDOMNodeMethod contained replaceChild setUserData nextgroup=typescriptFuncCallArg
    3              0.000009 syntax match typescriptDOMNodeMethod contained /contains/
    3              0.000012 syntax cluster props add=typescriptDOMNodeMethod
    3              0.000013 if exists("did_typescript_hilink") | HiLink typescriptDOMNodeMethod Keyword
    3              0.000002 endif
    3              0.000006 syntax keyword typescriptDOMNodeType contained ELEMENT_NODE ATTRIBUTE_NODE TEXT_NODE
    3              0.000006 syntax keyword typescriptDOMNodeType contained CDATA_SECTION_NODEN_NODE ENTITY_REFERENCE_NODE
    3              0.000003 syntax keyword typescriptDOMNodeType contained ENTITY_NODE PROCESSING_INSTRUCTION_NODEN_NODE
    3              0.000006 syntax keyword typescriptDOMNodeType contained COMMENT_NODE DOCUMENT_NODE DOCUMENT_TYPE_NODE
    3              0.000006 syntax keyword typescriptDOMNodeType contained DOCUMENT_FRAGMENT_NODE NOTATION_NODE
    3              0.000014 if exists("did_typescript_hilink") | HiLink typescriptDOMNodeType Keyword
    3              0.000001 endif

SCRIPT  /home/pyericz/.vimgo/plugged/yats.vim/syntax/yats/dom-elem.vim
Sourced 3 times
Total time:   0.000132
 Self time:   0.000132

count  total (s)   self (s)
    3              0.000007 syntax keyword typescriptDOMElemAttrs contained accessKey clientHeight clientLeft
    3              0.000006 syntax keyword typescriptDOMElemAttrs contained clientTop clientWidth id innerHTML
    3              0.000006 syntax keyword typescriptDOMElemAttrs contained length onafterscriptexecute onbeforescriptexecute
    3              0.000006 syntax keyword typescriptDOMElemAttrs contained oncopy oncut onpaste onwheel scrollHeight
    3              0.000004 syntax keyword typescriptDOMElemAttrs contained scrollLeft scrollTop scrollWidth tagName
    3              0.000005 syntax keyword typescriptDOMElemAttrs contained classList className name outerHTML
    3              0.000005 syntax keyword typescriptDOMElemAttrs contained style
    3              0.000013 if exists("did_typescript_hilink") | HiLink typescriptDOMElemAttrs Keyword
    3              0.000002 endif
    3              0.000005 syntax keyword typescriptDOMElemFuncs contained getAttributeNS getAttributeNode getAttributeNodeNS
    3              0.000004 syntax keyword typescriptDOMElemFuncs contained getBoundingClientRect getClientRects
    3              0.000005 syntax keyword typescriptDOMElemFuncs contained getElementsByClassName getElementsByTagName
    3              0.000005 syntax keyword typescriptDOMElemFuncs contained getElementsByTagNameNS hasAttribute
    3              0.000005 syntax keyword typescriptDOMElemFuncs contained hasAttributeNS insertAdjacentHTML
    3              0.000004 syntax keyword typescriptDOMElemFuncs contained matches querySelector querySelectorAll
    3              0.000005 syntax keyword typescriptDOMElemFuncs contained removeAttribute removeAttributeNS
    3              0.000004 syntax keyword typescriptDOMElemFuncs contained removeAttributeNode requestFullscreen
    3              0.000004 syntax keyword typescriptDOMElemFuncs contained requestPointerLock scrollIntoView
    3              0.000005 syntax keyword typescriptDOMElemFuncs contained setAttribute setAttributeNS setAttributeNode
    3              0.000007 syntax keyword typescriptDOMElemFuncs contained setAttributeNodeNS setCapture supports
    3              0.000004 syntax keyword typescriptDOMElemFuncs contained getAttribute
    3              0.000014 if exists("did_typescript_hilink") | HiLink typescriptDOMElemFuncs Keyword
    3              0.000001 endif

SCRIPT  /home/pyericz/.vimgo/plugged/yats.vim/syntax/yats/dom-document.vim
Sourced 3 times
Total time:   0.000333
 Self time:   0.000333

count  total (s)   self (s)
    3              0.000008 syntax keyword typescriptDOMDocProp contained activeElement body cookie defaultView
    3              0.000007 syntax keyword typescriptDOMDocProp contained designMode dir domain embeds forms head
    3              0.000008 syntax keyword typescriptDOMDocProp contained images lastModified links location plugins
    3              0.000006 syntax keyword typescriptDOMDocProp contained postMessage readyState referrer registerElement
    3              0.000007 syntax keyword typescriptDOMDocProp contained scripts styleSheets title vlinkColor
    3              0.000005 syntax keyword typescriptDOMDocProp contained xmlEncoding characterSet compatMode
    3              0.000006 syntax keyword typescriptDOMDocProp contained contentType currentScript doctype documentElement
    3              0.000006 syntax keyword typescriptDOMDocProp contained documentURI documentURIObject firstChild
    3              0.000004 syntax keyword typescriptDOMDocProp contained implementation lastStyleSheetSet namespaceURI
    3              0.000006 syntax keyword typescriptDOMDocProp contained nodePrincipal ononline pointerLockElement
    3              0.000005 syntax keyword typescriptDOMDocProp contained popupNode preferredStyleSheetSet selectedStyleSheetSet
    3              0.000005 syntax keyword typescriptDOMDocProp contained styleSheetSets textContent tooltipNode
    3              0.000013 syntax cluster props add=typescriptDOMDocProp
    3              0.000015 if exists("did_typescript_hilink") | HiLink typescriptDOMDocProp Keyword
    3              0.000002 endif
    3              0.000014 syntax keyword typescriptDOMDocMethod contained caretPositionFromPoint close createNodeIterator nextgroup=typescriptFuncCallArg
    3              0.000015 syntax keyword typescriptDOMDocMethod contained createRange createTreeWalker elementFromPoint nextgroup=typescriptFuncCallArg
    3              0.000015 syntax keyword typescriptDOMDocMethod contained getElementsByName adoptNode createAttribute nextgroup=typescriptFuncCallArg
    3              0.000014 syntax keyword typescriptDOMDocMethod contained createCDATASection createComment createDocumentFragment nextgroup=typescriptFuncCallArg
    3              0.000014 syntax keyword typescriptDOMDocMethod contained createElement createElementNS createEvent nextgroup=typescriptFuncCallArg
    3              0.000015 syntax keyword typescriptDOMDocMethod contained createExpression createNSResolver nextgroup=typescriptFuncCallArg
    3              0.000013 syntax keyword typescriptDOMDocMethod contained createProcessingInstruction createTextNode nextgroup=typescriptFuncCallArg
    3              0.000015 syntax keyword typescriptDOMDocMethod contained enableStyleSheetsForSet evaluate execCommand nextgroup=typescriptFuncCallArg
    3              0.000013 syntax keyword typescriptDOMDocMethod contained exitPointerLock getBoxObjectFor getElementById nextgroup=typescriptFuncCallArg
    3              0.000015 syntax keyword typescriptDOMDocMethod contained getElementsByClassName getElementsByTagName nextgroup=typescriptFuncCallArg
    3              0.000014 syntax keyword typescriptDOMDocMethod contained getElementsByTagNameNS getSelection nextgroup=typescriptFuncCallArg
    3              0.000014 syntax keyword typescriptDOMDocMethod contained hasFocus importNode loadOverlay open nextgroup=typescriptFuncCallArg
    3              0.000014 syntax keyword typescriptDOMDocMethod contained queryCommandSupported querySelector nextgroup=typescriptFuncCallArg
    3              0.000013 syntax keyword typescriptDOMDocMethod contained querySelectorAll write writeln nextgroup=typescriptFuncCallArg
    3              0.000012 syntax cluster props add=typescriptDOMDocMethod
    3              0.000015 if exists("did_typescript_hilink") | HiLink typescriptDOMDocMethod Keyword
    3              0.000000 endif

SCRIPT  /home/pyericz/.vimgo/plugged/yats.vim/syntax/yats/dom-event.vim
Sourced 3 times
Total time:   0.000872
 Self time:   0.000872

count  total (s)   self (s)
    3              0.000015 syntax keyword typescriptDOMEventTargetMethod contained addEventListener removeEventListener nextgroup=typescriptEventFuncCallArg
    3              0.000015 syntax keyword typescriptDOMEventTargetMethod contained dispatchEvent waitUntil nextgroup=typescriptEventFuncCallArg
    3              0.000011 syntax cluster props add=typescriptDOMEventTargetMethod
    3              0.000014 if exists("did_typescript_hilink") | HiLink typescriptDOMEventTargetMethod Keyword
    3              0.000001 endif
    3              0.000017 syntax keyword typescriptDOMEventCons containedin=typescriptIdentifierName AnimationEvent
    3              0.000015 syntax keyword typescriptDOMEventCons containedin=typescriptIdentifierName AudioProcessingEvent
    3              0.000017 syntax keyword typescriptDOMEventCons containedin=typescriptIdentifierName BeforeInputEvent
    3              0.000018 syntax keyword typescriptDOMEventCons containedin=typescriptIdentifierName BeforeUnloadEvent
    3              0.000015 syntax keyword typescriptDOMEventCons containedin=typescriptIdentifierName BlobEvent
    3              0.000016 syntax keyword typescriptDOMEventCons containedin=typescriptIdentifierName ClipboardEvent
    3              0.000015 syntax keyword typescriptDOMEventCons containedin=typescriptIdentifierName CloseEvent
    3              0.000016 syntax keyword typescriptDOMEventCons containedin=typescriptIdentifierName CompositionEvent
    3              0.000016 syntax keyword typescriptDOMEventCons containedin=typescriptIdentifierName CSSFontFaceLoadEvent
    3              0.000016 syntax keyword typescriptDOMEventCons containedin=typescriptIdentifierName CustomEvent
    3              0.000015 syntax keyword typescriptDOMEventCons containedin=typescriptIdentifierName DeviceLightEvent
    3              0.000015 syntax keyword typescriptDOMEventCons containedin=typescriptIdentifierName DeviceMotionEvent
    3              0.000015 syntax keyword typescriptDOMEventCons containedin=typescriptIdentifierName DeviceOrientationEvent
    3              0.000016 syntax keyword typescriptDOMEventCons containedin=typescriptIdentifierName DeviceProximityEvent
    3              0.000015 syntax keyword typescriptDOMEventCons containedin=typescriptIdentifierName DOMTransactionEvent
    3              0.000015 syntax keyword typescriptDOMEventCons containedin=typescriptIdentifierName DragEvent
    3              0.000015 syntax keyword typescriptDOMEventCons containedin=typescriptIdentifierName EditingBeforeInputEvent
    3              0.000016 syntax keyword typescriptDOMEventCons containedin=typescriptIdentifierName ErrorEvent
    3              0.000015 syntax keyword typescriptDOMEventCons containedin=typescriptIdentifierName FocusEvent
    3              0.000015 syntax keyword typescriptDOMEventCons containedin=typescriptIdentifierName GamepadEvent
    3              0.000015 syntax keyword typescriptDOMEventCons containedin=typescriptIdentifierName HashChangeEvent
    3              0.000016 syntax keyword typescriptDOMEventCons containedin=typescriptIdentifierName IDBVersionChangeEvent
    3              0.000015 syntax keyword typescriptDOMEventCons containedin=typescriptIdentifierName KeyboardEvent
    3              0.000015 syntax keyword typescriptDOMEventCons containedin=typescriptIdentifierName MediaStreamEvent
    3              0.000015 syntax keyword typescriptDOMEventCons containedin=typescriptIdentifierName MessageEvent
    3              0.000016 syntax keyword typescriptDOMEventCons containedin=typescriptIdentifierName MouseEvent
    3              0.000015 syntax keyword typescriptDOMEventCons containedin=typescriptIdentifierName MutationEvent
    3              0.000015 syntax keyword typescriptDOMEventCons containedin=typescriptIdentifierName OfflineAudioCompletionEvent
    3              0.000015 syntax keyword typescriptDOMEventCons containedin=typescriptIdentifierName PageTransitionEvent
    3              0.000016 syntax keyword typescriptDOMEventCons containedin=typescriptIdentifierName PointerEvent
    3              0.000015 syntax keyword typescriptDOMEventCons containedin=typescriptIdentifierName PopStateEvent
    3              0.000015 syntax keyword typescriptDOMEventCons containedin=typescriptIdentifierName ProgressEvent
    3              0.000015 syntax keyword typescriptDOMEventCons containedin=typescriptIdentifierName RelatedEvent
    3              0.000015 syntax keyword typescriptDOMEventCons containedin=typescriptIdentifierName RTCPeerConnectionIceEvent
    3              0.000016 syntax keyword typescriptDOMEventCons containedin=typescriptIdentifierName SensorEvent
    3              0.000015 syntax keyword typescriptDOMEventCons containedin=typescriptIdentifierName StorageEvent
    3              0.000015 syntax keyword typescriptDOMEventCons containedin=typescriptIdentifierName SVGEvent
    3              0.000016 syntax keyword typescriptDOMEventCons containedin=typescriptIdentifierName SVGZoomEvent
    3              0.000015 syntax keyword typescriptDOMEventCons containedin=typescriptIdentifierName TimeEvent
    3              0.000017 syntax keyword typescriptDOMEventCons containedin=typescriptIdentifierName TouchEvent
    3              0.000014 syntax keyword typescriptDOMEventCons containedin=typescriptIdentifierName TrackEvent
    3              0.000016 syntax keyword typescriptDOMEventCons containedin=typescriptIdentifierName TransitionEvent
    3              0.000015 syntax keyword typescriptDOMEventCons containedin=typescriptIdentifierName UIEvent
    3              0.000016 syntax keyword typescriptDOMEventCons containedin=typescriptIdentifierName UserProximityEvent
    3              0.000015 syntax keyword typescriptDOMEventCons containedin=typescriptIdentifierName WheelEvent
    3              0.000014 if exists("did_typescript_hilink") | HiLink typescriptDOMEventCons Structure
    3              0.000001 endif
    3              0.000007 syntax keyword typescriptDOMEventProp contained bubbles cancelable currentTarget defaultPrevented
    3              0.000006 syntax keyword typescriptDOMEventProp contained eventPhase target timeStamp type isTrusted
    3              0.000004 syntax keyword typescriptDOMEventProp contained isReload
    3              0.000011 syntax cluster props add=typescriptDOMEventProp
    3              0.000013 if exists("did_typescript_hilink") | HiLink typescriptDOMEventProp Keyword
    3              0.000001 endif
    3              0.000014 syntax keyword typescriptDOMEventMethod contained initEvent preventDefault stopImmediatePropagation nextgroup=typescriptEventFuncCallArg
    3              0.000014 syntax keyword typescriptDOMEventMethod contained stopPropagation respondWith default nextgroup=typescriptEventFuncCallArg
    3              0.000010 syntax cluster props add=typescriptDOMEventMethod
    3              0.000014 if exists("did_typescript_hilink") | HiLink typescriptDOMEventMethod Keyword
    3              0.000002 endif

SCRIPT  /home/pyericz/.vimgo/plugged/yats.vim/syntax/yats/dom-storage.vim
Sourced 3 times
Total time:   0.000110
 Self time:   0.000110

count  total (s)   self (s)
    3              0.000005 syntax keyword typescriptDOMStorage contained sessionStorage localStorage
    3              0.000014 if exists("did_typescript_hilink") | HiLink typescriptDOMStorage Keyword
    3              0.000001 endif
    3              0.000005 syntax keyword typescriptDOMStorageProp contained length
    3              0.000011 syntax cluster props add=typescriptDOMStorageProp
    3              0.000013 if exists("did_typescript_hilink") | HiLink typescriptDOMStorageProp Keyword
    3              0.000001 endif
    3              0.000015 syntax keyword typescriptDOMStorageMethod contained getItem key setItem removeItem nextgroup=typescriptFuncCallArg
    3              0.000014 syntax keyword typescriptDOMStorageMethod contained clear nextgroup=typescriptFuncCallArg
    3              0.000011 syntax cluster props add=typescriptDOMStorageMethod
    3              0.000012 if exists("did_typescript_hilink") | HiLink typescriptDOMStorageMethod Keyword
    3              0.000002 endif

SCRIPT  /home/pyericz/.vimgo/plugged/yats.vim/syntax/yats/dom-form.vim
Sourced 3 times
Total time:   0.000083
 Self time:   0.000083

count  total (s)   self (s)
    3              0.000006 syntax keyword typescriptDOMFormProp contained acceptCharset action elements encoding
    3              0.000007 syntax keyword typescriptDOMFormProp contained enctype length method name target
    3              0.000012 syntax cluster props add=typescriptDOMFormProp
    3              0.000014 if exists("did_typescript_hilink") | HiLink typescriptDOMFormProp Keyword
    3              0.000000 endif
    3              0.000015 syntax keyword typescriptDOMFormMethod contained reportValidity reset submit nextgroup=typescriptFuncCallArg
    3              0.000011 syntax cluster props add=typescriptDOMFormMethod
    3              0.000013 if exists("did_typescript_hilink") | HiLink typescriptDOMFormMethod Keyword
    3              0.000001 endif

SCRIPT  /home/pyericz/.vimgo/plugged/yats.vim/syntax/yats/css.vim
Sourced 3 times
Total time:   0.000476
 Self time:   0.000476

count  total (s)   self (s)
    3              0.000009 syntax keyword typescriptDOMStyle contained alignContent alignItems alignSelf animation
    3              0.000006 syntax keyword typescriptDOMStyle contained animationDelay animationDirection animationDuration
    3              0.000007 syntax keyword typescriptDOMStyle contained animationFillMode animationIterationCount
    3              0.000008 syntax keyword typescriptDOMStyle contained animationName animationPlayState animationTimingFunction
    3              0.000006 syntax keyword typescriptDOMStyle contained appearance backfaceVisibility background
    3              0.000006 syntax keyword typescriptDOMStyle contained backgroundAttachment backgroundBlendMode
    3              0.000006 syntax keyword typescriptDOMStyle contained backgroundClip backgroundColor backgroundImage
    3              0.000006 syntax keyword typescriptDOMStyle contained backgroundOrigin backgroundPosition backgroundRepeat
    3              0.000008 syntax keyword typescriptDOMStyle contained backgroundSize border borderBottom borderBottomColor
    3              0.000006 syntax keyword typescriptDOMStyle contained borderBottomLeftRadius borderBottomRightRadius
    3              0.000007 syntax keyword typescriptDOMStyle contained borderBottomStyle borderBottomWidth borderCollapse
    3              0.000006 syntax keyword typescriptDOMStyle contained borderColor borderImage borderImageOutset
    3              0.000008 syntax keyword typescriptDOMStyle contained borderImageRepeat borderImageSlice borderImageSource
    3              0.000006 syntax keyword typescriptDOMStyle contained borderImageWidth borderLeft borderLeftColor
    3              0.000006 syntax keyword typescriptDOMStyle contained borderLeftStyle borderLeftWidth borderRadius
    3              0.000006 syntax keyword typescriptDOMStyle contained borderRight borderRightColor borderRightStyle
    3              0.000006 syntax keyword typescriptDOMStyle contained borderRightWidth borderSpacing borderStyle
    3              0.000006 syntax keyword typescriptDOMStyle contained borderTop borderTopColor borderTopLeftRadius
    3              0.000006 syntax keyword typescriptDOMStyle contained borderTopRightRadius borderTopStyle borderTopWidth
    3              0.000006 syntax keyword typescriptDOMStyle contained borderWidth bottom boxDecorationBreak
    3              0.000006 syntax keyword typescriptDOMStyle contained boxShadow boxSizing breakAfter breakBefore
    3              0.000007 syntax keyword typescriptDOMStyle contained breakInside captionSide caretColor caretShape
    3              0.000008 syntax keyword typescriptDOMStyle contained caret clear clip clipPath color columns
    3              0.000006 syntax keyword typescriptDOMStyle contained columnCount columnFill columnGap columnRule
    3              0.000006 syntax keyword typescriptDOMStyle contained columnRuleColor columnRuleStyle columnRuleWidth
    3              0.000008 syntax keyword typescriptDOMStyle contained columnSpan columnWidth content counterIncrement
    3              0.000007 syntax keyword typescriptDOMStyle contained counterReset cursor direction display
    3              0.000006 syntax keyword typescriptDOMStyle contained emptyCells flex flexBasis flexDirection
    3              0.000006 syntax keyword typescriptDOMStyle contained flexFlow flexGrow flexShrink flexWrap
    3              0.000008 syntax keyword typescriptDOMStyle contained float font fontFamily fontFeatureSettings
    3              0.000008 syntax keyword typescriptDOMStyle contained fontKerning fontLanguageOverride fontSize
    3              0.000007 syntax keyword typescriptDOMStyle contained fontSizeAdjust fontStretch fontStyle fontSynthesis
    3              0.000006 syntax keyword typescriptDOMStyle contained fontVariant fontVariantAlternates fontVariantCaps
    3              0.000006 syntax keyword typescriptDOMStyle contained fontVariantEastAsian fontVariantLigatures
    3              0.000006 syntax keyword typescriptDOMStyle contained fontVariantNumeric fontVariantPosition
    3              0.000008 syntax keyword typescriptDOMStyle contained fontWeight grad grid gridArea gridAutoColumns
    3              0.000008 syntax keyword typescriptDOMStyle contained gridAutoFlow gridAutoPosition gridAutoRows
    3              0.000007 syntax keyword typescriptDOMStyle contained gridColumn gridColumnStart gridColumnEnd
    3              0.000007 syntax keyword typescriptDOMStyle contained gridRow gridRowStart gridRowEnd gridTemplate
    3              0.000006 syntax keyword typescriptDOMStyle contained gridTemplateAreas gridTemplateRows gridTemplateColumns
    3              0.000006 syntax keyword typescriptDOMStyle contained height hyphens imageRendering imageResolution
    3              0.000006 syntax keyword typescriptDOMStyle contained imageOrientation imeMode inherit justifyContent
    3              0.000007 syntax keyword typescriptDOMStyle contained left letterSpacing lineBreak lineHeight
    3              0.000005 syntax keyword typescriptDOMStyle contained listStyle listStyleImage listStylePosition
    3              0.000009 syntax keyword typescriptDOMStyle contained listStyleType margin marginBottom marginLeft
    3              0.000008 syntax keyword typescriptDOMStyle contained marginRight marginTop marks mask maskType
    3              0.000006 syntax keyword typescriptDOMStyle contained maxHeight maxWidth minHeight minWidth
    3              0.000007 syntax keyword typescriptDOMStyle contained mixBlendMode objectFit objectPosition
    3              0.000006 syntax keyword typescriptDOMStyle contained opacity order orphans outline outlineColor
    3              0.000006 syntax keyword typescriptDOMStyle contained outlineOffset outlineStyle outlineWidth
    3              0.000007 syntax keyword typescriptDOMStyle contained overflow overflowWrap overflowX overflowY
    3              0.000006 syntax keyword typescriptDOMStyle contained overflowClipBox padding paddingBottom
    3              0.000007 syntax keyword typescriptDOMStyle contained paddingLeft paddingRight paddingTop pageBreakAfter
    3              0.000006 syntax keyword typescriptDOMStyle contained pageBreakBefore pageBreakInside perspective
    3              0.000006 syntax keyword typescriptDOMStyle contained perspectiveOrigin pointerEvents position
    3              0.000006 syntax keyword typescriptDOMStyle contained quotes resize right shapeImageThreshold
    3              0.000007 syntax keyword typescriptDOMStyle contained shapeMargin shapeOutside tableLayout tabSize
    3              0.000006 syntax keyword typescriptDOMStyle contained textAlign textAlignLast textCombineHorizontal
    3              0.000006 syntax keyword typescriptDOMStyle contained textDecoration textDecorationColor textDecorationLine
    3              0.000006 syntax keyword typescriptDOMStyle contained textDecorationStyle textIndent textOrientation
    3              0.000006 syntax keyword typescriptDOMStyle contained textOverflow textRendering textShadow
    3              0.000006 syntax keyword typescriptDOMStyle contained textTransform textUnderlinePosition top
    3              0.000006 syntax keyword typescriptDOMStyle contained touchAction transform transformOrigin
    3              0.000006 syntax keyword typescriptDOMStyle contained transformStyle transition transitionDelay
    3              0.000005 syntax keyword typescriptDOMStyle contained transitionDuration transitionProperty
    3              0.000007 syntax keyword typescriptDOMStyle contained transitionTimingFunction unicodeBidi unicodeRange
    3              0.000007 syntax keyword typescriptDOMStyle contained userSelect userZoom verticalAlign visibility
    3              0.000006 syntax keyword typescriptDOMStyle contained whiteSpace width willChange wordBreak
    3              0.000006 syntax keyword typescriptDOMStyle contained wordSpacing wordWrap writingMode zIndex
    3              0.000016 if exists("did_typescript_hilink") | HiLink typescriptDOMStyle Keyword
    3              0.000002 endif

SCRIPT  /home/pyericz/.vimgo/plugged/yats.vim/syntax/yats/event.vim
Sourced 3 times
Total time:   0.001075
 Self time:   0.001075

count  total (s)   self (s)
    3              0.000006 syntax keyword typescriptAnimationEvent contained animationend animationiteration
    3              0.000006 syntax keyword typescriptAnimationEvent contained animationstart beginEvent endEvent
    3              0.000005 syntax keyword typescriptAnimationEvent contained repeatEvent
    3              0.000008 syntax cluster events add=typescriptAnimationEvent
    3              0.000019 if exists("did_typescript_hilink") | HiLink typescriptAnimationEvent Title
    3              0.000002 endif
    3              0.000004 syntax keyword typescriptCSSEvent contained CssRuleViewRefreshed CssRuleViewChanged
    3              0.000005 syntax keyword typescriptCSSEvent contained CssRuleViewCSSLinkClicked transitionend
    3              0.000009 syntax cluster events add=typescriptCSSEvent
    3              0.000015 if exists("did_typescript_hilink") | HiLink typescriptCSSEvent Title
    3              0.000000 endif
    3              0.000008 syntax keyword typescriptDatabaseEvent contained blocked complete error success upgradeneeded
    3              0.000004 syntax keyword typescriptDatabaseEvent contained versionchange
    3              0.000009 syntax cluster events add=typescriptDatabaseEvent
    3              0.000014 if exists("did_typescript_hilink") | HiLink typescriptDatabaseEvent Title
    3              0.000000 endif
    3              0.000006 syntax keyword typescriptDocumentEvent contained DOMLinkAdded DOMLinkRemoved DOMMetaAdded
    3              0.000005 syntax keyword typescriptDocumentEvent contained DOMMetaRemoved DOMWillOpenModalDialog
    3              0.000005 syntax keyword typescriptDocumentEvent contained DOMModalDialogClosed unload
    3              0.000008 syntax cluster events add=typescriptDocumentEvent
    3              0.000014 if exists("did_typescript_hilink") | HiLink typescriptDocumentEvent Title
    3              0.000001 endif
    3              0.000005 syntax keyword typescriptDOMMutationEvent contained DOMAttributeNameChanged DOMAttrModified
    3              0.000005 syntax keyword typescriptDOMMutationEvent contained DOMCharacterDataModified DOMContentLoaded
    3              0.000006 syntax keyword typescriptDOMMutationEvent contained DOMElementNameChanged DOMNodeInserted
    3              0.000004 syntax keyword typescriptDOMMutationEvent contained DOMNodeInsertedIntoDocument DOMNodeRemoved
    3              0.000005 syntax keyword typescriptDOMMutationEvent contained DOMNodeRemovedFromDocument DOMSubtreeModified
    3              0.000009 syntax cluster events add=typescriptDOMMutationEvent
    3              0.000013 if exists("did_typescript_hilink") | HiLink typescriptDOMMutationEvent Title
    3              0.000001 endif
    3              0.000005 syntax keyword typescriptDragEvent contained drag dragdrop dragend dragenter dragexit
    3              0.000006 syntax keyword typescriptDragEvent contained draggesture dragleave dragover dragstart
    3              0.000004 syntax keyword typescriptDragEvent contained drop
    3              0.000008 syntax cluster events add=typescriptDragEvent
    3              0.000015 if exists("did_typescript_hilink") | HiLink typescriptDragEvent Title
    3              0.000000 endif
    3              0.000006 syntax keyword typescriptElementEvent contained invalid overflow underflow DOMAutoComplete
    3              0.000006 syntax keyword typescriptElementEvent contained command commandupdate
    3              0.000007 syntax cluster events add=typescriptElementEvent
    3              0.000013 if exists("did_typescript_hilink") | HiLink typescriptElementEvent Title
    3              0.000001 endif
    3              0.000006 syntax keyword typescriptFocusEvent contained blur change DOMFocusIn DOMFocusOut focus
    3              0.000004 syntax keyword typescriptFocusEvent contained focusin focusout
    3              0.000008 syntax cluster events add=typescriptFocusEvent
    3              0.000013 if exists("did_typescript_hilink") | HiLink typescriptFocusEvent Title
    3              0.000002 endif
    3              0.000004 syntax keyword typescriptFormEvent contained reset submit
    3              0.000009 syntax cluster events add=typescriptFormEvent
    3              0.000013 if exists("did_typescript_hilink") | HiLink typescriptFormEvent Title
    3              0.000001 endif
    3              0.000005 syntax keyword typescriptFrameEvent contained DOMFrameContentLoaded
    3              0.000008 syntax cluster events add=typescriptFrameEvent
    3              0.000013 if exists("did_typescript_hilink") | HiLink typescriptFrameEvent Title
    3              0.000000 endif
    3              0.000006 syntax keyword typescriptInputDeviceEvent contained click contextmenu DOMMouseScroll
    3              0.000006 syntax keyword typescriptInputDeviceEvent contained dblclick gamepadconnected gamepaddisconnected
    3              0.000006 syntax keyword typescriptInputDeviceEvent contained keydown keypress keyup MozGamepadButtonDown
    3              0.000006 syntax keyword typescriptInputDeviceEvent contained MozGamepadButtonUp mousedown mouseenter
    3              0.000004 syntax keyword typescriptInputDeviceEvent contained mouseleave mousemove mouseout
    3              0.000005 syntax keyword typescriptInputDeviceEvent contained mouseover mouseup mousewheel MozMousePixelScroll
    3              0.000006 syntax keyword typescriptInputDeviceEvent contained pointerlockchange pointerlockerror
    3              0.000003 syntax keyword typescriptInputDeviceEvent contained wheel
    3              0.000009 syntax cluster events add=typescriptInputDeviceEvent
    3              0.000014 if exists("did_typescript_hilink") | HiLink typescriptInputDeviceEvent Title
    3              0.000002 endif
    3              0.000006 syntax keyword typescriptMediaEvent contained audioprocess canplay canplaythrough
    3              0.000006 syntax keyword typescriptMediaEvent contained durationchange emptied ended ended loadeddata
    3              0.000004 syntax keyword typescriptMediaEvent contained loadedmetadata MozAudioAvailable pause
    3              0.000005 syntax keyword typescriptMediaEvent contained play playing ratechange seeked seeking
    3              0.000006 syntax keyword typescriptMediaEvent contained stalled suspend timeupdate volumechange
    3              0.000005 syntax keyword typescriptMediaEvent contained waiting complete
    3              0.000007 syntax cluster events add=typescriptMediaEvent
    3              0.000014 if exists("did_typescript_hilink") | HiLink typescriptMediaEvent Title
    3              0.000001 endif
    3              0.000005 syntax keyword typescriptMenuEvent contained DOMMenuItemActive DOMMenuItemInactive
    3              0.000009 syntax cluster events add=typescriptMenuEvent
    3              0.000012 if exists("did_typescript_hilink") | HiLink typescriptMenuEvent Title
    3              0.000001 endif
    3              0.000006 syntax keyword typescriptNetworkEvent contained datachange dataerror disabled enabled
    3              0.000006 syntax keyword typescriptNetworkEvent contained offline online statuschange connectionInfoUpdate
    3              0.000009 syntax cluster events add=typescriptNetworkEvent
    3              0.000012 if exists("did_typescript_hilink") | HiLink typescriptNetworkEvent Title
    3              0.000001 endif
    3              0.000005 syntax keyword typescriptProgressEvent contained abort error load loadend loadstart
    3              0.000004 syntax keyword typescriptProgressEvent contained progress timeout uploadprogress
    3              0.000009 syntax cluster events add=typescriptProgressEvent
    3              0.000013 if exists("did_typescript_hilink") | HiLink typescriptProgressEvent Title
    3              0.000000 endif
    3              0.000006 syntax keyword typescriptResourceEvent contained cached error load
    3              0.000007 syntax cluster events add=typescriptResourceEvent
    3              0.000014 if exists("did_typescript_hilink") | HiLink typescriptResourceEvent Title
    3              0.000000 endif
    3              0.000006 syntax keyword typescriptScriptEvent contained afterscriptexecute beforescriptexecute
    3              0.000008 syntax cluster events add=typescriptScriptEvent
    3              0.000013 if exists("did_typescript_hilink") | HiLink typescriptScriptEvent Title
    3              0.000001 endif
    3              0.000005 syntax keyword typescriptSensorEvent contained compassneedscalibration devicelight
    3              0.000007 syntax keyword typescriptSensorEvent contained devicemotion deviceorientation deviceproximity
    3              0.000005 syntax keyword typescriptSensorEvent contained orientationchange userproximity
    3              0.000008 syntax cluster events add=typescriptSensorEvent
    3              0.000014 if exists("did_typescript_hilink") | HiLink typescriptSensorEvent Title
    3              0.000000 endif
    3              0.000006 syntax keyword typescriptSessionHistoryEvent contained pagehide pageshow popstate
    3              0.000009 syntax cluster events add=typescriptSessionHistoryEvent
    3              0.000013 if exists("did_typescript_hilink") | HiLink typescriptSessionHistoryEvent Title
    3              0.000000 endif
    3              0.000006 syntax keyword typescriptStorageEvent contained change storage
    3              0.000008 syntax cluster events add=typescriptStorageEvent
    3              0.000013 if exists("did_typescript_hilink") | HiLink typescriptStorageEvent Title
    3              0.000001 endif
    3              0.000006 syntax keyword typescriptSVGEvent contained SVGAbort SVGError SVGLoad SVGResize SVGScroll
    3              0.000006 syntax keyword typescriptSVGEvent contained SVGUnload SVGZoom
    3              0.000009 syntax cluster events add=typescriptSVGEvent
    3              0.000012 if exists("did_typescript_hilink") | HiLink typescriptSVGEvent Title
    3              0.000000 endif
    3              0.000005 syntax keyword typescriptTabEvent contained visibilitychange
    3              0.000007 syntax cluster events add=typescriptTabEvent
    3              0.000013 if exists("did_typescript_hilink") | HiLink typescriptTabEvent Title
    3              0.000001 endif
    3              0.000006 syntax keyword typescriptTextEvent contained compositionend compositionstart compositionupdate
    3              0.000005 syntax keyword typescriptTextEvent contained copy cut paste select text
    3              0.000008 syntax cluster events add=typescriptTextEvent
    3              0.000014 if exists("did_typescript_hilink") | HiLink typescriptTextEvent Title
    3              0.000000 endif
    3              0.000006 syntax keyword typescriptTouchEvent contained touchcancel touchend touchenter touchleave
    3              0.000005 syntax keyword typescriptTouchEvent contained touchmove touchstart
    3              0.000008 syntax cluster events add=typescriptTouchEvent
    3              0.000013 if exists("did_typescript_hilink") | HiLink typescriptTouchEvent Title
    3              0.000001 endif
    3              0.000005 syntax keyword typescriptUpdateEvent contained checking downloading error noupdate
    3              0.000004 syntax keyword typescriptUpdateEvent contained obsolete updateready
    3              0.000007 syntax cluster events add=typescriptUpdateEvent
    3              0.000014 if exists("did_typescript_hilink") | HiLink typescriptUpdateEvent Title
    3              0.000000 endif
    3              0.000006 syntax keyword typescriptValueChangeEvent contained hashchange input readystatechange
    3              0.000008 syntax cluster events add=typescriptValueChangeEvent
    3              0.000014 if exists("did_typescript_hilink") | HiLink typescriptValueChangeEvent Title
    3              0.000000 endif
    3              0.000005 syntax keyword typescriptViewEvent contained fullscreen fullscreenchange fullscreenerror
    3              0.000003 syntax keyword typescriptViewEvent contained resize scroll
    3              0.000009 syntax cluster events add=typescriptViewEvent
    3              0.000013 if exists("did_typescript_hilink") | HiLink typescriptViewEvent Title
    3              0.000001 endif
    3              0.000005 syntax keyword typescriptWebsocketEvent contained close error message open
    3              0.000009 syntax cluster events add=typescriptWebsocketEvent
    3              0.000013 if exists("did_typescript_hilink") | HiLink typescriptWebsocketEvent Title
    3              0.000002 endif
    3              0.000006 syntax keyword typescriptWindowEvent contained DOMWindowCreated DOMWindowClose DOMTitleChanged
    3              0.000009 syntax cluster events add=typescriptWindowEvent
    3              0.000014 if exists("did_typescript_hilink") | HiLink typescriptWindowEvent Title
    3              0.000000 endif
    3              0.000006 syntax keyword typescriptUncategorizedEvent contained beforeunload message open show
    3              0.000009 syntax cluster events add=typescriptUncategorizedEvent
    3              0.000013 if exists("did_typescript_hilink") | HiLink typescriptUncategorizedEvent Title
    3              0.000001 endif
    3              0.000005 syntax keyword typescriptServiceWorkerEvent contained install activate fetch
    3              0.000010 syntax cluster events add=typescriptServiceWorkerEvent
    3              0.000014 if exists("did_typescript_hilink") | HiLink typescriptServiceWorkerEvent Title
    3              0.000003 endif

SCRIPT  /home/pyericz/.vimgo/plugged/yats.vim/syntax/basic/patch.vim
Sourced 3 times
Total time:   0.000112
 Self time:   0.000112

count  total (s)   self (s)
                            " patch for generated code
    3              0.000063 syntax keyword typescriptGlobal Promise
                              \ nextgroup=typescriptGlobalPromiseDot,typescriptFuncCallArg,typescriptTypeArguments oneline
    3              0.000045 syntax keyword typescriptGlobal Map WeakMap
                              \ nextgroup=typescriptGlobalPromiseDot,typescriptFuncCallArg,typescriptTypeArguments oneline

SCRIPT  /home/pyericz/.vimgo/plugged/yats.vim/syntax/basic/members.vim
Sourced 3 times
Total time:   0.000310
 Self time:   0.000310

count  total (s)   self (s)
    3              0.000012 syntax keyword typescriptConstructor           contained constructor
                              \ nextgroup=@typescriptCallSignature
                              \ skipwhite skipempty
                            
                            
    3              0.000032 syntax cluster memberNextGroup contains=typescriptMemberOptionality,typescriptTypeAnnotation,@typescriptCallSignature
                            
    3              0.000018 syntax match typescriptMember /#\?\K\k*/
                              \ nextgroup=@memberNextGroup
                              \ contained skipwhite
                            
    3              0.000015 syntax match typescriptMethodAccessor contained /\v(get|set)\s\K/me=e-1
                              \ nextgroup=@typescriptMembers
                            
    3              0.000039 syntax cluster typescriptPropertyMemberDeclaration contains=
                              \ typescriptClassStatic,
                              \ typescriptAccessibilityModifier,
                              \ typescriptReadonlyModifier,
                              \ typescriptMethodAccessor,
                              \ @typescriptMembers
                              " \ typescriptMemberVariableDeclaration
                            
    3              0.000029 syntax match typescriptMemberOptionality /?\|!/ contained
                              \ nextgroup=typescriptTypeAnnotation,@typescriptCallSignature
                              \ skipwhite skipempty
                            
    3              0.000022 syntax cluster typescriptMembers contains=typescriptMember,typescriptStringMember,typescriptComputedMember
                            
    3              0.000029 syntax keyword typescriptClassStatic static
                              \ nextgroup=@typescriptMembers,typescriptAsyncFuncKeyword,typescriptReadonlyModifier
                              \ skipwhite contained
                            
    3              0.000009 syntax keyword typescriptAccessibilityModifier public private protected contained
                            
    3              0.000008 syntax keyword typescriptReadonlyModifier readonly override contained
                            
    3              0.000023 syntax region  typescriptStringMember   contained
                              \ start=/\z(["']\)/  skip=/\\\\\|\\\z1\|\\\n/  end=/\z1/
                              \ nextgroup=@memberNextGroup
                              \ skipwhite skipempty
                            
    3              0.000062 syntax region  typescriptComputedMember   contained matchgroup=typescriptProperty
                              \ start=/\[/rs=s+1 end=/]/
                              \ contains=@typescriptValue,typescriptMember,typescriptMappedIn,typescriptCastKeyword
                              \ nextgroup=@memberNextGroup
                              \ skipwhite skipempty

SCRIPT  /home/pyericz/.vimgo/plugged/yats.vim/syntax/basic/class.vim
Sourced 3 times
Total time:   0.000565
 Self time:   0.000565

count  total (s)   self (s)
                            "don't add typescriptMembers to nextgroup, let outer scope match it
                            " so we won't match abstract method outside abstract class
    3              0.000027 syntax keyword typescriptAbstract              abstract
                              \ nextgroup=typescriptClassKeyword
                              \ skipwhite skipnl
    3              0.000033 syntax keyword typescriptClassKeyword          class
                              \ nextgroup=typescriptClassName,typescriptClassExtends,typescriptClassBlock
                              \ skipwhite
                            
    3              0.000033 syntax match   typescriptClassName             contained /\K\k*/
                              \ nextgroup=typescriptClassBlock,typescriptClassExtends,typescriptClassTypeParameter
                              \ skipwhite skipnl
                            
    3              0.000027 syntax region typescriptClassTypeParameter
                              \ start=/</ end=/>/
                              \ contains=@typescriptTypeParameterCluster
                              \ nextgroup=typescriptClassBlock,typescriptClassExtends
                              \ contained skipwhite skipnl
                            
    3              0.000014 syntax keyword typescriptClassExtends          contained extends implements nextgroup=typescriptClassHeritage skipwhite skipnl
                            
    3              0.000040 syntax match   typescriptClassHeritage         contained /\v(\k|\.|\(|\))+/
                              \ nextgroup=typescriptClassBlock,typescriptClassExtends,typescriptMixinComma,typescriptClassTypeArguments
                              \ contains=@typescriptValue
                              \ skipwhite skipnl
                              \ contained
                            
    3              0.000041 syntax region typescriptClassTypeArguments matchgroup=typescriptTypeBrackets
                              \ start=/</ end=/>/
                              \ contains=@typescriptType
                              \ nextgroup=typescriptClassExtends,typescriptClassBlock,typescriptMixinComma
                              \ contained skipwhite skipnl
                            
    3              0.000014 syntax match typescriptMixinComma /,/ contained nextgroup=typescriptClassHeritage skipwhite skipnl
                            
                            " we need add arrowFunc to class block for high order arrow func
                            " see test case
    3              0.000076 syntax region  typescriptClassBlock matchgroup=typescriptBraces start=/{/ end=/}/
                              \ contains=@typescriptPropertyMemberDeclaration,typescriptAbstract,@typescriptComments,typescriptBlock,typescriptAssign,typescriptDecorator,typescriptAsyncFuncKeyword,typescriptArrowFunc
                              \ contained fold
                            
    3              0.000019 syntax keyword typescriptInterfaceKeyword          interface nextgroup=typescriptInterfaceName skipwhite
    3              0.000031 syntax match   typescriptInterfaceName             contained /\k\+/
                              \ nextgroup=typescriptObjectType,typescriptInterfaceExtends,typescriptInterfaceTypeParameter
                              \ skipwhite skipnl
    3              0.000028 syntax region typescriptInterfaceTypeParameter
                              \ start=/</ end=/>/
                              \ contains=@typescriptTypeParameterCluster
                              \ nextgroup=typescriptObjectType,typescriptInterfaceExtends
                              \ contained
                              \ skipwhite skipnl
                            
    3              0.000041 syntax keyword typescriptInterfaceExtends          contained extends nextgroup=typescriptInterfaceHeritage skipwhite skipnl
                            
    3              0.000056 syntax match typescriptInterfaceHeritage contained /\v(\k|\.)+/
                              \ nextgroup=typescriptObjectType,typescriptInterfaceComma,typescriptInterfaceTypeArguments
                              \ skipwhite
                            
    3              0.000047 syntax region typescriptInterfaceTypeArguments matchgroup=typescriptTypeBrackets
                              \ start=/</ end=/>/ skip=/\s*,\s*/
                              \ contains=@typescriptType
                              \ nextgroup=typescriptObjectType,typescriptInterfaceComma
                              \ contained skipwhite
                            
    3              0.000018 syntax match typescriptInterfaceComma /,/ contained nextgroup=typescriptInterfaceHeritage skipwhite skipnl

SCRIPT  /home/pyericz/.vimgo/plugged/yats.vim/syntax/basic/cluster.vim
Sourced 3 times
Total time:   0.000507
 Self time:   0.000507

count  total (s)   self (s)
                            "Block VariableStatement EmptyStatement ExpressionStatement IfStatement IterationStatement ContinueStatement BreakStatement ReturnStatement WithStatement LabelledStatement SwitchStatement ThrowStatement TryStatement DebuggerStatement
    3              0.000186 syntax cluster typescriptStatement
                              \ contains=typescriptBlock,typescriptVariable,
                              \ @typescriptTopExpression,typescriptAssign,
                              \ typescriptConditional,typescriptRepeat,typescriptBranch,
                              \ typescriptLabel,typescriptStatementKeyword,
                              \ typescriptFuncKeyword,
                              \ typescriptTry,typescriptExceptions,typescriptDebugger,
                              \ typescriptExport,typescriptInterfaceKeyword,typescriptEnum,
                              \ typescriptModule,typescriptAliasKeyword,typescriptImport
                            
    3              0.000071 syntax cluster typescriptPrimitive  contains=typescriptString,typescriptTemplate,typescriptRegexpString,typescriptNumber,typescriptBoolean,typescriptNull,typescriptArray
                            
    3              0.000050 syntax cluster typescriptEventTypes            contains=typescriptEventString,typescriptTemplate,typescriptNumber,typescriptBoolean,typescriptNull
                            
                            " top level expression: no arrow func
                            " also no func keyword. funcKeyword is contained in statement
                            " funcKeyword allows overloading (func without body)
                            " funcImpl requires body
    3              0.000097 syntax cluster typescriptTopExpression
                              \ contains=@typescriptPrimitive,
                              \ typescriptIdentifier,typescriptIdentifierName,
                              \ typescriptOperator,typescriptUnaryOp,
                              \ typescriptParenExp,typescriptRegexpString,
                              \ typescriptGlobal,typescriptAsyncFuncKeyword,
                              \ typescriptClassKeyword,typescriptTypeCast
                            
                            " no object literal, used in type cast and arrow func
                            " TODO: change func keyword to funcImpl
    3              0.000015 syntax cluster typescriptExpression
                              \ contains=@typescriptTopExpression,
                              \ typescriptArrowFuncDef,
                              \ typescriptFuncImpl
                            
    3              0.000013 syntax cluster typescriptValue
                              \ contains=@typescriptExpression,typescriptObjectLiteral
                            
    3              0.000057 syntax cluster typescriptEventExpression       contains=typescriptArrowFuncDef,typescriptParenExp,@typescriptValue,typescriptRegexpString,@typescriptEventTypes,typescriptOperator,typescriptGlobal,jsxRegion

SCRIPT  /home/pyericz/.vimgo/plugged/yats.vim/syntax/basic/function.vim
Sourced 3 times
Total time:   0.000476
 Self time:   0.000476

count  total (s)   self (s)
    3              0.000042 syntax keyword typescriptAsyncFuncKeyword      async
                              \ nextgroup=typescriptFuncKeyword,typescriptArrowFuncDef,typescriptArrowFuncTypeParameter
                              \ skipwhite
                            
    3              0.000014 syntax keyword typescriptAsyncFuncKeyword      await
                              \ nextgroup=@typescriptValue
                              \ skipwhite
                            
    3              0.000044 exec 'syntax keyword typescriptFuncKeyword '.(exists('g:typescript_conceal_function') ? 'conceal cchar='.g:typescript_conceal_function : '').' function nextgroup=typescriptAsyncFunc,typescriptFuncName,@typescriptCallSignature skipwhite skipempty'
                            
    3              0.000018 syntax match   typescriptAsyncFunc             contained /*/
                              \ nextgroup=typescriptFuncName,@typescriptCallSignature
                              \ skipwhite skipempty
                            
    3              0.000008 syntax match   typescriptFuncName              contained /\K\k*/
                              \ nextgroup=@typescriptCallSignature
                              \ skipwhite
                            
    3              0.000037 syntax match   typescriptArrowFuncDef          contained /\K\k*\s*=>/
                              \ contains=typescriptArrowFuncArg,typescriptArrowFunc
                              \ nextgroup=@typescriptExpression,typescriptBlock
                              \ skipwhite skipempty
                            
    3              0.000039 syntax match   typescriptArrowFuncDef          contained /(\%(\_[^()]\+\|(\_[^()]*)\)*)\_s*=>/
                              \ contains=typescriptArrowFuncArg,typescriptArrowFunc,@typescriptCallSignature
                              \ nextgroup=@typescriptExpression,typescriptBlock
                              \ skipwhite skipempty
                            
    3              0.000057 syntax region  typescriptArrowFuncDef          contained start=/(\%(\_[^()]\+\|(\_[^()]*)\)*):/ matchgroup=typescriptArrowFunc end=/=>/
                              \ contains=typescriptArrowFuncArg,typescriptTypeAnnotation,@typescriptCallSignature
                              \ nextgroup=@typescriptExpression,typescriptBlock
                              \ skipwhite skipempty keepend
                            
    3              0.000015 syntax region  typescriptArrowFuncTypeParameter start=/</ end=/>/
                              \ contains=@typescriptTypeParameterCluster
                              \ nextgroup=typescriptArrowFuncDef
                              \ contained skipwhite skipnl
                            
    3              0.000011 syntax match   typescriptArrowFunc             /=>/
    3              0.000007 syntax match   typescriptArrowFuncArg          contained /\K\k*/
                            
    3              0.000022 syntax region typescriptReturnAnnotation contained start=/:/ end=/{/me=e-1 contains=@typescriptType nextgroup=typescriptBlock
                            
                            
    3              0.000049 syntax region typescriptFuncImpl contained start=/function\>/ end=/{/me=e-1
                              \ contains=typescriptFuncKeyword
                              \ nextgroup=typescriptBlock
                            
    3              0.000019 syntax cluster typescriptCallImpl contains=typescriptGenericImpl,typescriptParamImpl
    3              0.000035 syntax region typescriptGenericImpl matchgroup=typescriptTypeBrackets
                              \ start=/</ end=/>/ skip=/\s*,\s*/
                              \ contains=typescriptTypeParameter
                              \ nextgroup=typescriptParamImpl
                              \ contained skipwhite
    3              0.000045 syntax region typescriptParamImpl matchgroup=typescriptParens
                              \ start=/(/ end=/)/
                              \ contains=typescriptDecorator,@typescriptParameterList,@typescriptComments
                              \ nextgroup=typescriptReturnAnnotation,typescriptBlock
                              \ contained skipwhite skipnl

SCRIPT  /home/pyericz/.vimgo/plugged/yats.vim/syntax/basic/decorator.vim
Sourced 3 times
Total time:   0.000063
 Self time:   0.000063

count  total (s)   self (s)
    3              0.000060 syntax match typescriptDecorator /@\([_$a-zA-Z][_$a-zA-Z0-9]*\.\)*[_$a-zA-Z][_$a-zA-Z0-9]*\>/
                              \ nextgroup=typescriptFuncCallArg,typescriptTypeArguments
                              \ contains=@_semantic,typescriptDotNotation

SCRIPT  /home/pyericz/.vimgo/plugged/vim-polyglot/syntax/typescript.vim
Sourced 3 times
Total time:   0.000093
 Self time:   0.000079

count  total (s)   self (s)
    3   0.000066   0.000052 if polyglot#init#is_disabled(expand('<sfile>:p'), 'typescript', 'syntax/typescript.vim')
                              finish
    3              0.000000 endif
                            
                            " Vim syntax file
                            " Language:     TypeScript
                            " Maintainer:   Herrington Darkholme
                            " Last Change:  2016-04-05
                            " Version:      1.0
                            " Changes:      Go to https:github.com/HerringtonDarkholme/yats.vim for recent changes.
                            " Origin:       https://github.com/othree/yajs
                            " Credits:      Kao Wei-Ko(othree), Jose Elera Campana, Zhao Yi, Claudio Fleiner, Scott Shattuck
                            "               (This file is based on their hard work), gumnos (From the #vim
                            "               IRC Channel in Freenode)
                            
                            
    3              0.000004 if !exists("main_syntax")
    3              0.000005   if exists("b:current_syntax")
    3              0.000002     finish
                              endif
                              let main_syntax = 'typescript'
                            endif
                            
                            " nextgroup doesn't contain objectLiteral, let outer region contains it
                            syntax region typescriptTypeCast matchgroup=typescriptTypeBrackets
                              \ start=/< \@!/ end=/>/
                              \ contains=@typescriptType
                              \ nextgroup=@typescriptExpression
                              \ contained skipwhite oneline
                            
                            runtime syntax/common.vim
                            
                            let b:current_syntax = "typescript"
                            if main_syntax == 'typescript'
                              unlet main_syntax
                            endif

SCRIPT  /home/pyericz/.vimgo/plugged/yats.vim/autoload/yats.vim
Sourced 1 time
Total time:   0.000043
 Self time:   0.000043

count  total (s)   self (s)
                            " Regex of syntax group names that are strings or documentation.
    1              0.000005 let s:syng_multiline = 'comment\c'
                            
                            " Regex of syntax group names that are line comment.
    1              0.000003 let s:syng_linecom = 'linecomment\c'
                            
                            " Check if the character at lnum:col is inside a multi-line comment.
    1              0.000006 function yats#IsInMultilineComment(lnum, col)
                              return !yats#IsLineComment(a:lnum, a:col) && synIDattr(synID(a:lnum, a:col, 1), 'name') =~ s:syng_multiline
                            endfunction
                            
                            " Check if the character at lnum:col is a line comment.
    1              0.000004 function yats#IsLineComment(lnum, col)
                              return synIDattr(synID(a:lnum, a:col, 1), 'name') =~ s:syng_linecom
                            endfunction
                            

SCRIPT  /home/pyericz/.vimgo/plugged/coc.nvim/autoload/coc/pum.vim
Sourced 1 time
Total time:   0.000285
 Self time:   0.000268

count  total (s)   self (s)
    1              0.000003 scriptencoding utf-8
    1              0.000009 let s:is_vim = !has('nvim')
    1              0.000001 let s:pum_bufnr = 0
    1              0.000001 let s:pum_winid = 0
    1              0.000001 let s:pum_index = -1
    1              0.000001 let s:pum_size = 0
    1              0.000001 let s:inserted = 0
    1              0.000001 let s:virtual_text = 0
    1   0.000023   0.000006 let s:virtual_text_ns = coc#highlight#create_namespace('pum-virtual')
    1              0.000005 let s:ignore = s:is_vim || has('nvim-0.5.0') ? "\<Ignore>" : "\<space>\<bs>"
    1              0.000004 let s:hide_pum = has('nvim-0.6.1') || has('patch-8.2.3389')
    1              0.000004 let s:virtual_text_support = has('nvim-0.5.0') || has('patch-9.0.0067')
                            " bufnr, &indentkeys
    1              0.000001 let s:saved_indenetkeys = []
    1              0.000001 let s:prop_id = 0
    1              0.000001 let s:reversed = 0
    1              0.000002 let s:check_hl_group = 0
    1              0.000001 let s:start_col = -1
                            
    1              0.000002 if s:is_vim && s:virtual_text_support
    1              0.000003   if empty(prop_type_get('CocPumVirtualText'))
    1              0.000009     call prop_type_add('CocPumVirtualText', {'highlight': 'CocPumVirtualText'})
    1              0.000000   endif
    1              0.000001 endif
                            
    1              0.000002 function! coc#pum#visible() abort
                              if !s:pum_winid
                                return 0
                              endif
                              return getwinvar(s:pum_winid, 'float', 0) == 1
                            endfunction
                            
    1              0.000001 function! coc#pum#winid() abort
                              return s:pum_winid
                            endfunction
                            
    1              0.000001 function! coc#pum#close_detail() abort
                              let winid = coc#float#get_float_by_kind('pumdetail')
                              if winid
                                call coc#float#close(winid, 1)
                                if s:is_vim
                                  call timer_start(0, { -> execute('redraw')})
                                endif
                              endif
                            endfunction
                            
    1              0.000001 function! coc#pum#close(...) abort
                              if coc#float#valid(s:pum_winid)
                                let kind = get(a:, 1, '')
                                if kind ==# 'cancel'
                                  let input = getwinvar(s:pum_winid, 'input', '')
                                  let s:pum_index = -1
                                  call s:insert_word(input)
                                  call s:on_pum_change(0)
                                  doautocmd <nomodeline> TextChangedI
                                elseif kind ==# 'confirm'
                                  let words = getwinvar(s:pum_winid, 'words', [])
                                  if s:pum_index >= 0
                                    let word = get(words, s:pum_index, '')
                                    call s:insert_word(word)
                                    " have to restore here, so that TextChangedI can trigger indent.
                                    call s:restore_indentkeys()
                                  endif
                                  doautocmd <nomodeline> TextChangedI
                                endif
                                call s:close_pum()
                                if !get(a:, 2, 0)
                                  " vim possible have unexpected text inserted without timer.
                                  call timer_start(1, { -> coc#rpc#notify('CompleteStop', [kind])})
                                endif
                              endif
                            endfunction
                            
    1              0.000001 function! coc#pum#select_confirm() abort
                              if s:pum_index < 0
                                let s:pum_index = 0
                                call s:on_pum_change(0)
                              endif
                              call coc#pum#close('confirm')
                            endfunction
                            
    1              0.000001 function! coc#pum#insert() abort
                              call timer_start(1, { -> s:insert_current()})
                              return s:ignore
                            endfunction
                            
                            " Add one more character from the matched complete item(or first one),
                            " the word should starts with input, the same as vim's CTRL-L behavior.
    1              0.000000 function! coc#pum#one_more() abort
                              call timer_start(1, { -> s:insert_one_more()})
                              return ''
                            endfunction
                            
    1              0.000000 function! coc#pum#_close() abort
                              if coc#float#valid(s:pum_winid)
                                call s:close_pum()
                                if s:is_vim
                                  call timer_start(0, { -> execute('redraw')})
                                endif
                              endif
                            endfunction
                            
    1              0.000002 function! s:insert_one_more() abort
                              if coc#float#valid(s:pum_winid)
                                let parts = getwinvar(s:pum_winid, 'parts', [])
                                let start = strlen(parts[0])
                                let input = strpart(getline('.'), start, col('.') - 1 - start)
                                let words = getwinvar(s:pum_winid, 'words', [])
                                let word = get(words, s:pum_index == -1 ? 0 : s:pum_index, '')
                                if !empty(word) && strcharpart(word, 0, strchars(input)) ==# input
                                  let ch = strcharpart(word, strchars(input), 1)
                                  if !empty(ch)
                                    call feedkeys(ch, "int")
                                  endif
                                endif
                              endif
                            endfunction
                            
    1              0.000001 function! s:insert_current() abort
                              if coc#float#valid(s:pum_winid)
                                if s:pum_index >= 0
                                  let words = getwinvar(s:pum_winid, 'words', [])
                                  let word = get(words, s:pum_index, '')
                                  call s:insert_word(word)
                                  call s:restore_indentkeys()
                                endif
                                doautocmd <nomodeline> TextChangedI
                                call s:close_pum()
                                call coc#rpc#notify('CompleteStop', [''])
                              endif
                            endfunction
                            
    1              0.000001 function! s:close_pum() abort
                              call s:clear_virtual_text()
                              call coc#float#close(s:pum_winid, 1)
                              let s:pum_winid = 0
                              let s:pum_size = 0
                              let winid = coc#float#get_float_by_kind('pumdetail')
                              if winid
                                call coc#float#close(winid, 1)
                              endif
                              call s:restore_indentkeys()
                            endfunction
                            
    1              0.000001 function! s:restore_indentkeys() abort
                              if get(s:saved_indenetkeys, 0, 0) == bufnr('%')
                                call setbufvar(s:saved_indenetkeys[0], '&indentkeys', get(s:saved_indenetkeys, 1, ''))
                                let s:saved_indenetkeys = []
                              endif
                            endfunction
                            
    1              0.000001 function! coc#pum#next(insert) abort
                              call timer_start(1, { -> s:navigate(1, a:insert)})
                              return s:ignore
                            endfunction
                            
    1              0.000001 function! coc#pum#prev(insert) abort
                              call timer_start(1, { -> s:navigate(0, a:insert)})
                              return s:ignore
                            endfunction
                            
    1              0.000000 function! coc#pum#stop() abort
                              call timer_start(1, { -> coc#pum#close()})
                              return s:ignore
                            endfunction
                            
    1              0.000001 function! coc#pum#cancel() abort
                              call timer_start(1, { -> coc#pum#close('cancel')})
                              return s:ignore
                            endfunction
                            
    1              0.000001 function! coc#pum#confirm() abort
                              call timer_start(1, { -> coc#pum#close('confirm')})
                              return s:ignore
                            endfunction
                            
    1              0.000001 function! coc#pum#select(index, insert, confirm) abort
                              if !coc#float#valid(s:pum_winid)
                                return ''
                              endif
                              if a:index == -1
                                call coc#pum#close('cancel')
                                return ''
                              endif
                              if a:index < 0 || a:index >= s:pum_size
                                throw 'index out of range ' . a:index
                              endif
                              call s:select_by_index(a:index, a:insert)
                              if a:confirm
                                call coc#pum#close('confirm')
                              endif
                              return ''
                            endfunction
                            
    1              0.000001 function! coc#pum#info() abort
                              let bufnr = winbufnr(s:pum_winid)
                              let words = getwinvar(s:pum_winid, 'words', [])
                              let word = s:pum_index < 0 ? '' : get(words, s:pum_index, '')
                              let pretext = strpart(getline('.'), 0, col('.') - 1)
                              let base = {
                                    \ 'word': word,
                                    \ 'index': s:pum_index,
                                    \ 'size': s:pum_size,
                                    \ 'startcol': s:start_col,
                                    \ 'inserted': s:inserted ? v:true : v:false,
                                    \ 'reversed': s:reversed ? v:true : v:false,
                                    \ }
                              if s:is_vim
                                let pos = popup_getpos(s:pum_winid)
                                let border = has_key(popup_getoptions(s:pum_winid), 'border')
                                let add = pos['scrollbar'] && border ? 1 : 0
                                return extend(base, {
                                      \ 'scrollbar': pos['scrollbar'],
                                      \ 'row': pos['line'] - 1,
                                      \ 'col': pos['col'] - 1,
                                      \ 'width': pos['width'] + add,
                                      \ 'height': pos['height'],
                                      \ 'border': border,
                                      \ })
                              else
                                let scrollbar = coc#float#get_related(s:pum_winid, 'scrollbar')
                                let winid = coc#float#get_related(s:pum_winid, 'border', s:pum_winid)
                                let pos = nvim_win_get_position(winid)
                                return extend(base, {
                                      \ 'scrollbar': scrollbar && nvim_win_is_valid(scrollbar) ? 1 : 0,
                                      \ 'row': pos[0],
                                      \ 'col': pos[1],
                                      \ 'width': nvim_win_get_width(winid),
                                      \ 'height': nvim_win_get_height(winid),
                                      \ 'border': winid != s:pum_winid,
                                      \ })
                              endif
                            endfunction
                            
    1              0.000001 function! coc#pum#scroll(forward) abort
                              if coc#pum#visible()
                                let height = s:get_height(s:pum_winid)
                                if s:pum_size > height
                                  call timer_start(10, { -> s:scroll_pum(a:forward, height, s:pum_size)})
                                endif
                              endif
                              return s:ignore
                            endfunction
                            
    1              0.000001 function! s:get_height(winid) abort
                              if has('nvim')
                                return nvim_win_get_height(a:winid)
                              endif
                              return get(popup_getpos(a:winid), 'core_height', 0)
                            endfunction
                            
    1              0.000001 function! s:scroll_pum(forward, height, size) abort
                              let topline = s:get_topline(s:pum_winid)
                              if !a:forward && topline == 1
                                if s:pum_index >= 0
                                  call s:select_line(s:pum_winid, 1)
                                  call s:on_pum_change(1)
                                endif
                                return
                              endif
                              if a:forward && topline + a:height - 1 >= a:size
                                if s:pum_index >= 0
                                  call s:select_line(s:pum_winid, a:size)
                                  call s:on_pum_change(1)
                                endif
                                return
                              endif
                              call coc#float#scroll_win(s:pum_winid, a:forward, a:height)
                              if s:pum_index >= 0
                                let lnum = s:pum_index + 1
                                let topline = s:get_topline(s:pum_winid)
                                if lnum >= topline && lnum <= topline + a:height - 1
                                  return
                                endif
                                call s:select_line(s:pum_winid, topline)
                                call s:on_pum_change(1)
                              endif
                            endfunction
                            
    1              0.000001 function! s:get_topline(winid) abort
                              if has('nvim')
                                let info = getwininfo(a:winid)[0]
                                return info['topline']
                              else
                                let pos = popup_getpos(a:winid)
                                return pos['firstline']
                              endif
                            endfunction
                            
    1              0.000001 function! s:navigate(next, insert) abort
                              if !coc#float#valid(s:pum_winid)
                                return
                              endif
                              call s:save_indentkeys()
                              let index = s:get_index(a:next)
                              call s:select_by_index(index, a:insert)
                            endfunction
                            
    1              0.000001 function! s:select_by_index(index, insert) abort
                              let lnum = a:index == -1 ? 0 : s:index_to_lnum(a:index)
                              call s:set_cursor(s:pum_winid, lnum)
                              if !s:is_vim
                                call coc#float#nvim_scrollbar(s:pum_winid)
                              endif
                              if a:insert
                                let s:inserted = 1
                                if a:index < 0
                                  let input = getwinvar(s:pum_winid, 'input', '')
                                  call s:insert_word(input)
                                  call coc#pum#close_detail()
                                else
                                  let words = getwinvar(s:pum_winid, 'words', [])
                                  let word = get(words, a:index, '')
                                  call s:insert_word(word)
                                endif
                                doautocmd <nomodeline> TextChangedP
                              endif
                              call s:on_pum_change(1)
                            endfunction
                            
    1              0.000001 function! s:get_index(next) abort
                              if a:next
                                let index = s:pum_index + 1 == s:pum_size ? -1 : s:pum_index + 1
                              else
                                let index = s:pum_index == -1 ? s:pum_size - 1 : s:pum_index - 1
                              endif
                              return index
                            endfunction
                            
    1              0.000001 function! s:insert_word(word) abort
                              if s:start_col != -1 && mode() ==# 'i'
                                let curr = getline('.')
                                let saved_completeopt = &completeopt
                                if saved_completeopt =~ 'menuone'
                                  noa set completeopt=menu
                                endif
                                noa call complete(s:start_col + 1, [{ 'empty': v:true, 'word': a:word }])
                                " exit complete state
                                if s:hide_pum
                                  call feedkeys("\<C-x>\<C-z>", 'in')
                                else
                                  let g:coc_disable_space_report = 1
                                  call feedkeys("\<space>\<bs>", 'in')
                                endif
                                execute 'noa set completeopt='.saved_completeopt
                              endif
                            endfunction
                            
                            " create or update pum with lines, CompleteOption and config.
                            " return winid & dimension
    1              0.000001 function! coc#pum#create(lines, opt, config) abort
                              if mode() !=# 'i' || a:opt['line'] != line('.')
                                return
                              endif
                              let len = col('.') - a:opt['col'] - 1
                              if len < 0
                                return
                              endif
                              let input = len == 0 ? '' : strpart(getline('.'), a:opt['col'], len)
                              if input !=# a:opt['input']
                                return
                              endif
                              let config = s:get_pum_dimension(a:lines, a:opt['col'], a:config)
                              if empty(config)
                                return
                              endif
                              let s:reversed = get(a:config, 'reverse', 0) && config['row'] < 0
                              let s:virtual_text = s:virtual_text_support && a:opt['virtualText']
                              let s:pum_size = len(a:lines)
                              let s:pum_index = a:opt['index']
                              let lnum = s:index_to_lnum(s:pum_index)
                              call extend(config, {
                                    \ 'lines': s:reversed ? reverse(copy(a:lines)) : a:lines,
                                    \ 'relative': 'cursor',
                                    \ 'nopad': 1,
                                    \ 'cursorline': 1,
                                    \ 'index': lnum - 1,
                                    \ 'focusable': v:false
                                    \ })
                              call extend(config, coc#dict#pick(a:config, ['highlight', 'rounded', 'highlights', 'winblend', 'shadow', 'border', 'borderhighlight']))
                              if s:reversed
                                for item in config['highlights']
                                  let item['lnum'] = s:pum_size - item['lnum'] - 1
                                endfor
                              endif
                              if empty(get(config, 'winblend', 0)) && exists('&pumblend')
                                let config['winblend'] = &pumblend
                              endif
                              let result =  coc#float#create_float_win(s:pum_winid, s:pum_bufnr, config)
                              if empty(result)
                                return
                              endif
                              let s:inserted = 0
                              let s:pum_winid = result[0]
                              let s:pum_bufnr = result[1]
                              let s:start_col = a:opt['startcol']
                              call setwinvar(s:pum_winid, 'above', config['row'] < 0)
                              let firstline = s:get_firstline(lnum, s:pum_size, config['height'])
                              if s:is_vim
                                call popup_setoptions(s:pum_winid, { 'firstline': firstline })
                              else
                                call coc#compat#execute(s:pum_winid, 'call winrestview({"lnum":'.lnum.',"topline":'.firstline.'})')
                              endif
                              call coc#dialog#place_sign(s:pum_bufnr, s:pum_index == -1 ? 0 : lnum)
                              " content before col and content after cursor
                              let linetext = getline('.')
                              let parts = [strpart(linetext, 0, s:start_col), strpart(linetext, col('.') - 1)]
                              let input = strpart(getline('.'), s:start_col, col('.') - 1 - s:start_col)
                              call setwinvar(s:pum_winid, 'input', input)
                              call setwinvar(s:pum_winid, 'parts', parts)
                              call setwinvar(s:pum_winid, 'words', a:opt['words'])
                              call setwinvar(s:pum_winid, 'kind', 'pum')
                              if !s:is_vim
                                if s:pum_size > config['height']
                                  redraw
                                  call coc#float#nvim_scrollbar(s:pum_winid)
                                else
                                  call coc#float#close_related(s:pum_winid, 'scrollbar')
                                endif
                              endif
                              call s:on_pum_change(0)
                            endfunction
                            
    1              0.000000 function! s:save_indentkeys() abort
                              let bufnr = bufnr('%')
                              if !empty(&indentexpr) && get(s:saved_indenetkeys, 0, 0) != bufnr
                                let s:saved_indenetkeys = [bufnr, &indentkeys]
                                execute 'setl indentkeys='
                              endif
                            endfunction
                            
    1              0.000001 function! s:get_firstline(lnum, total, height) abort
                              if a:lnum <= a:height
                                return 1
                              endif
                              return min([a:total - a:height + 1, a:lnum  - (a:height*2/3)])
                            endfunction
                            
    1              0.000001 function! s:on_pum_change(move) abort
                              if coc#float#valid(s:pum_winid)
                                if s:virtual_text
                                  call s:insert_virtual_text()
                                endif
                                let ev = extend(coc#pum#info(), {'move': a:move ? v:true : v:false})
                                call coc#rpc#notify('CocAutocmd', ['MenuPopupChanged', ev, win_screenpos(winnr())[0] + winline() - 2])
                              endif
                            endfunction
                            
    1              0.000000 function! s:index_to_lnum(index) abort
                              if s:reversed
                                if a:index <= 0
                                  return s:pum_size
                                endif
                                return s:pum_size - a:index
                              endif
                              return max([1, a:index + 1])
                            endfunction
                            
    1              0.000001 function! s:get_pum_dimension(lines, col, config) abort
                              let linecount = len(a:lines)
                              let [lineIdx, colIdx] = coc#cursor#screen_pos()
                              let bh = empty(get(a:config, 'border', [])) ? 0 : 2
                              let columns = &columns
                              let pumwidth = max([15, exists('&pumwidth') ? &pumwidth : 0])
                              let width = min([columns, max([pumwidth, a:config['width']])])
                              let vh = &lines - &cmdheight - 1 - !empty(&tabline)
                              if vh <= 0
                                return v:null
                              endif
                              let pumheight = empty(&pumheight) ? vh : &pumheight
                              let showTop = getwinvar(s:pum_winid, 'above', v:null)
                              if type(showTop) != v:t_number
                                if vh - lineIdx - bh - 1 < min([pumheight, linecount]) && vh - lineIdx < min([10, vh/2])
                                  let showTop = 1
                                else
                                  let showTop = 0
                                endif
                              endif
                              let height = showTop ? min([lineIdx - bh - !empty(&tabline), linecount, pumheight]) : min([vh - lineIdx - bh - 1, linecount, pumheight])
                              if height <= 0
                                return v:null
                              endif
                              " should use strdiplaywidth here
                              let text = strpart(getline('.'), a:col, col('.') - 1 - a:col)
                              let col = - strdisplaywidth(text, a:col) - 1
                              let row = showTop ? - height : 1
                              let delta = colIdx + col
                              if width > pumwidth && delta + width > columns
                                let width = max([columns - delta, pumwidth])
                              endif
                              if delta < 0
                                let col = col - delta
                              elseif delta + width > columns
                                let col = max([-colIdx, col - (delta + width - columns)])
                              endif
                              return {
                                    \ 'row': row,
                                    \ 'col': col,
                                    \ 'width': width,
                                    \ 'height': height
                                    \ }
                            endfunction
                            
                            " can't use coc#dialog#set_cursor on vim8, don't know why
    1              0.000001 function! s:set_cursor(winid, line) abort
                              if s:is_vim
                                let pos = popup_getpos(a:winid)
                                let core_height = pos['core_height']
                                let lastline = pos['firstline'] + core_height - 1
                                if a:line > lastline
                                  call popup_setoptions(a:winid, {
                                        \ 'firstline': pos['firstline'] + a:line - lastline,
                                        \ })
                                elseif a:line < pos['firstline']
                                  if s:reversed
                                    call popup_setoptions(a:winid, {
                                          \ 'firstline': a:line == 0 ? s:pum_size - core_height + 1 : a:line - core_height + 1,
                                          \ })
                                  else
                                    call popup_setoptions(a:winid, {
                                          \ 'firstline': max([1, a:line]),
                                          \ })
                                  endif
                                endif
                              endif
                              call s:select_line(a:winid, a:line)
                            endfunction
                            
    1              0.000001 function! s:select_line(winid, line) abort
                              let s:pum_index = s:reversed ? (a:line == 0 ? -1 : s:pum_size - a:line) : a:line - 1
                              let lnum = s:reversed ? (a:line == 0 ? s:pum_size : a:line) : max([1, a:line])
                              if s:is_vim
                                call coc#compat#execute(a:winid, 'exe '.lnum)
                              else
                                call nvim_win_set_cursor(a:winid, [lnum, 0])
                              endif
                              call coc#dialog#place_sign(s:pum_bufnr, a:line == 0 ? 0 : lnum)
                            endfunction
                            
    1              0.000001 function! s:insert_virtual_text() abort
                              let bufnr = bufnr('%')
                              if !s:virtual_text || s:pum_index < 0
                                call s:clear_virtual_text()
                              else
                                " Check if could create
                                let insert = ''
                                let line = line('.') - 1
                                let words = getwinvar(s:pum_winid, 'words', [])
                                let word = get(words, s:pum_index, '')
                                let input = strpart(getline('.'), s:start_col, col('.') - 1 - s:start_col)
                                if strlen(word) > strlen(input) && strcharpart(word, 0, strchars(input)) ==# input
                                  let insert = strcharpart(word, strchars(input))
                                endif
                                if s:is_vim
                                  if s:prop_id != 0
                                    call prop_remove({'id': s:prop_id}, line + 1, line + 1)
                                  endif
                                  if !empty(insert)
                                    let s:prop_id = prop_add(line + 1, col('.'), {
                                        \ 'text': insert,
                                        \ 'type': 'CocPumVirtualText'
                                        \ })
                                  endif
                                else
                                  call nvim_buf_clear_namespace(bufnr, s:virtual_text_ns, line, line + 1)
                                  if !empty(insert)
                                    let opts = {
                                        \ 'hl_mode': 'combine',
                                        \ 'virt_text': [[insert, 'CocPumVirtualText']],
                                        \ 'virt_text_pos': 'overlay',
                                        \ 'virt_text_win_col': virtcol('.') - 1,
                                        \ }
                                    call nvim_buf_set_extmark(bufnr, s:virtual_text_ns, line, col('.') - 1, opts)
                                  endif
                                endif
                              endif
                            endfunction
                            
    1              0.000001 function! s:clear_virtual_text() abort
                              if s:virtual_text_support
                                if s:is_vim
                                  if s:prop_id != 0
                                    call prop_remove({'id': s:prop_id})
                                  endif
                                else
                                  call nvim_buf_clear_namespace(bufnr('%'), s:virtual_text_ns, 0, -1)
                                endif
                              endif
                            endfunction

SCRIPT  /home/pyericz/.vimgo/plugged/coc.nvim/autoload/coc/dict.vim
Sourced 1 time
Total time:   0.000016
 Self time:   0.000016

count  total (s)   self (s)
    1              0.000002 scriptencoding utf-8
                            
    1              0.000001 function! coc#dict#equal(one, two) abort
                              for key in keys(a:one)
                                if a:one[key] != a:two[key]
                                  return 0
                                endif
                              endfor
                              return 1
                            endfunction
                            
                            " Return new dict with keys removed
    1              0.000001 function! coc#dict#omit(dict, keys) abort
                              let res = {}
                              for key in keys(a:dict)
                                if index(a:keys, key) == -1
                                  let res[key] = a:dict[key]
                                endif
                              endfor
                              return res
                            endfunction
                            
                            " Return new dict with keys only
    1              0.000001 function! coc#dict#pick(dict, keys) abort
                              let res = {}
                              for key in keys(a:dict)
                                if index(a:keys, key) != -1
                                  let res[key] = a:dict[key]
                                endif
                              endfor
                              return res
                            endfunction

SCRIPT  /home/pyericz/.vimgo/plugged/coc.nvim/autoload/coc/dialog.vim
Sourced 1 time
Total time:   0.000199
 Self time:   0.000199

count  total (s)   self (s)
    1              0.000001 scriptencoding utf-8
    1              0.000003 let s:is_vim = !has('nvim')
    1              0.000003 let s:root = expand('<sfile>:h:h:h')
    1              0.000001 let s:prompt_win_bufnr = 0
    1              0.000001 let s:list_win_bufnr = 0
    1              0.000002 let s:prompt_win_width = get(g:, 'coc_prompt_win_width', 32)
    1              0.000003 let s:frames = ['  ', ' ', '', ' ', '  ', '   ']
    1              0.000001 let s:sign_group = 'PopUpCocDialog'
    1              0.000001 let s:detail_bufnr = 0
                            
                            " Float window aside pum
    1              0.000002 function! coc#dialog#create_pum_float(lines, config) abort
                              let winid = coc#float#get_float_by_kind('pumdetail')
                              if empty(a:lines) || !coc#pum#visible()
                                if winid
                                  call coc#float#close(winid)
                                endif
                                return
                              endif
                              let pumbounding = coc#pum#info()
                              let border = get(a:config, 'border', [])
                              let pw = pumbounding['width'] + (pumbounding['border'] ? 0 : get(pumbounding, 'scrollbar', 0))
                              let rp = &columns - pumbounding['col'] - pw
                              let showRight = pumbounding['col'] > rp ? 0 : 1
                              let maxWidth = showRight ? coc#math#min(rp - 1, a:config['maxWidth']) : coc#math#min(pumbounding['col'] - 1, a:config['maxWidth'])
                              let bh = get(border, 0 ,0) + get(border, 2, 0)
                              let maxHeight = &lines - pumbounding['row'] - &cmdheight - 1 - bh
                              if maxWidth <= 2 || maxHeight < 1
                                return v:null
                              endif
                              let width = 0
                              for line in a:lines
                                let dw = max([1, strdisplaywidth(line)])
                                let width = max([width, dw + 2])
                              endfor
                              let width = float2nr(coc#math#min(maxWidth, width))
                              let ch = coc#string#content_height(a:lines, width - 2)
                              let height = float2nr(coc#math#min(maxHeight, ch))
                              let lines = map(a:lines, {_, s -> s =~# '^' ? repeat('', width - 2 + (s:is_vim && ch > height ? -1 : 0)) : s})
                              let opts = {
                                    \ 'lines': lines,
                                    \ 'highlights': get(a:config, 'highlights', []),
                                    \ 'relative': 'editor',
                                    \ 'col': showRight ? pumbounding['col'] + pw : pumbounding['col'] - width,
                                    \ 'row': pumbounding['row'],
                                    \ 'height': height,
                                    \ 'width': width - 2 + (s:is_vim && ch > height ? -1 : 0),
                                    \ 'scrollinside': showRight ? 0 : 1,
                                    \ 'codes': get(a:config, 'codes', []),
                                    \ }
                              for key in ['border', 'highlight', 'borderhighlight', 'winblend', 'focusable', 'shadow', 'rounded']
                                if has_key(a:config, key)
                                  let opts[key] = a:config[key]
                                endif
                              endfor
                              call s:close_auto_hide_wins(winid)
                              let result = coc#float#create_float_win(winid, s:detail_bufnr, opts)
                              if empty(result)
                                return
                              endif
                              let s:detail_bufnr = result[1]
                              call setwinvar(result[0], 'kind', 'pumdetail')
                              if !s:is_vim
                                call coc#float#nvim_scrollbar(result[0])
                              endif
                            endfunction
                            
                            " Float window below/above cursor
    1              0.000002 function! coc#dialog#create_cursor_float(winid, bufnr, lines, config) abort
                              if coc#prompt#activated()
                                return v:null
                              endif
                              let pumAlignTop = get(a:config, 'pumAlignTop', 0)
                              let modes = get(a:config, 'modes', ['n', 'i', 'ic', 's'])
                              let mode = mode()
                              let currbuf = bufnr('%')
                              let pos = [line('.'), col('.')]
                              if index(modes, mode) == -1
                                return v:null
                              endif
                              if !s:is_vim && !has('nvim-0.5.0') && mode ==# 'i'
                                " helps to fix undo issue, don't know why.
                                call feedkeys("\<C-g>u", 'n')
                              endif
                              if mode ==# 's' && has('patch-8.2.4969') && !has('patch-8.2.4996')
                                echohl WarningMsg | echon 'Popup not created to avoid issue #10466 on vim >= 8.2.4969' | echohl None
                                return v:null
                              endif
                              let dimension = coc#dialog#get_config_cursor(a:lines, a:config)
                              if empty(dimension)
                                return v:null
                              endif
                              if coc#pum#visible() && ((pumAlignTop && dimension['row'] <0)|| (!pumAlignTop && dimension['row'] > 0))
                                return v:null
                              endif
                              let width = dimension['width']
                              let lines = map(a:lines, {_, s -> s =~# '^' ? repeat('', width) : s})
                              let config = extend(extend({'lines': lines, 'relative': 'cursor'}, a:config), dimension)
                              call s:close_auto_hide_wins(a:winid)
                              let res = coc#float#create_float_win(a:winid, a:bufnr, config)
                              if empty(res)
                                return v:null
                              endif
                              let alignTop = dimension['row'] < 0
                              let winid = res[0]
                              let bufnr = res[1]
                              redraw
                              if has('nvim')
                                call coc#float#nvim_scrollbar(winid)
                              endif
                              return [currbuf, pos, winid, bufnr, alignTop]
                            endfunction
                            
                            " Create float window for input
    1              0.000002 function! coc#dialog#create_prompt_win(title, default, opts) abort
                              call s:close_auto_hide_wins()
                              let bufnr = has('nvim') ? s:prompt_win_bufnr : 0
                              if s:is_vim
                                execute 'hi link CocPopupTerminal '.get(a:opts, 'highlight', 'CocFloating')
                                let node =  expand(get(g:, 'coc_node_path', 'node'))
                                let bufnr = term_start([node, s:root . '/bin/prompt.js', a:default], {
                                      \ 'term_rows': 1,
                                      \ 'term_highlight': 'CocPopupTerminal',
                                      \ 'hidden': 1,
                                      \ 'term_finish': 'close'
                                      \ })
                                call term_setapi(bufnr, 'Coc')
                                call setbufvar(bufnr, 'current', type(a:default) == v:t_string ? a:default : '')
                              endif
                              let config = s:get_prompt_dimension(a:title, a:default, a:opts)
                              let res = coc#float#create_float_win(0, bufnr, extend(config, {
                                    \ 'style': 'minimal',
                                    \ 'border': get(a:opts, 'border', [1,1,1,1]),
                                    \ 'rounded': get(a:opts, 'rounded', 1),
                                    \ 'prompt': 1,
                                    \ 'title': a:title,
                                    \ 'lines': s:is_vim ? v:null : [a:default],
                                    \ 'highlight': get(a:opts, 'highlight', 'CocFloating'),
                                    \ 'borderhighlight': [get(a:opts, 'borderhighlight', 'CocFloating')],
                                    \ }))
                              if empty(res)
                                return
                              endif
                              let winid = res[0]
                              let bufnr = res[1]
                              if has('nvim')
                                let s:prompt_win_bufnr = res[1]
                                call sign_unplace(s:sign_group, { 'buffer': s:prompt_win_bufnr })
                                call nvim_set_current_win(winid)
                                inoremap <buffer> <C-a> <Home>
                                inoremap <buffer><expr><C-e> pumvisible() ? "\<C-e>" : "\<End>"
                                exe 'imap <silent><nowait><buffer> <esc> <esc><esc>'
                                exe 'nnoremap <silent><buffer> <esc> :call coc#float#close('.winid.')<CR>'
                                exe 'inoremap <silent><expr><nowait><buffer> <cr> "\<C-r>=coc#dialog#prompt_insert(getline(''.''))\<cr>\<esc>"'
                                if get(a:opts, 'list', 0)
                                  for key in ['<C-j>', '<C-k>', '<C-n>', '<C-p>', '<up>', '<down>', '<C-f>', '<C-b>', '<C-space>']
                                    " Can't use < in remap
                                    let escaped = key ==# '<C-space>' ? "C-@" : strcharpart(key, 1, strchars(key) - 2)
                                    exe 'inoremap <nowait><buffer> '.key.' <Cmd>call coc#rpc#notify("PromptKeyPress", ['.bufnr.', "'.escaped.'"])<CR>'
                                  endfor
                                endif
                                call feedkeys('A', 'in')
                              endif
                              call coc#util#do_autocmd('CocOpenFloatPrompt')
                              if s:is_vim
                                let pos = popup_getpos(winid)
                                " width height row col
                                let dimension = [pos['width'], pos['height'], pos['line'] - 1, pos['col'] - 1]
                              else
                                let id = coc#float#get_related(winid, 'border')
                                if !has('nvim-0.6.0')
                                  redraw
                                endif
                                let pos = nvim_win_get_position(id)
                                let dimension = [nvim_win_get_width(id), nvim_win_get_height(id), pos[0], pos[1]]
                              endif
                              return [bufnr, winid, dimension]
                            endfunction
                            
                            " Create list window under target window
    1              0.000001 function! coc#dialog#create_list(target, dimension, opts) abort
                              let maxHeight = get(a:opts, 'maxHeight', 10)
                              let height = max([1, len(get(a:opts, 'lines', []))])
                              let height = min([maxHeight, height, &lines - &cmdheight - 1 - a:dimension['row'] + a:dimension['height']])
                              let chars = get(a:opts, 'rounded', 1) ? ['', ''] : ['', '']
                              let config = extend(copy(a:opts), {
                                  \ 'relative': 'editor',
                                  \ 'row': a:dimension['row'] + a:dimension['height'],
                                  \ 'col': a:dimension['col'],
                                  \ 'width': a:dimension['width'] - 2,
                                  \ 'height': height,
                                  \ 'border': [1, 1, 1, 1],
                                  \ 'scrollinside': 1,
                                  \ 'borderchars': extend(['', '', '', '', '', ''], chars)
                                  \ })
                              let bufnr = 0
                              let result = coc#float#create_float_win(0, s:list_win_bufnr, config)
                              if empty(result)
                                return
                              endif
                              let winid = result[0]
                              call coc#float#add_related(winid, a:target)
                              call setwinvar(winid, 'auto_height', get(a:opts, 'autoHeight', 1))
                              call setwinvar(winid, 'max_height', maxHeight)
                              call setwinvar(winid, 'target_winid', a:target)
                              call setwinvar(winid, 'kind', 'list')
                              call coc#dialog#check_scroll_vim(a:target)
                              return result
                            endfunction
                            
                            " Create menu picker for pick single item
    1              0.000001 function! coc#dialog#create_menu(lines, config) abort
                              call s:close_auto_hide_wins()
                              let highlight = get(a:config, 'highlight', 'CocFloating')
                              let borderhighlight = get(a:config, 'borderhighlight', [highlight])
                              let relative = get(a:config, 'relative', 'cursor')
                              let lines = copy(a:lines)
                              let content = get(a:config, 'content', '')
                              let maxWidth = get(a:config, 'maxWidth', 80)
                              let highlights = get(a:config, 'highlights', [])
                              let contentCount = 0
                              if !empty(content)
                                let contentLines = coc#string#reflow(split(content, '\r\?\n'), maxWidth)
                                let contentCount = len(contentLines)
                                let lines = extend(contentLines, lines)
                                if !empty(highlights)
                                  for item in highlights
                                    let item['lnum'] = item['lnum'] + contentCount
                                  endfor
                                endif
                              endif
                              let opts = {
                                \ 'lines': lines,
                                \ 'highlight': highlight,
                                \ 'title': get(a:config, 'title', ''),
                                \ 'borderhighlight': borderhighlight,
                                \ 'maxWidth': maxWidth,
                                \ 'maxHeight': get(a:config, 'maxHeight', 80),
                                \ 'rounded': get(a:config, 'rounded', 0),
                                \ 'border': [1, 1, 1, 1],
                                \ 'highlights': highlights,
                                \ 'relative': relative,
                                \ }
                              if relative ==# 'editor'
                                let dimension = coc#dialog#get_config_editor(lines, opts)
                              else
                                let dimension = coc#dialog#get_config_cursor(lines, opts)
                              endif
                              call extend(opts, dimension)
                              let ids = coc#float#create_float_win(0, s:prompt_win_bufnr, opts)
                              if empty(ids)
                                return
                              endif
                              let s:prompt_win_bufnr = ids[1]
                              call coc#dialog#set_cursor(ids[0], ids[1], contentCount + 1)
                              redraw
                              if has('nvim')
                                call coc#float#nvim_scrollbar(ids[0])
                              endif
                              return [ids[0], ids[1], contentCount]
                            endfunction
                            
                            " Create dialog at center of screen
    1              0.000001 function! coc#dialog#create_dialog(lines, config) abort
                              call s:close_auto_hide_wins()
                              " dialog always have borders
                              let title = get(a:config, 'title', '')
                              let buttons = get(a:config, 'buttons', [])
                              let highlight = get(a:config, 'highlight', 'CocFloating')
                              let borderhighlight = get(a:config, 'borderhighlight', [highlight])
                              let opts = {
                                \ 'title': title,
                                \ 'rounded': get(a:config, 'rounded', 0),
                                \ 'relative': 'editor',
                                \ 'border': [1,1,1,1],
                                \ 'close': get(a:config, 'close', 1),
                                \ 'highlight': highlight,
                                \ 'highlights': get(a:config, 'highlights', []),
                                \ 'buttons': buttons,
                                \ 'borderhighlight': borderhighlight,
                                \ 'getchar': get(a:config, 'getchar', 0)
                                \ }
                              call extend(opts, coc#dialog#get_config_editor(a:lines, a:config))
                              let bufnr = coc#float#create_buf(0, a:lines)
                              let res =  coc#float#create_float_win(0, bufnr, opts)
                              if empty(res)
                                return
                              endif
                              if get(a:config, 'cursorline', 0)
                                call coc#dialog#place_sign(bufnr, 1)
                              endif
                              if has('nvim')
                                redraw
                                call coc#float#nvim_scrollbar(res[0])
                              endif
                              return res
                            endfunction
                            
    1              0.000001 function! coc#dialog#prompt_confirm(title, cb) abort
                              call s:close_auto_hide_wins()
                              if s:is_vim && exists('*popup_dialog')
                                try
                                  call popup_dialog(a:title. ' (y/n)?', {
                                    \ 'highlight': 'Normal',
                                    \ 'filter': 'popup_filter_yesno',
                                    \ 'callback': {id, res -> a:cb(v:null, res)},
                                    \ 'borderchars': get(g:, 'coc_borderchars', ['', '', '', '', '', '', '', '']),
                                    \ 'borderhighlight': ['MoreMsg']
                                    \ })
                                catch /.*/
                                  call a:cb(v:exception)
                                endtry
                                return
                              endif
                              let text = ' '. a:title . ' (y/n)? '
                              let maxWidth = coc#math#min(78, &columns - 2)
                              let width = coc#math#min(maxWidth, strdisplaywidth(text))
                              let maxHeight = &lines - &cmdheight - 1
                              let height = coc#math#min(maxHeight, float2nr(ceil(str2float(string(strdisplaywidth(text)))/width)))
                              let arr =  coc#float#create_float_win(0, s:prompt_win_bufnr, {
                                    \ 'col': &columns/2 - width/2 - 1,
                                    \ 'row': maxHeight/2 - height/2 - 1,
                                    \ 'width': width,
                                    \ 'height': height,
                                    \ 'border': [1,1,1,1],
                                    \ 'focusable': v:false,
                                    \ 'relative': 'editor',
                                    \ 'highlight': 'Normal',
                                    \ 'borderhighlight': 'MoreMsg',
                                    \ 'style': 'minimal',
                                    \ 'lines': [text],
                                    \ })
                              if empty(arr)
                                call a:cb('Window create failed!')
                                return
                              endif
                              let winid = arr[0]
                              let s:prompt_win_bufnr = arr[1]
                              call sign_unplace(s:sign_group, { 'buffer': s:prompt_win_bufnr })
                              let res = 0
                              redraw
                              " same result as vim
                              while 1
                                let key = nr2char(getchar())
                                if key == "\<C-c>"
                                  let res = -1
                                  break
                                elseif key == "\<esc>" || key == 'n' || key == 'N'
                                  let res = 0
                                  break
                                elseif key == 'y' || key == 'Y'
                                  let res = 1
                                  break
                                endif
                              endw
                              call coc#float#close(winid)
                              call a:cb(v:null, res)
                            endfunction
                            
    1              0.000001 function! coc#dialog#get_config_editor(lines, config) abort
                              let title = get(a:config, 'title', '')
                              let maxheight = min([get(a:config, 'maxHeight', 78), &lines - &cmdheight - 6])
                              let maxwidth = min([get(a:config, 'maxWidth', 78), &columns - 2])
                              let buttons = get(a:config, 'buttons', [])
                              let minwidth = s:min_btns_width(buttons)
                              if maxheight <= 0 || maxwidth <= 0 || minwidth > maxwidth
                                throw 'Not enough spaces for float window'
                              endif
                              let ch = 0
                              let width = min([strdisplaywidth(title) + 1, maxwidth])
                              for line in a:lines
                                let dw = max([1, strdisplaywidth(line)])
                                if dw < maxwidth && dw > width
                                  let width = dw
                                elseif dw >= maxwidth
                                  let width = maxwidth
                                endif
                                let ch += float2nr(ceil(str2float(string(dw))/maxwidth))
                              endfor
                              let width = max([minwidth, width])
                              let height = coc#math#min(ch ,maxheight)
                              return {
                                  \ 'row': &lines/2 - (height + 4)/2,
                                  \ 'col': &columns/2 - (width + 2)/2,
                                  \ 'width': width,
                                  \ 'height': height,
                                  \ }
                            endfunction
                            
    1              0.000001 function! coc#dialog#prompt_insert(text) abort
                              call coc#rpc#notify('PromptInsert', [a:text, bufnr('%')])
                              return ''
                            endfunction
                            
                            " Dimension of window with lines relative to cursor
                            " Width & height excludes border & padding
    1              0.000001 function! coc#dialog#get_config_cursor(lines, config) abort
                              let preferTop = get(a:config, 'preferTop', 0)
                              let title = get(a:config, 'title', '')
                              let border = get(a:config, 'border', [])
                              if empty(border) && len(title)
                                let border = [1, 1, 1, 1]
                              endif
                              let bh = get(border, 0, 0) + get(border, 2, 0)
                              let vh = &lines - &cmdheight - 1
                              if vh <= 0
                                return v:null
                              endif
                              let maxWidth = coc#math#min(get(a:config, 'maxWidth', &columns - 1), &columns - 1)
                              if maxWidth < 3
                                return v:null
                              endif
                              let maxHeight = coc#math#min(get(a:config, 'maxHeight', vh), vh)
                              let width = coc#math#min(40, strdisplaywidth(title)) + 3
                              for line in a:lines
                                let dw = max([1, strdisplaywidth(line)])
                                let width = max([width, dw + 2])
                              endfor
                              let width = coc#math#min(maxWidth, width)
                              let ch = coc#string#content_height(a:lines, width - 2)
                              let [lineIdx, colIdx] = coc#cursor#screen_pos()
                              " How much we should move left
                              let offsetX = coc#math#min(get(a:config, 'offsetX', 0), colIdx)
                              let showTop = 0
                              let hb = vh - lineIdx -1
                              if lineIdx > bh + 2 && (preferTop || (lineIdx > hb && hb < ch + bh))
                                let showTop = 1
                              endif
                              let height = coc#math#min(maxHeight, ch + bh, showTop ? lineIdx - 1 : hb)
                              if height <= bh
                                return v:null
                              endif
                              let col = - max([offsetX, colIdx - (&columns - 1 - width)])
                              let row = showTop ? - height + bh : 1
                              return {
                                    \ 'row': row,
                                    \ 'col': col,
                                    \ 'width': width - 2,
                                    \ 'height': height - bh
                                    \ }
                            endfunction
                            
    1              0.000001 function! coc#dialog#change_border_hl(winid, hlgroup) abort
                              if !hlexists(a:hlgroup)
                                return
                              endif
                              if s:is_vim
                                if coc#float#valid(a:winid)
                                  call popup_setoptions(a:winid, {'borderhighlight': repeat([a:hlgroup], 4)})
                                  redraw
                                endif
                              else
                                let winid = coc#float#get_related(a:winid, 'border')
                                if winid > 0
                                  call setwinvar(winid, '&winhl', 'Normal:'.a:hlgroup)
                                endif
                              endif
                            endfunction
                            
    1              0.000001 function! coc#dialog#change_title(winid, title) abort
                              if s:is_vim
                                if coc#float#valid(a:winid)
                                  call popup_setoptions(a:winid, {'title': a:title})
                                  redraw
                                endif
                              else
                                let winid = coc#float#get_related(a:winid, 'border')
                                if winid > 0
                                  let bufnr = winbufnr(winid)
                                  let line = getbufline(bufnr, 1)[0]
                                  let top = strcharpart(line, 0, 1)
                                        \.repeat('', strchars(line) - 2)
                                        \.strcharpart(line, strchars(line) - 1, 1)
                                  if !empty(a:title)
                                    let top = coc#string#compose(top, 1, a:title.' ')
                                  endif
                                  call nvim_buf_set_lines(bufnr, 0, 1, v:false, [top])
                                endif
                              endif
                            endfunction
                            
    1              0.000000 function! coc#dialog#change_loading(winid, loading) abort
                              if coc#float#valid(a:winid)
                                let winid = coc#float#get_related(a:winid, 'loading')
                                if !a:loading && winid > 0
                                  call coc#float#close(winid)
                                endif
                                if a:loading && winid == 0
                                  let bufnr = s:create_loading_buf()
                                  if s:is_vim
                                    let pos = popup_getpos(a:winid)
                                    let winid = popup_create(bufnr, {
                                        \ 'line': pos['line'] + 1,
                                        \ 'col': pos['col'] + pos['width'] - 4,
                                        \ 'maxheight': 1,
                                        \ 'maxwidth': 3,
                                        \ 'zindex': 999,
                                        \ 'highlight': get(popup_getoptions(a:winid), 'highlight', 'CocFloating')
                                        \ })
                                  else
                                    let pos = nvim_win_get_position(a:winid)
                                    let width = nvim_win_get_width(a:winid)
                                    let opts = {
                                        \ 'relative': 'editor',
                                        \ 'row': pos[0],
                                        \ 'col': pos[1] + width - 3,
                                        \ 'focusable': v:false,
                                        \ 'width': 3,
                                        \ 'height': 1,
                                        \ 'style': 'minimal',
                                        \ }
                                    if has('nvim-0.5.1')
                                      let opts['zindex'] = 900
                                    endif
                                    let winid = nvim_open_win(bufnr, v:false, opts)
                                    call setwinvar(winid, '&winhl', getwinvar(a:winid, '&winhl'))
                                  endif
                                  call setwinvar(winid, 'kind', 'loading')
                                  call setbufvar(bufnr, 'target_winid', a:winid)
                                  call setbufvar(bufnr, 'popup', winid)
                                  call coc#float#add_related(winid, a:winid)
                                endif
                              endif
                            endfunction
                            
                            " Update list with new lines and highlights
    1              0.000001 function! coc#dialog#update_list(winid, bufnr, lines, highlights) abort
                              if coc#window#tabnr(a:winid) == tabpagenr()
                                if getwinvar(a:winid, 'auto_height', 0)
                                  let row = coc#float#get_row(a:winid)
                                  " core height
                                  let height = max([1, len(copy(a:lines))])
                                  let height = min([getwinvar(a:winid, 'max_height', 10), height, &lines - &cmdheight - 1 - row])
                                  let curr = s:is_vim ? popup_getpos(a:winid)['core_height'] : nvim_win_get_height(a:winid)
                                  let delta = height - curr
                                  if delta != 0
                                    call coc#float#change_height(a:winid, delta)
                                  endif
                                endif
                                call coc#compat#buf_set_lines(a:bufnr, 0, -1, a:lines)
                                call coc#highlight#add_highlights(a:winid, [], a:highlights)
                                if s:is_vim
                                  let target = getwinvar(a:winid, 'target_winid', -1)
                                  if target != -1
                                    call coc#dialog#check_scroll_vim(target)
                                  endif
                                  call win_execute(a:winid, 'exe 1')
                                endif
                              endif
                            endfunction
                            
                            " Fix width of prompt window same as list window on scrollbar change
    1              0.000001 function! coc#dialog#check_scroll_vim(winid) abort
                              if s:is_vim && coc#float#valid(a:winid)
                                let winid = coc#float#get_related(a:winid, 'list')
                                if winid
                                  redraw
                                  let pos = popup_getpos(winid)
                                  let width = pos['width'] + (pos['scrollbar'] ? 1 : 0)
                                  if width != popup_getpos(a:winid)['width']
                                    call popup_move(a:winid, {
                                        \ 'minwidth': width - 2,
                                        \ 'maxwidth': width - 2,
                                        \ })
                                  endif
                                endif
                              endif
                            endfunction
                            
    1              0.000001 function! coc#dialog#set_cursor(winid, bufnr, line) abort
                              if s:is_vim
                                call coc#compat#execute(a:winid, 'exe '.a:line, 'silent!')
                                call popup_setoptions(a:winid, {'cursorline' : 1})
                                call popup_setoptions(a:winid, {'cursorline' : 0})
                              else
                                call nvim_win_set_cursor(a:winid, [a:line, 0])
                              endif
                              call coc#dialog#place_sign(a:bufnr, a:line)
                            endfunction
                            
    1              0.000001 function! coc#dialog#place_sign(bufnr, line) abort
                              call sign_unplace(s:sign_group, { 'buffer': a:bufnr })
                              if a:line > 0
                                call sign_place(6, s:sign_group, 'CocCurrentLine', a:bufnr, {'lnum': a:line})
                              endif
                            endfunction
                            
                            " Could be center(with optional marginTop) or cursor
    1              0.000002 function! s:get_prompt_dimension(title, default, opts) abort
                              let relative = get(a:opts, 'position', 'cursor') ==# 'cursor' ? 'cursor' : 'editor'
                              let curr = win_screenpos(winnr())[1] + wincol() - 2
                              let minWidth = get(a:opts, 'minWidth', s:prompt_win_width)
                              let width = min([max([strwidth(a:default) + 2, strwidth(a:title) + 2, minWidth]), &columns - 2])
                              if get(a:opts, 'maxWidth', 0)
                                let width = min([width, a:opts['maxWidth']])
                              endif
                              if relative ==# 'cursor'
                                let [lineIdx, colIdx] = coc#cursor#screen_pos()
                                if width == &columns - 2
                                  let col = 0 - curr
                                else
                                  let col = curr + width <= &columns - 2 ? 0 : curr + width - &columns + 2
                                endif
                                let config = {
                                    \ 'row': lineIdx == 0 ? 1 : 0,
                                    \ 'col': colIdx == 0 ? 0 : col - 1,
                                    \ }
                              else
                                let marginTop = get(a:opts, 'marginTop', v:null)
                                if marginTop is v:null
                                  let row = (&lines - &cmdheight - 2) / 2
                                else
                                  let row = marginTop < 2 ? 1 : min([marginTop, &columns - &cmdheight])
                                endif
                                let config = {
                                      \ 'col': float2nr((&columns - width) / 2),
                                      \ 'row': row - s:is_vim,
                                      \ }
                              endif
                              return extend(config, {'relative': relative, 'width': width, 'height': 1})
                            endfunction
                            
    1              0.000001 function! s:min_btns_width(buttons) abort
                              if empty(a:buttons)
                                return 0
                              endif
                              let minwidth = len(a:buttons)*3 - 1
                              for txt in a:buttons
                                let minwidth = minwidth + strdisplaywidth(txt)
                              endfor
                              return minwidth
                            endfunction
                            
                            " Close windows that should auto hide
    1              0.000001 function! s:close_auto_hide_wins(...) abort
                              let winids = coc#float#get_float_win_list()
                              let except = get(a:, 1, 0)
                              for id in winids
                                if except && id == except
                                  continue
                                endif
                                if coc#window#get_var(id, 'autohide', 0)
                                  call coc#float#close(id)
                                endif
                              endfor
                            endfunction
                            
    1              0.000001 function! s:create_loading_buf() abort
                              let bufnr = coc#float#create_buf(0)
                              call s:change_loading_buf(bufnr, 0)
                              return bufnr
                            endfunction
                            
    1              0.000000 function! s:change_loading_buf(bufnr, idx) abort
                              if bufloaded(a:bufnr)
                                let target = getbufvar(a:bufnr, 'target_winid', v:null)
                                if !empty(target) && !coc#float#valid(target)
                                  call coc#float#close(getbufvar(a:bufnr, 'popup'))
                                  return
                                endif
                                let line = get(s:frames, a:idx, '   ')
                                call setbufline(a:bufnr, 1, line)
                                call coc#highlight#add_highlight(a:bufnr, -1, 'CocNotificationProgress', 0, 0, -1)
                                let idx = a:idx == len(s:frames) - 1 ? 0 : a:idx + 1
                                call timer_start(100, { -> s:change_loading_buf(a:bufnr, idx)})
                              endif
                            endfunction

SCRIPT  /home/pyericz/.vimgo/plugged/coc.nvim/autoload/coc/math.vim
Sourced 1 time
Total time:   0.000016
 Self time:   0.000016

count  total (s)   self (s)
                            
                            " support for float values
    1              0.000004 function! coc#math#min(first, ...) abort
                              let val = a:first
                              for i in range(0, len(a:000) - 1)
                                if a:000[i] < val
                                  let val = a:000[i]
                                endif
                              endfor
                              return val
                            endfunction

FUNCTION  coc#client#get_channel()
    Defined: ~/.vimgo/plugged/coc.nvim/autoload/coc/client.vim:189
Called 170 times
Total time:   0.000585
 Self time:   0.000585

count  total (s)   self (s)
  170              0.000167   if s:is_vim
  170              0.000296     return a:client['channel']
                              endif
                              return a:client['chan_id']

FUNCTION  296()
    Defined: ~/.vimgo/plugged/coc.nvim/autoload/coc/api.vim:119
Called 109 times
Total time:   0.179292
 Self time:   0.000624

count  total (s)   self (s)
  109   0.179247   0.000579   return call(a:method, a:args)

FUNCTION  AutoPairsSpace()
    Defined: ~/.vimgo/plugged/auto-pairs/plugin/auto-pairs.vim:423
Called 4 times
Total time:   0.000663
 Self time:   0.000489

count  total (s)   self (s)
    4              0.000010   if !b:autopairs_enabled
                                return "\<SPACE>"
    4              0.000004   end
                            
    4   0.000201   0.000027   let [before, after, ig] = s:getline()
                            
   40              0.000083   for [open, close, opt] in b:AutoPairsList
   36              0.000027     if close == ''
                                  continue
   36              0.000011     end
   36              0.000104     if before =~ '\V'.open.'\v$' && after =~ '^\V'.close
                                  if close =~ '\v^[''"`]$'
                                    return "\<SPACE>"
                                  else
                                    return "\<SPACE>\<SPACE>".s:Left
                                  end
   36              0.000012     end
   40              0.000024   endfor
    4              0.000008   return "\<SPACE>"

FUNCTION  <SNR>227_tabline_evaluated_length()
    Defined: ~/.vimgo/plugged/vim-airline/autoload/airline/extensions/tabline/builder.vim:223
Called 5 times
Total time:   0.000286
 Self time:   0.000018

count  total (s)   self (s)
    5   0.000285   0.000017   return airline#util#strchars(s:evaluate_tabline(a:tabline))

FUNCTION  <SNR>176_group_not_done()
    Defined: ~/.vimgo/plugged/vim-airline/autoload/airline/highlighter.vim:32
Called 132 times
Total time:   0.000496
 Self time:   0.000496

count  total (s)   self (s)
  132              0.000175     if index(a:list, a:name) == -1
  108              0.000146       call add(a:list, a:name)
  108              0.000060       return 1
   24              0.000008     else
   24              0.000016       if &vbs
                                    echomsg printf("airline: group: %s already done, skipping", a:name)
   24              0.000010       endif
   24              0.000010       return 0
                                endif

FUNCTION  <SNR>76_notify()
    Defined: ~/.vimgo/plugged/coc.nvim/autoload/coc/client.vim:233
Called 170 times
Total time:   0.012148
 Self time:   0.011563

count  total (s)   self (s)
  170   0.001520   0.000935   let channel = coc#client#get_channel(self)
  170              0.000320   if empty(channel)
                                return ''
  170              0.000075   endif
  170              0.000157   try
  170              0.000132     if s:is_vim
  170              0.005310       call ch_sendraw(channel, json_encode([0, [a:method, a:args]])."\n")
                                else
                                  call call('rpcnotify', [channel, a:method] + a:args)
  170              0.000100     endif
                              catch /.*/
                                if v:exception =~# 'E475'
                                  if get(g:, 'coc_vim_leaving', 0)
                                    return
                                  endif
                                  echohl Error | echom '['.self.name.'] server connection lost' | echohl None
                                  let name = self.name
                                  call s:on_exit(name, 0)
                                  execute 'silent do User ConnectionLost'.toupper(name[0]).name[1:]
                                elseif v:exception =~# 'E12'
                                  " neovim's bug, ignore it
                                else
                                  echohl Error | echo 'Error on notify ('.a:method.'): '.v:exception | echohl None
                                endif
  170              0.000165   endtry

FUNCTION  <SNR>233_close_win()
    Defined: ~/.vimgo/plugged/coc.nvim/autoload/coc/float.vim:1131
Called 7 times
Total time:   0.001322
 Self time:   0.000131

count  total (s)   self (s)
    7              0.000005   if a:winid <= 0
                                return
    7              0.000002   endif
                              " vim not throw for none exists winid
    7              0.000005   if s:is_vim
    7   0.001250   0.000059     call popup_close(a:winid)
                              else
                                if nvim_win_is_valid(a:winid)
                                  if a:noautocmd
                                    noa call nvim_win_close(a:winid, 1)
                                  else
                                    call nvim_win_close(a:winid, 1)
                                  endif
                                endif
    7              0.000003   endif

FUNCTION  <SNR>195_can_diffoff()
    Defined: ~/.vimgo/plugged/vim-fugitive/autoload/fugitive.vim:6404
Called 7 times
Total time:   0.000026
 Self time:   0.000026

count  total (s)   self (s)
    7              0.000025   return getwinvar(bufwinnr(a:buf), '&diff') && !empty(getwinvar(bufwinnr(a:buf), 'fugitive_diff_restore'))

FUNCTION  <SNR>222_SetListsImpl()
    Defined: ~/.vimgo/plugged/ale/autoload/ale/list.vim:100
Called 1 time
Total time:   0.000134
 Self time:   0.000073

count  total (s)   self (s)
    1              0.000005     let l:title = expand('#' . a:buffer . ':p')
                            
    1              0.000001     if g:ale_set_quickfix
                                    let l:quickfix_list = ale#list#GetCombinedList()
                            
                                    if has('nvim')
                                        call setqflist(s:FixList(a:buffer, l:quickfix_list), ' ', l:title)
                                    else
                                        call setqflist(s:FixList(a:buffer, l:quickfix_list))
                                        call setqflist([], 'r', {'title': l:title})
                                    endif
    1              0.000001     elseif g:ale_set_loclist
                                    " If windows support is off, win_findbuf() may not exist.
                                    " We'll set result in the current window, which might not be correct,
                                    " but it's better than nothing.
    1   0.000006   0.000002         let l:ids = s:WinFindBuf(a:buffer)
                            
    1   0.000008   0.000002         let l:loclist = s:Deduplicate(a:loclist)
                            
    2              0.000002         for l:id in l:ids
    1              0.000002             if has('nvim')
                                            call setloclist(l:id, s:FixList(a:buffer, l:loclist), ' ', l:title)
    1              0.000001             else
    1   0.000022   0.000004                 call setloclist(l:id, s:FixList(a:buffer, l:loclist))
    1              0.000003                 call setloclist(l:id, [], 'r', {'title': l:title})
    1              0.000001             endif
    2              0.000000         endfor
    1              0.000001     endif
                            
                                " Save the current view before opening/closing any window
    1              0.000004     call setbufvar(a:buffer, 'ale_winview', winsaveview())
                            
                                " Open a window to show the problems if we need to.
                                "
                                " ShouldOpen() checks if the current buffer has enough problems to be
                                " opened.
    1   0.000013   0.000002     if s:ShouldOpen(a:buffer, len(a:loclist))
                                    let l:winnr = winnr()
                                    let l:mode = mode()
                            
                                    " open windows vertically instead of default horizontally
                                    let l:open_type = ''
                            
                                    if ale#Var(a:buffer, 'list_vertical') == 1
                                        let l:open_type = 'vert rightbelow '
                                    endif
                            
                                    if g:ale_set_quickfix
                                        if !ale#list#IsQuickfixOpen()
                                            silent! execute l:open_type . 'copen ' . str2nr(ale#Var(a:buffer, 'list_window_size'))
                                        endif
                                    elseif g:ale_set_loclist
                                        silent! execute l:open_type . 'lopen ' . str2nr(ale#Var(a:buffer, 'list_window_size'))
                                    endif
                            
                                    " If focus changed, restore it (jump to the last window).
                                    if l:winnr isnot# winnr()
                                        wincmd p
                                    endif
                            
                                    " Return to original mode when applicable
                                    if mode() != l:mode
                                        if l:mode is? 'v' || l:mode is# "\<c-v>"
                                            " Reset our last visual selection
                                            normal! gv
                                        elseif l:mode is? 's' || l:mode is# "\<c-s>"
                                            " Reset our last character selection
                                            normal! "\<c-g>"
                                        endif
                                    endif
                            
                                    call s:RestoreViewIfNeeded(a:buffer)
    1              0.000000     endif
                            
                                " If ALE isn't currently checking for more problems, close the window if
                                " needed now. This check happens inside of this timer function, so
                                " the window can be closed reliably.
    1   0.000007   0.000002     if !ale#engine#IsCheckingBuffer(a:buffer)
    1   0.000019   0.000002         call s:CloseWindowIfNeeded(a:buffer)
    1              0.000000     endif

FUNCTION  <SNR>198_CreateCountDict()
    Defined: ~/.vimgo/plugged/ale/autoload/ale/statusline.vim:5
Called 1 time
Total time:   0.000004
 Self time:   0.000004

count  total (s)   self (s)
                                " Keys 0 and 1 are for backwards compatibility.
                                " The count object used to be a List of [error_count, warning_count].
    1              0.000003     return {   '0': 0,   '1': 0,   'error': 0,   'warning': 0,   'info': 0,   'style_error': 0,   'style_warning': 0,   'total': 0,}

FUNCTION  ale#linter#Get()
    Defined: ~/.vimgo/plugged/ale/autoload/ale/linter.vim:373
Called 1 time
Total time:   0.001468
 Self time:   0.001074

count  total (s)   self (s)
    1              0.000008     let l:possibly_duplicated_linters = []
                            
                                " Handle dot-separated filetypes.
    2              0.000032     for l:original_filetype in split(a:original_filetypes, '\.')
    1   0.000185   0.000022         let l:filetype = ale#linter#ResolveFiletype(l:original_filetype)
    1   0.000113   0.000021         let l:linter_names = s:GetLinterNames(l:original_filetype)
    1   0.000157   0.000018         let l:all_linters = ale#linter#GetAll(l:filetype)
    1              0.000005         let l:filetype_linters = []
                            
    1              0.000011         if type(l:linter_names) is v:t_string && l:linter_names is# 'all'
    1              0.000006             let l:filetype_linters = l:all_linters
                                    elseif type(l:linter_names) is v:t_list
                                        " Select only the linters we or the user has specified.
                                        for l:linter in l:all_linters
                                            let l:name_list = [l:linter.name] + l:linter.aliases
                            
                                            for l:name in l:name_list
                                                if index(l:linter_names, l:name) >= 0
                                                    call add(l:filetype_linters, l:linter)
                                                    break
                                                endif
                                            endfor
                                        endfor
    1              0.000002         endif
                            
    1              0.000012         call extend(l:possibly_duplicated_linters, l:filetype_linters)
    2              0.000007     endfor
                            
    1              0.000005     let l:name_list = []
    1              0.000006     let l:combined_linters = []
                            
                                " Make sure we override linters so we don't get two with the same name,
                                " like 'eslint' for both 'javascript' and 'typescript'
                                "
                                " Note that the reverse calls here modify the List variables.
    9              0.000031     for l:linter in reverse(l:possibly_duplicated_linters)
    8              0.000055         if index(l:name_list, l:linter.name) < 0
    8              0.000046             call add(l:name_list, l:linter.name)
    8              0.000042             call add(l:combined_linters, l:linter)
    8              0.000499         endif
    9              0.000017     endfor
                            
    1              0.000007     return reverse(l:combined_linters)

FUNCTION  ale#command#IsDeferred()
    Defined: ~/.vimgo/plugged/ale/autoload/ale/command.vim:471
Called 24 times
Total time:   0.000124
 Self time:   0.000124

count  total (s)   self (s)
   24              0.000115     return type(a:value) is v:t_dict && has_key(a:value, '_deferred_job_id')

FUNCTION  <SNR>179_update_git_branch()
    Defined: ~/.vimgo/plugged/vim-airline/autoload/airline/extensions/branch.vim:87
Called 101 times
Total time:   0.016756
 Self time:   0.001276

count  total (s)   self (s)
  101   0.000745   0.000265   call airline#util#ignore_next_focusgain()
  101   0.000673   0.000194   if airline#util#has_fugitive()
  101   0.014761   0.000240     call s:config_fugitive_branch()
                              elseif airline#util#has_gina()
                                call s:config_gina_branch()
                              else
                                let s:vcs_config['git'].branch = ''
                                return
  101              0.000036   endif

FUNCTION  airline#extensions#coc#get_error()
    Defined: ~/.vimgo/plugged/vim-airline/autoload/airline/extensions/coc.vim:13
Called 4 times
Total time:   0.000040
 Self time:   0.000007

count  total (s)   self (s)
    4   0.000040   0.000007   return airline#extensions#coc#get('error')

FUNCTION  coc#highlight#add_highlight()
    Defined: ~/.vimgo/plugged/coc.nvim/autoload/coc/highlight.vim:287
Called 1115 times
Total time:   0.046593
 Self time:   0.014196

count  total (s)   self (s)
 1115              0.001204   let opts = get(a:, 1, {})
 1115              0.001278   let priority = get(opts, 'priority', v:null)
 1115              0.000456   if !s:is_vim
                                if s:set_extmark && a:src_id != -1
                                  " get(opts, 'start_incl', 0) ? v:true : v:false,
                                  try
                                    call nvim_buf_set_extmark(a:bufnr, a:src_id, a:line, a:col_start, { 'end_col': a:col_end, 'hl_group': a:hl_group, 'hl_mode': get(opts, 'combine', 1) ? 'combine' : 'replace', 'right_gravity': v:true, 'end_right_gravity': v:false, 'priority': type(priority) == 0 ?  min([priority, 4096]) : 4096, })
                                  catch /^Vim\%((\a\+)\)\=:E5555/
                                    " the end_col could be invalid, ignore this error
                                  endtry
                                else
                                  call nvim_buf_add_highlight(a:bufnr, a:src_id, a:hl_group, a:line, a:col_start, a:col_end)
                                endif
 1115              0.000279   else
 1115   0.035193   0.002796     call coc#api#exec('buf_add_highlight', [a:bufnr, a:src_id, a:hl_group, a:line, a:col_start, a:col_end, opts])
 1115              0.000266   endif

FUNCTION  <SNR>181_new_airline_ale_get_line_number()
    Defined: ~/.vimgo/plugged/vim-airline/autoload/airline/extensions/ale.vim:40
Called 8 times
Total time:   0.000017
 Self time:   0.000017

count  total (s)   self (s)
                              " The FirstProblem call in ALE is a far more efficient way
                              " of obtaining line number data. If the installed ALE supports
                              " it, we should use this method of getting line data.
    8              0.000002   if a:cnt == 0
    8              0.000005     return ''
                              endif
                              let l:buffer = bufnr('')
                            
                              " Try to get the first error from ALE.
                              let l:result = ale#statusline#FirstProblem(l:buffer, a:type)
                              if empty(l:result)
                                " If there are no errors then try and check for style errors.
                                let l:result =  ale#statusline#FirstProblem(l:buffer, 'style_' . a:type)
                              endif
                            
                              if empty(l:result)
                                  return ''
                              endif
                            
                              let l:open_lnum_symbol  = get(g:, 'airline#extensions#ale#open_lnum_symbol', '(L')
                              let l:close_lnum_symbol = get(g:, 'airline#extensions#ale#close_lnum_symbol', ')')
                            
                              return open_lnum_symbol . l:result.lnum . close_lnum_symbol

FUNCTION  <SNR>233_empty_border()
    Defined: ~/.vimgo/plugged/coc.nvim/autoload/coc/float.vim:1408
Called 20 times
Total time:   0.000059
 Self time:   0.000059

count  total (s)   self (s)
   20              0.000040   if empty(a:border) || empty(filter(copy(a:border), 'v:val != 0'))
   20              0.000006     return 1
                              endif
                              return 0

FUNCTION  <SNR>227_get_separator_change_with_end()
    Defined: ~/.vimgo/plugged/vim-airline/autoload/airline/extensions/tabline/builder.vim:76
Called 2 times
Total time:   0.000333
 Self time:   0.000024

count  total (s)   self (s)
    2              0.000002   let sep_change = 0
    2              0.000002   if !empty(a:new_end_group) " Separator between title and the end
    2   0.000316   0.000007     let sep_change += airline#builder#should_change_group(a:new_group, a:new_end_group) ? a:sep_size : a:alt_sep_size
    2              0.000000   endif
    2              0.000002   if !empty(a:old_group) " Separator between the title and the one adjacent
                                let sep_change += airline#builder#should_change_group(a:new_group, a:old_group) ? a:sep_size : a:alt_sep_size
                                if !empty(a:old_end_group) " Remove mis-predicted separator
                                  let sep_change -= airline#builder#should_change_group(a:old_group, a:old_end_group) ? a:sep_size : a:alt_sep_size
                                endif
    2              0.000000   endif
    2              0.000002   return sep_change

FUNCTION  airline#statusline()
    Defined: ~/.vimgo/plugged/vim-airline/autoload/airline.vim:218
Called 97 times
Total time:   0.001122
 Self time:   0.001122

count  total (s)   self (s)
   97              0.000445   if has_key(s:contexts, a:winnr)
   97              0.000540     return '%{airline#check_mode('.a:winnr.')}'.s:contexts[a:winnr].line
                              endif
                              " in rare circumstances this happens...see #276
                              return ''

FUNCTION  airline#check_mode()
    Defined: ~/.vimgo/plugged/vim-airline/autoload/airline.vim:227
Called 97 times
Total time:   0.052115
 Self time:   0.008020

count  total (s)   self (s)
   97              0.000228   if !has_key(s:contexts, a:winnr)
                                return ''
   97              0.000046   endif
   97              0.000207   let context = s:contexts[a:winnr]
                            
   97              0.000224   if get(w:, 'airline_active', 1)
   97              0.000224     let m = mode(1)
                                " Refer :help mode() to see the list of modes
                                "   NB: 'let mode' here refers to the display colour _groups_,
                                "   not the literal mode's code (i.e., m). E.g., Select modes
                                "   v, S and ^V use 'visual' since they are of similar ilk.
                                "   Some modes do not get recognised for status line purposes:
                                "   no, nov, noV, no^V, !, cv, and ce.
                                "   Mode name displayed is handled in init.vim (g:airline_mode_map).
                                "
   97              0.000209     if m[0] ==# "i"
   82              0.000150       let mode = ['insert']  " Insert modes + submodes (i, ic, ix)
   15              0.000020     elseif m[0] == "R"
                                  let mode = ['replace']  " Replace modes + submodes (R, Rc, Rv, Rx) (NB: case sensitive as 'r' is a mode)
   15              0.000077     elseif m[0] =~ '\v(v|V||s|S|)'
                                    let mode = ['visual']  " Visual and Select modes (v, V, ^V, s, S, ^S))
   15              0.000008     elseif m ==# "t"
                                  let mode = ['terminal']  " Terminal mode (only has one mode (t))
   15              0.000038     elseif m[0] =~ '\v(c|r|!)'
    2              0.000007       let mode = ['commandline']  " c, cv, ce, r, rm, r? (NB: cv and ce stay showing as mode entered from)
   13              0.000006     else
   13              0.000016       let mode = ['normal']  " Normal mode + submodes (n, niI, niR, niV; plus operator pendings no, nov, noV, no^V)
   97              0.000039     endif
   97              0.000335     if exists("*VMInfos") && !empty(VMInfos())
                                  " Vim plugin Multiple Cursors https://github.com/mg979/vim-visual-multi
                                  let m = 'multi'
   97              0.000038     endif
                                " Adjust to handle additional modes, which don't display correctly otherwise
   97              0.000438     if index(['niI', 'niR', 'niV', 'ic', 'ix', 'Rc', 'Rv', 'Rx', 'multi'], m) == -1
   97              0.000138       let m = m[0]
   97              0.000046     endif
   97              0.000319     let w:airline_current_mode = get(g:airline_mode_map, m, m)
                              else
                                let mode = ['inactive']
                                let w:airline_current_mode = get(g:airline_mode_map, '__')
   97              0.000050   endif
                            
   97              0.000222   if g:airline_detect_modified && &modified
   87              0.000238     call add(mode, 'modified')
   97              0.000037   endif
                            
   97              0.000127   if g:airline_detect_paste && &paste
                                call add(mode, 'paste')
   97              0.000040   endif
                            
   97              0.000330   if g:airline_detect_crypt && exists("+key") && !empty(&key)
                                call add(mode, 'crypt')
   97              0.000030   endif
                            
   97              0.000143   if g:airline_detect_spell && &spell
                                call add(mode, 'spell')
   97              0.000024   endif
                            
   97              0.000118   if &readonly || ! &modifiable
                                call add(mode, 'readonly')
   97              0.000032   endif
                            
   97              0.000271   let mode_string = join(mode)
   97              0.000253   if get(w:, 'airline_lastmode', '') != mode_string
    6   0.002530   0.000037     call airline#highlighter#highlight_modified_inactive(context.bufnr)
    6   0.041436   0.000060     call airline#highlighter#highlight(mode, string(context.bufnr))
    6   0.000252   0.000026     call airline#util#doautocmd('AirlineModeChanged')
    6              0.000010     let w:airline_lastmode = mode_string
   97              0.000029   endif
                            
   97              0.000071   return ''

FUNCTION  <SNR>183_ws_refresh()
    Defined: ~/.vimgo/plugged/vim-airline/autoload/airline/extensions/whitespace.vim:186
Called 3 times
Total time:   0.000015
 Self time:   0.000015

count  total (s)   self (s)
    3              0.000005   if !exists('#airline')
                                " airline disabled
                                return
    3              0.000000   endif
    3              0.000005   if get(b:, 'airline_ws_changedtick', 0) == b:changedtick
    3              0.000001     return
                              endif
                              unlet! b:airline_whitespace_check
                              if get(g:, 'airline_skip_empty_sections', 0)
                                exe ':AirlineRefresh!'
                              endif
                              let b:airline_ws_changedtick = b:changedtick

FUNCTION  <SNR>179_sh_autocmd_handler()
    Defined: ~/.vimgo/plugged/vim-airline/autoload/airline/extensions/branch.vim:356
Called 4 times
Total time:   0.000045
 Self time:   0.000045

count  total (s)   self (s)
    4              0.000015   if exists('#airline')
    4              0.000021     unlet! b:airline_head b:airline_do_mq_check
    4              0.000004   endif

FUNCTION  airline#util#append()
    Defined: ~/.vimgo/plugged/vim-airline/autoload/airline/util.vim:51
Called 679 times
Total time:   0.004155
 Self time:   0.004155

count  total (s)   self (s)
  679              0.000928   if a:minwidth > 0 && airline#util#winwidth() < a:minwidth
                                return ''
  679              0.000243   endif
  679              0.001249   let prefix = s:spc == "\ua0" ? s:spc : s:spc.s:spc
  679              0.001181   return empty(a:text) ? '' : prefix.g:airline_left_alt_sep.s:spc.a:text

FUNCTION  coc#util#get_format_opts()
    Defined: ~/.vimgo/plugged/coc.nvim/autoload/coc/util.vim:393
Called 1 time
Total time:   0.000025
 Self time:   0.000025

count  total (s)   self (s)
    1              0.000005   let bufnr = a:bufnr && bufloaded(a:bufnr) ? a:bufnr : bufnr('%')
    1              0.000004   let tabsize = getbufvar(bufnr, '&shiftwidth')
    1              0.000001   if tabsize == 0
                                let tabsize = getbufvar(bufnr, '&tabstop')
    1              0.000000   endif
    1              0.000012   return { 'tabsize': tabsize, 'expandtab': getbufvar(bufnr, '&expandtab'), 'insertFinalNewline': getbufvar(bufnr, '&eol'), 'trimTrailingWhitespace': getbufvar(bufnr, 'coc_trim_trailing_whitespace', 0), 'trimFinalNewlines': getbufvar(bufnr, 'coc_trim_final_newlines', 0) }

FUNCTION  coc#window#is_float()
    Defined: ~/.vimgo/plugged/coc.nvim/autoload/coc/window.vim:104
Called 3 times
Total time:   0.000015
 Self time:   0.000015

count  total (s)   self (s)
    3              0.000002   if s:is_vim
    3              0.000005     if exists('*popup_list')
    3              0.000006       return index(popup_list(), a:winid) != -1
                                else
                                  try
                                    return !empty(popup_getpos(a:winid))
                                  catch /^Vim\%((\a\+)\)\=:E993/
                                    return 0
                                  endtry
                                endif
                                return 0
                              elseif exists('*nvim_win_get_config')
                                let config = nvim_win_get_config(a:winid)
                                return !empty(config) && !empty(get(config, 'relative', ''))
                              endif

FUNCTION  coc#float#create_buf()
    Defined: ~/.vimgo/plugged/coc.nvim/autoload/coc/float.vim:927
Called 20 times
Total time:   0.001127
 Self time:   0.001120

count  total (s)   self (s)
   20              0.000042   if a:bufnr > 0 && bufloaded(a:bufnr)
   18              0.000017     let bufnr = a:bufnr
    2              0.000001   else
    2              0.000001     if s:is_vim
    2              0.000042       noa let bufnr = bufadd('')
    2              0.000063       noa call bufload(bufnr)
    2   0.000020   0.000018       call setbufvar(bufnr, '&buflisted', 0)
                                else
                                  noa let bufnr = nvim_create_buf(v:false, v:true)
    2              0.000001     endif
    2              0.000004     let bufhidden = get(a:, 2, 'wipe')
    2   0.000012   0.000010     call setbufvar(bufnr, '&buftype', 'nofile')
    2              0.000009     call setbufvar(bufnr, '&bufhidden', bufhidden)
    2   0.000010   0.000008     call setbufvar(bufnr, '&swapfile', 0)
    2              0.000010     call setbufvar(bufnr, '&undolevels', -1)
                                " neovim's bug
    2   0.000008   0.000007     call setbufvar(bufnr, '&modifiable', 1)
   20              0.000005   endif
   20              0.000039   let lines = get(a:, 1, v:null)
   20              0.000031   if type(lines) == v:t_list
   20              0.000066     if has('nvim')
                                  call nvim_buf_set_lines(bufnr, 0, -1, v:false, lines)
   20              0.000007     else
   20              0.000173       silent noa call setbufline(bufnr, 1, lines)
   20              0.000118       silent noa call deletebufline(bufnr, len(lines) + 1, '$')
   20              0.000007     endif
   20              0.000004   endif
   20              0.000014   return bufnr

FUNCTION  airline#themes#get_highlight()
    Defined: ~/.vimgo/plugged/vim-airline/autoload/airline/themes.vim:35
Called 214 times
Total time:   0.014964
 Self time:   0.000730

count  total (s)   self (s)
  214   0.014863   0.000629     return call('airline#highlighter#get_highlight', [a:group] + a:000)

FUNCTION  airline#mode_changed()
    Defined: ~/.vimgo/plugged/vim-airline/autoload/airline.vim:307
Called 6 times
Total time:   0.000079
 Self time:   0.000049

count  total (s)   self (s)
                              " airline#visual_active
                              " Boolean: for when to get visual wordcount
                              " needed for the wordcount extension
    6              0.000026   let g:airline#visual_active = (mode() =~? '[vs]')
    6   0.000042   0.000012   call airline#update_tabline()

FUNCTION  <SNR>194_get_section()
    Defined: ~/.vimgo/plugged/vim-airline/autoload/airline/extensions/default.vim:20
Called 44 times
Total time:   0.001836
 Self time:   0.001357

count  total (s)   self (s)
   44              0.000115   if has_key(s:section_truncate_width, a:key)
   32   0.000468   0.000132     if airline#util#winwidth(a:winnr) < s:section_truncate_width[a:key]
                                  return ''
   32              0.000018     endif
   44              0.000029   endif
   44              0.000080   let spc = g:airline_symbols.space
   44              0.000156   if !exists('g:airline_section_{a:key}')
                                return ''
   44              0.000019   endif
   44   0.000391   0.000248   let text = airline#util#getwinvar(a:winnr, 'airline_section_'.a:key, g:airline_section_{a:key})
   44              0.000234   let [prefix, suffix] = [get(a:000, 0, '%('.spc), get(a:000, 1, spc.'%)')]
   44              0.000151   return empty(text) ? '' : prefix.text.suffix

FUNCTION  coc#highlight#create_namespace()
    Defined: ~/.vimgo/plugged/coc.nvim/autoload/coc/highlight.vim:680
Called 24 times
Total time:   0.000082
 Self time:   0.000082

count  total (s)   self (s)
   24              0.000029   if type(a:key) == 0
   21              0.000013     return a:key
    3              0.000002   endif
    3              0.000008   if has_key(s:namespace_map, a:key)
    2              0.000005     return s:namespace_map[a:key]
    1              0.000000   endif
    1              0.000002   if has('nvim')
                                let s:namespace_map[a:key] = nvim_create_namespace('coc-'.a:key)
    1              0.000000   else
    1              0.000002     let s:namespace_map[a:key] = s:ns_id
    1              0.000001     let s:ns_id = s:ns_id + 1
    1              0.000001   endif
    1              0.000001   return s:namespace_map[a:key]

FUNCTION  coc#pum#close_detail()
    Defined: ~/.vimgo/plugged/coc.nvim/autoload/coc/pum.vim:37
Called 12 times
Total time:   0.000989
 Self time:   0.000140

count  total (s)   self (s)
   12   0.000248   0.000056   let winid = coc#float#get_float_by_kind('pumdetail')
   12              0.000008   if winid
    2   0.000665   0.000008     call coc#float#close(winid, 1)
    2              0.000001     if s:is_vim
    2              0.000006       call timer_start(0, { -> execute('redraw')})
    2              0.000000     endif
   12              0.000003   endif

FUNCTION  <SNR>180_sh_autocmd_handler()
    Defined: ~/.vimgo/plugged/vim-airline/autoload/airline/extensions/fugitiveline.vim:36
Called 4 times
Total time:   0.000024
 Self time:   0.000024

count  total (s)   self (s)
    4              0.000012   if exists('#airline')
    4              0.000009     unlet! b:fugitive_name
    4              0.000003   endif

FUNCTION  <SNR>88_Remove_Matches()
    Defined: /usr/share/vim/vim90/plugin/matchparen.vim:196
Called 76 times
Total time:   0.000653
 Self time:   0.000653

count  total (s)   self (s)
   76              0.000277   if exists('w:paren_hl_on') && w:paren_hl_on
   46              0.000131     silent! call matchdelete(3)
   46              0.000072     let w:paren_hl_on = 0
   76              0.000032   endif

FUNCTION  airline#extensions#fugitiveline#bufname()
    Defined: ~/.vimgo/plugged/vim-airline/autoload/airline/extensions/fugitiveline.vim:13
Called 97 times
Total time:   0.001963
 Self time:   0.001963

count  total (s)   self (s)
   97              0.000171   if !exists('b:fugitive_name')
    4              0.000004     let b:fugitive_name = ''
    4              0.000003     try
    4              0.000012       if bufname('%') =~? '^fugitive:' && exists('*FugitiveReal')
                                    let b:fugitive_name = FugitiveReal(bufname('%'))
    4              0.000001       endif
                                catch
    4              0.000001     endtry
   97              0.000037   endif
                            
   97              0.000219   let fmod = (exists("+autochdir") && &autochdir) ? ':p' : ':.'
   97              0.000091   let result=''
   97              0.000128   if empty(b:fugitive_name)
   97              0.000210     if empty(bufname('%'))
                                  return &buftype ==# 'nofile' ? '[Scratch]' : '[No Name]'
   97              0.000037     endif
   97              0.000203     return s:has_percent_eval ? '%f' : fnamemodify(bufname('%'), fmod)
                              else
                                return s:has_percent_eval ? '%f [git]' : (fnamemodify(b:fugitive_name, fmod). " [git]")
                              endif

FUNCTION  <SNR>197_RunLinter()
    Defined: ~/.vimgo/plugged/ale/autoload/ale/engine.vim:589
Called 8 times
Total time:   0.374799
 Self time:   0.000107

count  total (s)   self (s)
    8              0.000017     if !empty(a:linter.lsp)
    2   0.092935   0.000007         return ale#lsp_linter#CheckWithLSP(a:buffer, a:linter)
    6              0.000002     else
    6   0.001714   0.000027         let l:executable = ale#linter#GetExecutable(a:buffer, a:linter)
                            
    6   0.280110   0.000033         return s:RunIfExecutable(a:buffer, a:linter, a:lint_file, l:executable)
                                endif
                            
                                return 0

FUNCTION  ale#handlers#cspell#GetExecutable()
    Defined: ~/.vimgo/plugged/ale/autoload/ale/handlers/cspell.vim:5
Called 1 time
Total time:   0.000714
 Self time:   0.000016

count  total (s)   self (s)
    1   0.000713   0.000015     return ale#path#FindExecutable(a:buffer,    'cspell', [        'node_modules/.bin/cspell',        'node_modules/cspell/bin.js',    ])

FUNCTION  airline#extensions#coc#get_warning()
    Defined: ~/.vimgo/plugged/vim-airline/autoload/airline/extensions/coc.vim:9
Called 4 times
Total time:   0.000049
 Self time:   0.000009

count  total (s)   self (s)
    4   0.000049   0.000009   return airline#extensions#coc#get('warning')

FUNCTION  airline#extensions#coc#get_status()
    Defined: ~/.vimgo/plugged/vim-airline/autoload/airline/extensions/coc.vim:39
Called 97 times
Total time:   0.002014
 Self time:   0.000592

count  total (s)   self (s)
                              " Shorten text for windows < 91 characters
   97   0.001771   0.000349   let status = airline#util#shorten(get(g:, 'coc_status', ''), 91, 9)
   97              0.000157   return (s:show_coc_status ? status : '')

FUNCTION  airline#extensions#tabline#tabs#tabnr_formatter()
    Defined: ~/.vimgo/plugged/vim-airline/autoload/airline/extensions/tabline/tabs.vim:131
Called 1 time
Total time:   0.000014
 Self time:   0.000010

count  total (s)   self (s)
    1              0.000002   let formatter = get(g:, 'airline#extensions#tabline#tabnr_formatter', 'tabnr')
    1              0.000000   try
    1   0.000008   0.000004     return airline#extensions#tabline#formatters#{formatter}#format(a:nr, a:i)
                              catch /^Vim\%((\a\+)\)\=:E117/	" catch E117, unknown function
                                " Function not found
                                return call(formatter, [a:nr, a:i])
                              catch
                                " something went wrong, return an empty string
                                return ""
    1              0.000001   endtry

FUNCTION  coc#float#on_close()
    Defined: ~/.vimgo/plugged/coc.nvim/autoload/coc/float.vim:711
Called 7 times
Total time:   0.000176
 Self time:   0.000092

count  total (s)   self (s)
    7   0.000098   0.000014   let winids = coc#float#get_float_win_list()
   17              0.000011   for winid in winids
   10              0.000018     let target = getwinvar(winid, 'target_winid', -1)
   10              0.000006     if target == a:winid
                                  call coc#float#close(winid)
   10              0.000001     endif
   17              0.000012   endfor

FUNCTION  coc#float#vim_buttons()
    Defined: ~/.vimgo/plugged/coc.nvim/autoload/coc/float.vim:767
Called 20 times
Total time:   0.001574
 Self time:   0.000370

count  total (s)   self (s)
   20              0.000044   if !has('patch-8.2.0750')
                                return
   20              0.000004   endif
   20              0.000037   let related = getwinvar(a:winid, 'related', [])
   20   0.001258   0.000054   let winid = coc#float#get_related(a:winid, 'buttons')
   20              0.000028   let btns = get(a:config, 'buttons', [])
   20              0.000017   if empty(btns)
   20              0.000008     if winid
                                  call s:close_win(winid, 1)
                                  " fix padding
                                  let opts = popup_getoptions(a:winid)
                                  let padding = get(opts, 'padding', v:null)
                                  if !empty(padding)
                                    let padding[2] = padding[2] - 2
                                  endif
                                  call popup_setoptions(a:winid, {'padding': padding})
   20              0.000006     endif
   20              0.000008     return
                              endif
                              let border = get(a:config, 'border', v:null)
                              if !winid
                                " adjusting popup padding
                                let opts = popup_getoptions(a:winid)
                                let padding = get(opts, 'padding', v:null)
                                if type(padding) == 7
                                  let padding = [0, 0, 2, 0]
                                elseif len(padding) == 0
                                  let padding = [1, 1, 3, 1]
                                else
                                  let padding[2] = padding[2] + 2
                                endif
                                call popup_setoptions(a:winid, {'padding': padding})
                              endif
                              let borderhighlight = get(get(a:config, 'borderhighlight', []), 0, '')
                              let pos = popup_getpos(a:winid)
                              let bw = empty(border) ? 0 : get(border, 1, 0) + get(border, 3, 0)
                              let borderbottom = empty(border) ? 0 : get(border, 2, 0)
                              let borderleft = empty(border) ? 0 : get(border, 3, 0)
                              let width = pos['width'] - bw + get(pos, 'scrollbar', 0)
                              let bufnr = s:create_btns_buffer(winid ? winbufnr(winid): 0,width, btns, borderbottom)
                              let height = 2 + (borderbottom ? 1 : 0)
                              let keys = s:gen_filter_keys(getbufline(bufnr, 2)[0])
                              let options = { 'filter': {id, key -> coc#float#vim_filter(id, key, keys[1])}, 'highlight': get(opts, 'highlight', 'CocFloating') }
                              let config = { 'line': pos['line'] + pos['height'] - height, 'col': pos['col'] + borderleft, 'minwidth': width, 'minheight': height, 'maxwidth': width, 'maxheight': height, }
                              if winid != 0
                                call popup_move(winid, config)
                                call popup_setoptions(winid, options)
                                call win_execute(winid, 'call clearmatches()')
                              else
                                let options = extend({ 'filtermode': 'nvi', 'padding': [0, 0, 0, 0], 'fixed': 1, 'zindex': 99, }, options)
                                call extend(options, config)
                                let winid = popup_create(bufnr, options)
                                if !s:popup_list_api
                                  call add(s:popup_list, winid)
                                endif
                              endif
                              if winid != 0
                                if !empty(borderhighlight)
                                  call coc#highlight#add_highlight(bufnr, -1, borderhighlight, 0, 0, -1)
                                  call coc#highlight#add_highlight(bufnr, -1, borderhighlight, 2, 0, -1)
                                  call win_execute(winid, 'call matchadd("'.borderhighlight.'", "'.s:borderchars[1].'")')
                                endif
                                call setwinvar(winid, 'kind', 'buttons')
                                call setwinvar(winid, 'target_winid', a:winid)
                                call add(related, winid)
                                call setwinvar(a:winid, 'related', related)
                                call matchaddpos('MoreMsg', map(keys[0], "[2,v:val]"), 99, -1, {'window': winid})
                              endif

FUNCTION  <SNR>176_get_syn()
    Defined: ~/.vimgo/plugged/vim-airline/autoload/airline/highlighter.vim:44
Called 1940 times
Total time:   0.020124
 Self time:   0.020124

count  total (s)   self (s)
 1940              0.001126     let color = ''
 1940              0.003074     if hlexists(a:group)
 1928              0.005177       let color = synIDattr(synIDtrans(hlID(a:group)), a:what, a:mode)
 1940              0.000547     endif
 1940              0.002035     if empty(color) || color == -1
                                  " should always exist
   12              0.000054       let color = synIDattr(synIDtrans(hlID('Normal')), a:what, a:mode)
                                  " however, just in case
   12              0.000015       if empty(color) || color == -1
                                    let color = 'NONE'
   12              0.000002       endif
 1940              0.000541     endif
 1940              0.000917     return color

FUNCTION  airline#util#exec_funcrefs()
    Defined: ~/.vimgo/plugged/vim-airline/autoload/airline/util.vim:95
Called 4 times
Total time:   0.005240
 Self time:   0.000434

count  total (s)   self (s)
   36              0.000063     for Fn in a:list
   36   0.005024   0.000218       let code = call(Fn, a:000)
   36              0.000048       if code != 0
    4              0.000005         return code
   32              0.000022       endif
   32              0.000023     endfor
                                return 0

FUNCTION  <SNR>102_GetMSL()
    Defined: ~/.vimgo/plugged/yats.vim/indent/typescript.vim:102
Called 4 times
Total time:   0.000827
 Self time:   0.000260

count  total (s)   self (s)
                              " Start on the line we're at and use its indent.
    4              0.000008   let msl = a:lnum
    4   0.000283   0.000020   let lnum = s:PrevNonBlankNonString(a:lnum - 1)
    4              0.000006   while lnum > 0
                                " If we have a continuation line, or we're in a string, use line as MSL.
                                " Otherwise, terminate search as we have found our MSL already.
    4              0.000010     let line = getline(lnum)
    4              0.000078     let col = match(line, s:msl_regex) + 1
    4   0.000346   0.000042     if (col > 0 && !s:IsInStringOrComment(lnum, col)) || s:IsInString(lnum, strlen(line))
                                  let msl = lnum
    4              0.000003     else
                                  " Don't use lines that are part of a one line scope as msl unless the
                                  " flag in_one_line_scope is set to 1
                                  "
    4              0.000009       if a:in_one_line_scope
    4              0.000003         break
                                  end
                                  let msl_one_line = s:Match(lnum, s:one_line_scope_regex)
                                  if msl_one_line == 0
                                    break
                                  endif
                                endif
                                let lnum = s:PrevNonBlankNonString(lnum - 1)
    4              0.000009   endwhile
    4              0.000004   return msl

FUNCTION  coc#util#get_buf_lines()
    Defined: ~/.vimgo/plugged/coc.nvim/autoload/coc/util.vim:576
Called 19 times
Total time:   0.000258
 Self time:   0.000258

count  total (s)   self (s)
   19              0.000054   if !bufloaded(a:bufnr)
                                return v:null
   19              0.000011   endif
   19              0.000051   let changedtick = getbufvar(a:bufnr, 'changedtick')
   19              0.000029   if changedtick == a:changedtick
   15              0.000015     return v:null
    4              0.000002   endif
    4              0.000055   return { 'lines': getbufline(a:bufnr, 1, '$'), 'changedtick': getbufvar(a:bufnr, 'changedtick') }

FUNCTION  <SNR>243_get_pum_dimension()
    Defined: ~/.vimgo/plugged/coc.nvim/autoload/coc/pum.vim:459
Called 17 times
Total time:   0.001050
 Self time:   0.000922

count  total (s)   self (s)
   17              0.000027   let linecount = len(a:lines)
   17   0.000183   0.000055   let [lineIdx, colIdx] = coc#cursor#screen_pos()
   17              0.000047   let bh = empty(get(a:config, 'border', [])) ? 0 : 2
   17              0.000024   let columns = &columns
   17              0.000050   let pumwidth = max([15, exists('&pumwidth') ? &pumwidth : 0])
   17              0.000044   let width = min([columns, max([pumwidth, a:config['width']])])
   17              0.000034   let vh = &lines - &cmdheight - 1 - !empty(&tabline)
   17              0.000009   if vh <= 0
                                return v:null
   17              0.000006   endif
   17              0.000023   let pumheight = empty(&pumheight) ? vh : &pumheight
   17              0.000054   let showTop = getwinvar(s:pum_winid, 'above', v:null)
   17              0.000025   if type(showTop) != v:t_number
    4              0.000014     if vh - lineIdx - bh - 1 < min([pumheight, linecount]) && vh - lineIdx < min([10, vh/2])
    4              0.000003       let showTop = 1
                                else
                                  let showTop = 0
    4              0.000000     endif
   17              0.000003   endif
   17              0.000062   let height = showTop ? min([lineIdx - bh - !empty(&tabline), linecount, pumheight]) : min([vh - lineIdx - bh - 1, linecount, pumheight])
   17              0.000011   if height <= 0
                                return v:null
   17              0.000007   endif
                              " should use strdiplaywidth here
   17              0.000047   let text = strpart(getline('.'), a:col, col('.') - 1 - a:col)
   17              0.000040   let col = - strdisplaywidth(text, a:col) - 1
   17              0.000020   let row = showTop ? - height : 1
   17              0.000019   let delta = colIdx + col
   17              0.000023   if width > pumwidth && delta + width > columns
                                let width = max([columns - delta, pumwidth])
   17              0.000002   endif
   17              0.000008   if delta < 0
                                let col = col - delta
   17              0.000015   elseif delta + width > columns
                                let col = max([-colIdx, col - (delta + width - columns)])
   17              0.000004   endif
   17              0.000047   return { 'row': row, 'col': col, 'width': width, 'height': height }

FUNCTION  coc#float#check_related()
    Defined: ~/.vimgo/plugged/coc.nvim/autoload/coc/float.vim:748
Called 3 times
Total time:   0.000236
 Self time:   0.000148

count  total (s)   self (s)
    3              0.000015   let invalids = []
    3   0.000112   0.000024   let ids = coc#float#get_float_win_list(1)
    3              0.000013   for id in ids
                                let target = getwinvar(id, 'target_winid', 0)
                                if target && index(ids, target) == -1
                                  call add(invalids, id)
                                endif
    3              0.000005   endfor
    3              0.000010   if s:is_vim && !s:popup_list_api
                                let s:popup_list = filter(ids, "index(invalids, v:val) == -1")
    3              0.000002   endif
    3              0.000008   for id in invalids
                                call coc#float#close(id)
    3              0.000004   endfor

FUNCTION  <SNR>102_PrevNonBlankNonString()
    Defined: ~/.vimgo/plugged/yats.vim/indent/typescript.vim:78
Called 5 times
Total time:   0.000403
 Self time:   0.000278

count  total (s)   self (s)
    5              0.000008   let in_block = 0
    5              0.000017   let lnum = prevnonblank(a:lnum)
    5              0.000008   while lnum > 0
                                " Go in and out of blocks comments as necessary.
                                " If the line isn't empty (with opt. comment) or in a string, end search.
    5              0.000018     let line = getline(lnum)
    5              0.000016     if line =~ '/\*'
                                  if in_block
                                    let in_block = 0
                                  else
                                    break
                                  endif
    5              0.000017     elseif !in_block && line =~ '\*/'
                                  let in_block = 1
    5   0.000184   0.000059     elseif !in_block && line !~ '^\s*\%(//\).*$' && !(s:IsInStringOrComment(lnum, 1) && s:IsInStringOrComment(lnum, strlen(line)))
    5              0.000005       break
                                endif
                                let lnum = prevnonblank(lnum - 1)
    5              0.000008   endwhile
    5              0.000007   return lnum

FUNCTION  airline#util#has_fugitive()
    Defined: ~/.vimgo/plugged/vim-airline/autoload/airline/util.vim:145
Called 101 times
Total time:   0.000479
 Self time:   0.000479

count  total (s)   self (s)
  101              0.000183   if !exists("s:has_fugitive")
                                let s:has_fugitive = exists('*FugitiveHead')
  101              0.000043   endif
  101              0.000079   return s:has_fugitive

FUNCTION  <SNR>222_Deduplicate()
    Defined: ~/.vimgo/plugged/ale/autoload/ale/list.vim:57
Called 1 time
Total time:   0.000006
 Self time:   0.000006

count  total (s)   self (s)
    1              0.000000     let l:list = a:list
                            
    1              0.000002     call sort(l:list, function('ale#util#LocItemCompareWithText'))
    1              0.000002     call uniq(l:list, function('ale#util#LocItemCompareWithText'))
                            
    1              0.000001     return l:list

FUNCTION  <SNR>80_left()
    Defined: ~/.vimgo/plugged/auto-pairs/plugin/auto-pairs.vim:123
Called 1 time
Total time:   0.000011
 Self time:   0.000005

count  total (s)   self (s)
    1   0.000010   0.000004   return repeat(s:Left, s:ulen(a:s))

FUNCTION  coc#float#create_float_win()
    Defined: ~/.vimgo/plugged/coc.nvim/autoload/coc/float.vim:119
Called 20 times
Total time:   0.094029
 Self time:   0.001867

count  total (s)   self (s)
   20              0.000035   let lines = get(a:config, 'lines', v:null)
   20              0.000010   let bufnr = a:bufnr
   20              0.000040   try
   20   0.001188   0.000061     let bufnr = coc#float#create_buf(a:bufnr, lines, 'hide')
                              catch /E523:/
                                " happens when using getchar() #3921
                                return []
   20              0.000015   endtry
   20              0.000043   let lnum = max([1, get(a:config, 'index', 0) + 1])
                              " use exists
   20   0.000209   0.000041   if a:winid && coc#float#valid(a:winid)
   13              0.000006     if s:is_vim
   13   0.000336   0.000044       let [line, col] = s:popup_position(a:config)
   13   0.000182   0.000118       let opts = { 'firstline': 1, 'line': line, 'col': col, 'minwidth': a:config['width'], 'minheight': a:config['height'], 'maxwidth': a:config['width'], 'maxheight': a:config['height'], 'title': get(a:config, 'title', ''), 'highlight': get(a:config, 'highlight', 'CocFloating'), 'borderhighlight':  [s:get_borderhighlight(a:config)], }
   13   0.000071   0.000033       if !s:empty_border(get(a:config, 'border', []))
                                    let opts['border'] = a:config['border']
   13              0.000007       endif
   13              0.000209       call popup_setoptions(a:winid, opts)
   13              0.000116       call win_execute(a:winid, 'exe '.lnum)
   13   0.001057   0.000029       call coc#float#vim_buttons(a:winid, a:config)
   13   0.039293   0.000041       call s:add_highlights(a:winid, a:config, 0)
   13              0.000022       return [a:winid, winbufnr(a:winid)]
                                else
                                  let config = s:convert_config_nvim(a:config, 0)
                                  let hlgroup = get(a:config, 'highlight', 'CocFloating')
                                  let current = getwinvar(a:winid, '&winhl', '')
                                  let winhl = coc#util#merge_winhl(current, [['Normal', hlgroup], ['FoldColumn', hlgroup]])
                                  if winhl !=# current
                                    call setwinvar(a:winid, '&winhl', winhl)
                                  endif
                                  call nvim_win_set_buf(a:winid, bufnr)
                                  call nvim_win_set_config(a:winid, config)
                                  call nvim_win_set_cursor(a:winid, [lnum, 0])
                                  call coc#float#nvim_create_related(a:winid, config, a:config)
                                  call s:add_highlights(a:winid, a:config, 0)
                                  return [a:winid, bufnr]
                                endif
    7              0.000002   endif
    7              0.000004   let winid = 0
    7              0.000003   if s:is_vim
    7   0.000161   0.000025     let [line, col] = s:popup_position(a:config)
    7              0.000008     let title = get(a:config, 'title', '')
    7              0.000010     let buttons = get(a:config, 'buttons', [])
    7              0.000007     let hlgroup = get(a:config, 'highlight',  'CocFloating')
    7              0.000007     let nopad = get(a:config, 'nopad', 0)
    7   0.000045   0.000024     let border = s:empty_border(get(a:config, 'border', [])) ? [0, 0, 0, 0] : a:config['border']
    7   0.000192   0.000114     let opts = { 'title': title, 'line': line, 'col': col, 'fixed': 1, 'padding': [0, !nopad && !border[1], 0, !nopad && !border[3]], 'borderchars': s:get_borderchars(a:config), 'highlight': hlgroup, 'minwidth': a:config['width'], 'minheight': a:config['height'], 'maxwidth': a:config['width'], 'maxheight': a:config['height'], 'close': get(a:config, 'close', 0) ? 'button' : 'none', 'border': border, 'callback': { -> coc#float#on_close(winid)}, 'borderhighlight': [s:get_borderhighlight(a:config)], 'scrollbarhighlight': 'CocFloatSbar', 'thumbhighlight': 'CocFloatThumb', }
    7              0.000219     let winid = popup_create(bufnr, opts)
    7              0.000004     if !s:popup_list_api
                                  call add(s:popup_list, winid)
    7              0.000003     endif
    7   0.000475   0.000020     call s:set_float_defaults(winid, a:config)
    7              0.000030     call win_execute(winid, 'exe '.lnum)
    7   0.000566   0.000020     call coc#float#vim_buttons(winid, a:config)
                              else
                                let config = s:convert_config_nvim(a:config, 1)
                                let border = get(a:config, 'border', [])
                                if has('nvim-0.5.0') && get(a:config, 'shadow', 0) && empty(get(a:config, 'buttons', v:null)) && empty(get(border, 2, 0))
                                  let config['border'] = 'shadow'
                                endif
                                noa let winid = nvim_open_win(bufnr, 0, config)
                                if winid is 0
                                  return []
                                endif
                                " cursorline highlight not work on old neovim
                                call s:set_float_defaults(winid, a:config)
                                call nvim_win_set_cursor(winid, [lnum, 0])
                                call coc#float#nvim_create_related(winid, config, a:config)
                                call coc#float#nvim_set_winblend(winid, get(a:config, 'winblend', v:null))
    7              0.000001   endif
    7   0.048915   0.000023   call s:add_highlights(winid, a:config, 1)
    7              0.000008   let g:coc_last_float_win = winid
    7   0.000083   0.000018   call coc#util#do_autocmd('CocOpenFloat')
    7              0.000008   return [winid, bufnr]

FUNCTION  <SNR>222_FixList()
    Defined: ~/.vimgo/plugged/ale/autoload/ale/list.vim:76
Called 1 time
Total time:   0.000018
 Self time:   0.000012

count  total (s)   self (s)
    1   0.000009   0.000003     let l:format = ale#Var(a:buffer, 'loclist_msg_format')
    1              0.000001     let l:new_list = []
                            
    1              0.000000     for l:item in a:list
                                    let l:fixed_item = copy(l:item)
                            
                                    let l:fixed_item.text = ale#GetLocItemMessage(l:item, l:format)
                            
                                    if l:item.bufnr == -1
                                        " If the buffer number is invalid, remove it.
                                        call remove(l:fixed_item, 'bufnr')
                                    endif
                            
                                    call add(l:new_list, l:fixed_item)
    1              0.000001     endfor
                            
    1              0.000001     return l:new_list

FUNCTION  airline#parts#filetype()
    Defined: ~/.vimgo/plugged/vim-airline/autoload/airline/parts.vim:190
Called 101 times
Total time:   0.000967
 Self time:   0.000416

count  total (s)   self (s)
  101   0.000945   0.000394   return (airline#util#winwidth() < 90 && strlen(&filetype) > 3) ? matchstr(&filetype, '...'). (&encoding is? 'utf-8' ? '' : '>') : &filetype

FUNCTION  airline#extensions#netrw#apply()
    Defined: ~/.vimgo/plugged/vim-airline/autoload/airline/extensions/netrw.vim:11
Called 4 times
Total time:   0.000128
 Self time:   0.000128

count  total (s)   self (s)
    4              0.000036   if &ft == 'netrw'
                                let spc = g:airline_symbols.space
                            
                                call a:1.add_section('airline_a', spc.'netrw'.spc)
                                if exists('*airline#extensions#branch#get_head')
                                  call a:1.add_section('airline_b', spc.'%{airline#extensions#branch#get_head()}'.spc)
                                endif
                                call a:1.add_section('airline_c', spc.'%f'.spc)
                                call a:1.split()
                                call a:1.add_section('airline_y', spc.'%{airline#extensions#netrw#sortstring()}'.spc)
                                return 1
    4              0.000002   endif

FUNCTION  airline#parts#iminsert()
    Defined: ~/.vimgo/plugged/vim-airline/autoload/airline/parts.vim:170
Called 97 times
Total time:   0.000406
 Self time:   0.000406

count  total (s)   self (s)
   97              0.000157   if g:airline_detect_iminsert && &iminsert && exists('b:keymap_name')
                                return toupper(b:keymap_name)
   97              0.000030   endif
   97              0.000056   return ''

FUNCTION  ale#lsp_linter#StartLSP()
    Defined: ~/.vimgo/plugged/ale/autoload/ale/lsp_linter.vim:429
Called 2 times
Total time:   0.092910
 Self time:   0.000047

count  total (s)   self (s)
    2              0.000002     let l:command = ''
    2              0.000001     let l:address = ''
    2   0.000419   0.000008     let l:root = ale#lsp_linter#FindProjectRoot(a:buffer, a:linter)
                            
    2              0.000003     if empty(l:root) && a:linter.lsp isnot# 'tsserver'
                                    " If there's no project root, then we can't check files with LSP,
                                    " unless we are using tsserver, which doesn't use project roots.
                                    call ale#lsp_linter#AddErrorMessage(a:linter.name, "Failed to find project root, language server won't start.")
                            
                                    return 0
    2              0.000000     endif
                            
    2              0.000006     let l:options = {   'buffer': a:buffer,   'linter': a:linter,   'callback': a:Callback,   'root': l:root,}
                            
    2              0.000002     if a:linter.lsp is# 'socket'
                                    let l:address = ale#linter#GetAddress(a:buffer, a:linter)
                            
                                    return s:StartWithAddress(l:options, l:address)
    2              0.000000     endif
                            
    2   0.000195   0.000005     let l:executable = ale#linter#GetExecutable(a:buffer, a:linter)
                            
    2   0.092270   0.000008     return s:StartIfExecutable(l:options, l:executable)

FUNCTION  airline#update_tabline()
    Defined: ~/.vimgo/plugged/vim-airline/autoload/airline.vim:301
Called 28 times
Total time:   0.000272
 Self time:   0.000272

count  total (s)   self (s)
   28              0.000157   if get(g:, 'airline_statusline_ontop', 0)
                                call airline#extensions#tabline#redraw()
   28              0.000024   endif

FUNCTION  airline#extensions#term#apply()
    Defined: ~/.vimgo/plugged/vim-airline/autoload/airline/extensions/term.vim:14
Called 4 times
Total time:   0.000111
 Self time:   0.000111

count  total (s)   self (s)
    4              0.000034   if &buftype ==? 'terminal' || bufname(a:2.bufnr)[0] ==? '!'
                                call a:1.add_section_spaced('airline_a', s:section_a)
                                call a:1.add_section_spaced('airline_b', s:neoterm_id(a:2.bufnr))
                                call a:1.add_section('airline_term', s:spc.s:termname(a:2.bufnr))
                                call a:1.split()
                                call a:1.add_section('airline_y', '')
                                call a:1.add_section_spaced('airline_z', s:section_z)
                                return 1
    4              0.000003   endif

FUNCTION  ale#handlers#tslint#GetExecutable()
    Defined: ~/.vimgo/plugged/ale/autoload/ale/handlers/tslint.vim:9
Called 1 time
Total time:   0.000130
 Self time:   0.000004

count  total (s)   self (s)
    1   0.000130   0.000004     return ale#path#FindExecutable(a:buffer, 'typescript_tslint', [   'node_modules/.bin/tslint',])

FUNCTION  coc#compat#execute()
    Defined: ~/.vimgo/plugged/coc.nvim/autoload/coc/compat.vim:190
Called 23 times
Total time:   0.033599
 Self time:   0.001315

count  total (s)   self (s)
   23              0.000027   if exists('*win_execute')
   23              0.000034     if type(a:command) == v:t_string
   20              0.000346       keepalt call win_execute(a:winid, a:command, get(a:, 1, ''))
    3              0.000003     elseif type(a:command) == v:t_list
    3   0.032743   0.000459       keepalt call win_execute(a:winid, join(a:command, "\n"), get(a:, 1, ''))
   23              0.000006     endif
                              elseif has('nvim')
                                if !nvim_win_is_valid(a:winid)
                                  return
                                endif
                                let curr = nvim_get_current_win()
                                noa keepalt call nvim_set_current_win(a:winid)
                                if type(a:command) == v:t_string
                                  exe get(a:, 1, '').' '.a:command
                                elseif type(a:command) == v:t_list
                                  for cmd in a:command
                                    exe get(a:, 1, '').' '.cmd
                                  endfor
                                endif
                                noa keepalt call nvim_set_current_win(curr)
                              else
                                throw 'win_execute does not exist, please upgrade vim.'
   23              0.000008   endif

FUNCTION  <SNR>176_hl_group_exists()
    Defined: ~/.vimgo/plugged/vim-airline/autoload/airline/highlighter.vim:99
Called 182 times
Total time:   0.001191
 Self time:   0.001191

count  total (s)   self (s)
  182              0.000315     if !hlexists(a:group)
                                  return 0
  182              0.000539     elseif empty(synIDattr(synIDtrans(hlID(a:group)), 'fg'))
                                  return 0
  182              0.000044     endif
  182              0.000067     return 1

FUNCTION  coc#float#get_related()
    Defined: ~/.vimgo/plugged/coc.nvim/autoload/coc/float.vim:903
Called 20 times
Total time:   0.001204
 Self time:   0.000186

count  total (s)   self (s)
   20   0.000269   0.000035   if coc#float#valid(a:winid)
   20   0.000842   0.000058     for winid in coc#window#get_var(a:winid, 'related', [])
                                  if coc#window#get_var(winid, 'kind', '') ==# a:kind
                                    return winid
                                  endif
   20              0.000007     endfor
   20              0.000008   endif
   20              0.000020   return get(a:, 1, 0)

FUNCTION  coc#float#get_float_by_kind()
    Defined: ~/.vimgo/plugged/coc.nvim/autoload/coc/float.vim:596
Called 19 times
Total time:   0.000274
 Self time:   0.000274

count  total (s)   self (s)
   19              0.000029   if s:is_vim
   19              0.000017     if s:popup_list_api
   19              0.000212       return get(filter(popup_list(), 'popup_getpos(v:val)["visible"] && getwinvar(v:val, "kind", "") ==# "'.a:kind.'"'), 0, 0)
                                endif
                                return get(filter(s:popup_list, 's:popup_visible(v:val) && getwinvar(v:val, "kind", "") ==# "'.a:kind.'"'), 0, 0)
                              else
                                let res = []
                                for i in range(1, winnr('$'))
                                  let winid = win_getid(i)
                                  let config = nvim_win_get_config(winid)
                                  if !empty(config['relative']) && getwinvar(winid, 'kind', '') ==# a:kind
                                    return winid
                                  endif
                                endfor
                              endif
                              return 0

FUNCTION  <SNR>80_getline()
    Defined: ~/.vimgo/plugged/auto-pairs/plugin/auto-pairs.vim:139
Called 5 times
Total time:   0.000223
 Self time:   0.000223

count  total (s)   self (s)
    5              0.000017   let line = getline('.')
    5              0.000015   let pos = col('.') - 1
    5              0.000018   let before = strpart(line, 0, pos)
    5              0.000012   let after = strpart(line, pos)
    5              0.000008   let afterline = after
    5              0.000007   if g:AutoPairsMultilineClose
    5              0.000014     let n = line('$')
    5              0.000008     let i = line('.')+1
    5              0.000014     while i <= n
    5              0.000018       let line = getline(i)
    5              0.000010       let after = after.' '.line
    5              0.000033       if !(line =~ '\v^\s*$')
    5              0.000005         break
                                  end
                                  let i = i+1
    5              0.000004     endwhile
    5              0.000003   end
    5              0.000012   return [before, after, afterline]

FUNCTION  <SNR>243_on_pum_change()
    Defined: ~/.vimgo/plugged/coc.nvim/autoload/coc/pum.vim:439
Called 17 times
Total time:   0.001952
 Self time:   0.000290

count  total (s)   self (s)
   17   0.000200   0.000023   if coc#float#valid(s:pum_winid)
   17              0.000012     if s:virtual_text
                                  call s:insert_virtual_text()
   17              0.000004     endif
   17   0.000573   0.000066     let ev = extend(coc#pum#info(), {'move': a:move ? v:true : v:false})
   17   0.001114   0.000136     call coc#rpc#notify('CocAutocmd', ['MenuPopupChanged', ev, win_screenpos(winnr())[0] + winline() - 2])
   17              0.000006   endif

FUNCTION  airline#extensions#coc#get()
    Defined: ~/.vimgo/plugged/vim-airline/autoload/airline/extensions/coc.vim:17
Called 8 times
Total time:   0.000073
 Self time:   0.000073

count  total (s)   self (s)
    8              0.000018   if !exists(':CocCommand') | return '' | endif
                            
    8              0.000008   let is_err = (a:type  is# 'error')
    8              0.000015   let info = get(b:, 'coc_diagnostic_info', {})
    8              0.000009   if empty(info) | return '' | endif
                            
    8              0.000012   let cnt = get(info, a:type, 0)
    8              0.000008   if empty(cnt) | return '' | endif
                            
                              let error_symbol = get(g:, 'airline#extensions#coc#error_symbol', 'E:')
                              let warning_symbol = get(g:, 'airline#extensions#coc#warning_symbol', 'W:')
                              let error_format = get(g:, 'airline#extensions#coc#stl_format_err', '%C(L%L)')
                              let warning_format = get(g:, 'airline#extensions#coc#stl_format_warn', '%C(L%L)')
                            
                              " replace %C with error count and %L with line number
                              return (is_err ? error_symbol : warning_symbol) . substitute(substitute(is_err ? error_format : warning_format, '%C', cnt, 'g'), '%L', (info.lnums)[is_err ? 0 : 1], 'g')

FUNCTION  <SNR>179_format_name()
    Defined: ~/.vimgo/plugged/vim-airline/autoload/airline/extensions/branch.vim:77
Called 4 times
Total time:   0.000006
 Self time:   0.000006

count  total (s)   self (s)
    4              0.000005     return a:name

FUNCTION  333()
    Defined: ~/.vimgo/plugged/coc.nvim/autoload/coc/api.vim:444
Called 2 times
Total time:   0.000020
 Self time:   0.000020

count  total (s)   self (s)
    2              0.000018   return getbufvar(a:bufnr, a:name)

FUNCTION  <SNR>59_record()
    Defined: ~/.vimgo/plugged/ctrlp.vim/autoload/ctrlp/mrufiles.vim:59
Called 7 times
Total time:   0.000074
 Self time:   0.000074

count  total (s)   self (s)
    7              0.000013 	if s:locked | retu | en
    7              0.000009 	let bufnr = a:bufnr + 0
    7              0.000012 	let bufname = bufname(bufnr)
    7              0.000011 	if bufnr > 0 && !empty(bufname)
                            		cal filter(s:mrbs, 'v:val != bufnr')
                            		cal insert(s:mrbs, bufnr)
                            		cal s:addtomrufs(bufname)
    7              0.000002 	en

FUNCTION  <SNR>221_GroupLoclistItems()
    Defined: ~/.vimgo/plugged/ale/autoload/ale/sign.vim:261
Called 1 time
Total time:   0.000009
 Self time:   0.000009

count  total (s)   self (s)
    1              0.000001     let l:grouped_items = []
    1              0.000000     let l:last_lnum = -1
                            
    1              0.000000     for l:obj in a:loclist
                                    if l:obj.bufnr != a:buffer
                                        continue
                                    endif
                            
                                    " Create a new sub-List when we hit a new line.
                                    if l:obj.lnum != l:last_lnum
                                        call add(l:grouped_items, [])
                                    endif
                            
                                    call add(l:grouped_items[-1], l:obj)
                                    let l:last_lnum = l:obj.lnum
    1              0.000001     endfor
                            
    1              0.000001     return l:grouped_items

FUNCTION  FugitiveActualDir()
    Defined: ~/.vimgo/plugged/vim-fugitive/plugin/fugitive.vim:273
Called 101 times
Total time:   0.004022
 Self time:   0.001480

count  total (s)   self (s)
  101   0.003007   0.000465   let dir = call('FugitiveGitDir', a:000)
  101              0.000111   if empty(dir)
                                return ''
  101              0.000038   endif
  101              0.000211   if !has_key(s:resolved_git_dirs, dir)
                                let s:resolved_git_dirs[dir] = s:ResolveGitDir(dir)
  101              0.000037   endif
  101              0.000310   return empty(s:resolved_git_dirs[dir]) ? dir : s:resolved_git_dirs[dir]

FUNCTION  airline#extensions#tabline#buflist#list()
    Defined: ~/.vimgo/plugged/vim-airline/autoload/airline/extensions/tabline/buflist.vim:39
Called 81 times
Total time:   0.000215
 Self time:   0.000215

count  total (s)   self (s)
   81              0.000123   if exists('s:current_buffer_list')
   81              0.000056     return s:current_buffer_list
                              endif
                            
                              let exclude_buffers = get(g:, 'airline#extensions#tabline#exclude_buffers', [])
                              let exclude_paths = get(g:, 'airline#extensions#tabline#excludes', [])
                              let exclude_preview = get(g:, 'airline#extensions#tabline#exclude_preview', 1)
                            
                              let list = (exists('g:did_bufmru') && g:did_bufmru) ? BufMRUList() : range(1, bufnr("$"))
                            
                              let buffers = []
                              " If this is too slow, we can switch to a different algorithm.
                              " Basically branch 535 already does it, but since it relies on
                              " BufAdd autocommand, I'd like to avoid this if possible.
                              for nr in list
                                if buflisted(nr)
                                  " Do not add to the bufferlist, if either
                                  " 1) bufnr is exclude_buffers list
                                  " 2) buffername matches one of exclude_paths patterns
                                  " 3) buffer is a quickfix buffer
                                  " 4) when excluding preview windows:
                                  "     'bufhidden' == wipe
                                  "     'buftype' == nofile
                                  " 5) ignore buffers matching airline#extensions#tabline#ignore_bufadd_pat
                            
                                  " check buffer numbers first
                                  if index(exclude_buffers, nr) >= 0
                                    continue
                                  " check paths second
                                  elseif !empty(exclude_paths) && s:ExcludePaths(nr, exclude_paths)
                                    continue
                                  " ignore buffers matching airline#extensions#tabline#ignore_bufadd_pat
                                  elseif airline#util#ignore_buf(bufname(nr))
                                    continue
                                  " check other types last
                                  elseif s:ExcludeOther(nr, exclude_preview)
                                    continue
                                  endif
                            
                                  call add(buffers, nr)
                                endif
                              endfor
                            
                              let s:current_buffer_list = buffers
                              return buffers

FUNCTION  <SNR>176_CheckDefined()
    Defined: ~/.vimgo/plugged/vim-airline/autoload/airline/highlighter.vim:108
Called 221 times
Total time:   0.002488
 Self time:   0.002488

count  total (s)   self (s)
                                " Checks, whether the definition of the colors is valid and is not empty or NONE
                                " e.g. if the colors would expand to this:
                                " hi airline_c ctermfg=NONE ctermbg=NONE
                                " that means to clear that highlighting group, therefore, fallback to Normal
                                " highlighting group for the cterm values
                            
                                " This only works, if the Normal highlighting group is actually defined, so
                                " return early, if it has been cleared
  221              0.000362     if !exists("g:airline#highlighter#normal_fg_hi")
                                  let g:airline#highlighter#normal_fg_hi = synIDattr(synIDtrans(hlID('Normal')), 'fg', 'cterm')
  221              0.000070     endif
  221              0.000357     if empty(g:airline#highlighter#normal_fg_hi) || g:airline#highlighter#normal_fg_hi < 0
                                  return a:colors
  221              0.000051     endif
                            
  221              0.000211     for val in a:colors
  221              0.000282       if !empty(val) && val !=# 'NONE'
  221              0.000141         return a:colors
                                  endif
                                endfor
                                " this adds the bold attribute to the term argument of the :hi command,
                                " but at least this makes sure, the group will be defined
                                let fg = g:airline#highlighter#normal_fg_hi
                                let bg = synIDattr(synIDtrans(hlID('Normal')), 'bg', 'cterm')
                                if empty(bg) || bg < 0
                                  " in case there is no background color defined for Normal
                                  let bg = a:colors[3]
                                endif
                                return a:colors[0:1] + [fg, bg] + [a:colors[4]]

FUNCTION  <SNR>193_get_seperator()
    Defined: ~/.vimgo/plugged/vim-airline/autoload/airline/builder.vim:155
Called 23 times
Total time:   0.012997
 Self time:   0.000170

count  total (s)   self (s)
   23   0.004150   0.000066   if airline#builder#should_change_group(a:prev_group, a:group)
   23   0.008841   0.000098     return s:get_transitioned_seperator(a:self, a:prev_group, a:group, a:side)
                              else
                                return a:side ? a:self._context.left_alt_sep : a:self._context.right_alt_sep
                              endif

FUNCTION  <SNR>230_execute()
    Defined: ~/.vimgo/plugged/coc.nvim/autoload/coc/api.vim:45
Called 23 times
Total time:   0.035368
 Self time:   0.035368

count  total (s)   self (s)
   23              0.000035   if a:cmd =~# '^echo'
                                execute a:cmd
   23              0.000008   else
   23              0.035265     silent! execute a:cmd
   23              0.000023   endif

FUNCTION  <SNR>202_GetAliasedFiletype()
    Defined: ~/.vimgo/plugged/ale/autoload/ale/linter.vim:300
Called 1 time
Total time:   0.000130
 Self time:   0.000130

count  total (s)   self (s)
    1              0.000012     let l:buffer_aliases = get(b:, 'ale_linter_aliases', {})
                            
                                " b:ale_linter_aliases can be set to a List or String.
    1              0.000015     if type(l:buffer_aliases) is v:t_list|| type(l:buffer_aliases) is v:t_string
                                    return l:buffer_aliases
    1              0.000001     endif
                            
                                " Check for aliased filetypes first in a buffer variable,
                                " then the global variable,
                                " then in the default mapping,
                                " otherwise use the original filetype.
    4              0.000022     for l:dict in [   l:buffer_aliases,   g:ale_linter_aliases,   s:default_ale_linter_aliases,]
    3              0.000020         if has_key(l:dict, a:original_filetype)
                                        return l:dict[a:original_filetype]
    3              0.000005         endif
    4              0.000009     endfor
                            
    1              0.000005     return a:original_filetype

FUNCTION  coc#highlight#add_highlights()
    Defined: ~/.vimgo/plugged/coc.nvim/autoload/coc/highlight.vim:339
Called 20 times
Total time:   0.087820
 Self time:   0.007169

count  total (s)   self (s)
   20              0.000033   if get(g:, 'coc_node_env', '') ==# 'test'
                                call setwinvar(a:winid, 'highlights', a:highlights)
   20              0.000005   endif
                              " clear highlights
   20   0.000824   0.000043   call coc#compat#execute(a:winid, 'syntax clear')
   20              0.000022   let bufnr = winbufnr(a:winid)
   20   0.000873   0.000055   call coc#highlight#clear_highlight(bufnr, -1, 0, -1)
   20              0.000018   if !empty(a:codes)
    3   0.032995   0.000012     call coc#highlight#highlight_lines(a:winid, a:codes)
   20              0.000005   endif
   20              0.000020   if !empty(a:highlights)
 1130              0.000453     for item in a:highlights
 1111              0.000859       let hlGroup = item['hlGroup']
 1111              0.001868       let opts = hlGroup =~# 'Search$' ? {'priority': 999, 'combine': 1} : {}
 1111   0.049198   0.003129       call coc#highlight#add_highlight(bufnr, -1, hlGroup, item['lnum'], item['colStart'], item['colEnd'])
 1130              0.000365     endfor
   20              0.000004   endif

FUNCTION  coc#api#get_types()
    Defined: ~/.vimgo/plugged/coc.nvim/autoload/coc/api.vim:658
Called 1 time
Total time:   0.000004
 Self time:   0.000004

count  total (s)   self (s)
    1              0.000003   return get(s:id_types, a:srcId, [])

FUNCTION  ale#linter#RemoveIgnored()
    Defined: ~/.vimgo/plugged/ale/autoload/ale/linter.vim:419
Called 1 time
Total time:   0.000106
 Self time:   0.000046

count  total (s)   self (s)
                                " Apply ignore lists for linters only if needed.
    1   0.000051   0.000013     let l:ignore_config = ale#Var(a:buffer, 'linters_ignore')
    1   0.000031   0.000009     let l:disable_lsp = ale#Var(a:buffer, 'disable_lsp')
                            
    1              0.000018     return !empty(l:ignore_config) || l:disable_lsp   ? ale#engine#ignore#Exclude(a:filetype, a:linters, l:ignore_config, l:disable_lsp)   : a:linters

FUNCTION  ale#ShouldDoNothing()
    Defined: ~/.vimgo/plugged/ale/autoload/ale.vim:32
Called 5 times
Total time:   0.000638
 Self time:   0.000457

count  total (s)   self (s)
                                " The checks are split into separate if statements to make it possible to
                                " profile each check individually with Vim's profiling tools.
                                "
                                " Do nothing if ALE is disabled.
    5              0.000027     if !getbufvar(a:buffer, 'ale_enabled', get(g:, 'ale_enabled', 0))
                                    return 1
    5              0.000003     endif
                            
                                " Don't perform any checks when newer NeoVim versions are exiting.
    5              0.000018     if get(v:, 'exiting', v:null) isnot v:null
                                    return 1
    5              0.000002     endif
                            
    5              0.000021     let l:filetype = getbufvar(a:buffer, '&filetype')
                            
                                " Do nothing when there's no filetype.
    5              0.000009     if l:filetype is# ''
                                    return 1
    5              0.000004     endif
                            
                                " Do nothing for diff buffers.
    5              0.000013     if getbufvar(a:buffer, '&diff')
                                    return 1
    5              0.000004     endif
                            
                                " Do nothing for blacklisted files.
    5              0.000031     if index(get(g:, 'ale_filetype_blacklist', []), l:filetype) >= 0
                                    return 1
    5              0.000002     endif
                            
                                " Do nothing if running from command mode.
    5              0.000024     if s:getcmdwintype_exists && !empty(getcmdwintype())
                                    return 1
    5              0.000002     endif
                            
    5              0.000024     let l:filename = fnamemodify(bufname(a:buffer), ':t')
                            
                                " Do nothing for directories.
    5              0.000006     if l:filename is# '.'
                                    return 1
    5              0.000001     endif
                            
                                " Don't start linting and so on when an operator is pending.
    5   0.000046   0.000023     if ale#util#Mode(1) is# 'no'
                                    return 1
    5              0.000003     endif
                            
                                " Do nothing if running in the sandbox.
    5   0.000119   0.000017     if ale#util#InSandbox()
                                    return 1
    5              0.000003     endif
                            
                                " Do nothing if the file is too large.
    5   0.000079   0.000023     if ale#FileTooLarge(a:buffer)
                                    return 1
    5              0.000005     endif
                            
                                " Do nothing from CtrlP buffers with CtrlP-funky.
    5              0.000062     if exists(':CtrlPFunky') is 2&& getbufvar(a:buffer, '&l:statusline') =~# 'CtrlPMode.*funky'
                                    return 1
    5              0.000004     endif
                            
    5              0.000002     return 0

FUNCTION  airline#extensions#ale#get_error()
    Defined: ~/.vimgo/plugged/vim-airline/autoload/airline/extensions/ale.vim:116
Called 4 times
Total time:   0.000223
 Self time:   0.000008

count  total (s)   self (s)
    4   0.000222   0.000007   return airline#extensions#ale#get('error')

FUNCTION  coc#pum#visible()
    Defined: ~/.vimgo/plugged/coc.nvim/autoload/coc/pum.vim:26
Called 3 times
Total time:   0.000015
 Self time:   0.000015

count  total (s)   self (s)
    3              0.000004   if !s:pum_winid
                                return 0
    3              0.000002   endif
    3              0.000006   return getwinvar(s:pum_winid, 'float', 0) == 1

FUNCTION  <SNR>193_section_is_empty()
    Defined: ~/.vimgo/plugged/vim-airline/autoload/airline/builder.vim:182
Called 49 times
Total time:   0.006207
 Self time:   0.002005

count  total (s)   self (s)
   49              0.000048   let start=1
                            
                              " do not check for inactive windows or the tabline
   49              0.000085   if a:self._context.active == 0
                                return 0
   49              0.000083   elseif get(a:self._context, 'tabline', 0)
   13              0.000007     return 0
   36              0.000010   endif
                            
                              " only check, if airline#skip_empty_sections == 1
   36              0.000056   if get(g:, 'airline_skip_empty_sections', 0) == 0
                                return 0
   36              0.000007   endif
                            
                              " only check, if airline#skip_empty_sections == 1
   36              0.000057   if get(w:, 'airline_skip_empty_sections', -1) == 0
                                return 0
   36              0.000008   endif
                            
                              " special case: When the content is %=, that is the
                              " separation marker, which switches between left- and
                              " right-aligned content.
                              " Consider that to be empty, so that the previous previous
                              " group is correctly remembered in the builder() function
   36              0.000064   if empty(a:content) || a:content is# '%='
    4              0.000002     return 1
   32              0.000009   endif
                            
   32              0.000287   let stripped = substitute(a:content, '\(%{.*}\|%#__accent_[^#]*#\|%#__restore__#\|%( \| %)\)', '', 'g')
                            
   32              0.000040   if !empty(stripped)
    8              0.000005     return 0 " There is content in the statusline
   24              0.000006   endif
                            
   24              0.000020   let exprlist = []
   24              0.000389   call substitute(a:content, '%{\([^}]*\)}', '\=add(exprlist, submatch(1))', 'g')
                            
   72              0.000054   for expr in exprlist
   64              0.000024     try
                                  " catch all exceptions, just in case
   64   0.004450   0.000248       if !empty(eval(expr))
   16              0.000009         return 0
   48              0.000012       endif
                                catch
                                  return 0
   64              0.000028     endtry
   56              0.000019   endfor
    8              0.000004   return 1

FUNCTION  <SNR>176_get_array()
    Defined: ~/.vimgo/plugged/vim-airline/autoload/airline/highlighter.vim:60
Called 485 times
Total time:   0.001377
 Self time:   0.001377

count  total (s)   self (s)
  485              0.001311     return [ a:guifg, a:guibg, a:ctermfg, a:ctermbg, empty(a:opts) ? '' : join(a:opts, ',') ]

FUNCTION  coc#highlight#buffer_update()
    Defined: ~/.vimgo/plugged/coc.nvim/autoload/coc/highlight.vim:22
Called 1 time
Total time:   0.001551
 Self time:   0.000131

count  total (s)   self (s)
    1              0.000003   if !bufloaded(a:bufnr)
                                return
    1              0.000001   endif
    1              0.000003   if empty(a:highlights)
                                call coc#highlight#clear_highlight(a:bufnr, a:key, 0, -1)
                                return
    1              0.000000   endif
    1              0.000005   let priority = get(a:, 1, v:null)
    1              0.000005   let changedtick = getbufvar(a:bufnr, 'changedtick', 0)
    1              0.000006   if type(get(a:, 2, v:null)) == 0 && changedtick > a:2
                                return
    1              0.000001   endif
    1              0.000078   let hls = map(copy(a:highlights), "{'hlGroup':v:val[0],'lnum':v:val[1],'colStart':v:val[2],'colEnd':v:val[3],'combine':get(v:val,4,1),'start_incl':get(v:val,5,0),'end_incl':get(v:val,6,0)}")
    1              0.000007   if len(hls) <= g:coc_highlight_maximum_count || get(g:, 'coc_node_env', '') ==# 'test'
    1   0.001431   0.000011     call coc#highlight#update_highlights(a:bufnr, a:key, hls, 0, -1, priority)
    1              0.000001     return
                              endif
                              let linecount = coc#compat#buf_line_count(a:bufnr)
                              let groups = s:group_hls(hls, linecount)
                              call s:update_highlights_timer(a:bufnr, changedtick, a:key, priority, groups, 0)

FUNCTION  <SNR>221_BuildSignMap()
    Defined: ~/.vimgo/plugged/ale/autoload/ale/sign.vim:307
Called 1 time
Total time:   0.000041
 Self time:   0.000033

count  total (s)   self (s)
    1   0.000010   0.000002     let l:max_signs = ale#Var(a:buffer, 'max_signs')
                            
    1              0.000001     if l:max_signs is 0
                                    let l:selected_grouped_items = []
    1              0.000002     elseif type(l:max_signs) is v:t_number && l:max_signs > 0
                                    let l:selected_grouped_items = a:grouped_items[:l:max_signs - 1]
    1              0.000001     else
    1              0.000001         let l:selected_grouped_items = a:grouped_items
    1              0.000000     endif
                            
    1              0.000001     let l:sign_map = {}
    1              0.000001     let l:sign_offset = g:ale_sign_offset
                            
    1              0.000001     for [l:line, l:sign_id, l:name] in a:current_sign_list
                                    let l:sign_info = get(l:sign_map, l:line, {   'current_id_list': [],   'current_name_list': [],   'new_id': 0,   'new_name': '',   'items': [],})
                            
                                    " Increment the sign offset for new signs, by the maximum sign ID.
                                    if l:sign_id > l:sign_offset
                                        let l:sign_offset = l:sign_id
                                    endif
                            
                                    " Remember the sign names and IDs in separate Lists, so they are easy
                                    " to work with.
                                    call add(l:sign_info.current_id_list, l:sign_id)
                                    call add(l:sign_info.current_name_list, l:name)
                            
                                    let l:sign_map[l:line] = l:sign_info
    1              0.000001     endfor
                            
    1              0.000001     for l:group in l:selected_grouped_items
                                    let l:line = l:group[0].lnum
                                    let l:sign_info = get(l:sign_map, l:line, {   'current_id_list': [],   'current_name_list': [],   'new_id': 0,   'new_name': '',   'items': [],})
                            
                                    let l:sign_info.new_name = ale#sign#GetSignName(l:group)
                                    let l:sign_info.items = l:group
                            
                                    let l:index = index(   l:sign_info.current_name_list,   l:sign_info.new_name)
                            
                                    if l:index >= 0
                                        " We have a sign with this name already, so use the same ID.
                                        let l:sign_info.new_id = l:sign_info.current_id_list[l:index]
                                    else
                                        " This sign name replaces the previous name, so use a new ID.
                                        let l:sign_info.new_id = l:sign_offset + 1
                                        let l:sign_offset += 1
                                    endif
                            
                                    let l:sign_map[l:line] = l:sign_info
    1              0.000001     endfor
                            
    1              0.000000     return l:sign_map

FUNCTION  <SNR>222_ShouldClose()
    Defined: ~/.vimgo/plugged/ale/autoload/ale/list.vim:50
Called 1 time
Total time:   0.000008
 Self time:   0.000004

count  total (s)   self (s)
    1   0.000005   0.000001     let l:val = ale#Var(a:buffer, 'open_list')
    1              0.000002     let l:saved = getbufvar(a:buffer, 'ale_save_event_fired', 0)
                            
    1              0.000001     return !((l:val >= 1) || (l:val is# 'on_save' && l:saved))

FUNCTION  <SNR>201_ApplyPartialTimer()
    Defined: ~/.vimgo/plugged/ale/autoload/ale/util.vim:447
Called 1 time
Total time:   0.000144
 Self time:   0.000010

count  total (s)   self (s)
    1              0.000002     if has_key(s:partial_timers, a:timer_id)
    1              0.000003         let [l:Callback, l:args] = remove(s:partial_timers, a:timer_id)
    1   0.000137   0.000003         call call(l:Callback, [a:timer_id] + l:args)
    1              0.000001     endif

FUNCTION  airline#util#winwidth()
    Defined: ~/.vimgo/plugged/vim-airline/autoload/airline/util.vim:19
Called 805 times
Total time:   0.005543
 Self time:   0.005543

count  total (s)   self (s)
  805              0.001348   let nr = get(a:000, 0, 0)
                              " When statusline is on top, or using global statusline for Neovim
                              " always return the number of columns
  805              0.001469   if get(g:, 'airline_statusline_ontop', 0) || &laststatus > 2
                                return &columns
  805              0.000304   else
  805              0.001060     return winwidth(nr)
                              endif

FUNCTION  <SNR>193_get_accented_line()
    Defined: ~/.vimgo/plugged/vim-airline/autoload/airline/builder.vim:163
Called 35 times
Total time:   0.001109
 Self time:   0.001109

count  total (s)   self (s)
   35              0.000036   if a:self._context.active
                                " active window
   35              0.000035     let contents = []
   35              0.000139     let content_parts = split(a:contents, '__accent')
   98              0.000071     for cpart in content_parts
   63              0.000170       let accent = matchstr(cpart, '_\zs[^#]*\ze')
   63              0.000087       call add(contents, cpart)
   98              0.000064     endfor
   35              0.000089     let line = join(contents, a:group)
   35              0.000136     let line = substitute(line, '__restore__', a:group, 'g')
                              else
                                " inactive window
                                let line = substitute(a:contents, '%#__accent[^#]*#', '', 'g')
                                let line = substitute(line, '%#__restore__#', '', 'g')
   35              0.000012   endif
   35              0.000026   return line

FUNCTION  325()
    Defined: ~/.vimgo/plugged/coc.nvim/autoload/coc/api.vim:275
Called 1115 times
Total time:   0.030039
 Self time:   0.026106

count  total (s)   self (s)
 1115              0.001550   if !has('patch-8.1.1719')
                                return
 1115              0.000282   endif
 1115              0.000515   if a:srcId == 0
                                let srcId = s:max_src_id + 1
                                let s:max_src_id = srcId
 1115              0.000251   else
 1115              0.000689     let srcId = a:srcId
 1115              0.000270   endif
 1115              0.001170   let bufnr = a:bufnr == 0 ? bufnr('%') : a:bufnr
 1115              0.001160   let type = srcId == -1 ? a:hlGroup : a:hlGroup.'_'.srcId
 1115              0.001941   let types = get(s:id_types, srcId, [])
 1115              0.001093   if index(types, type) == -1
   13              0.000016     call add(types, type)
   13              0.000022     let s:id_types[srcId] = types
   13              0.000026     if empty(prop_type_get(type))
   13              0.000067       call prop_type_add(type, extend({'highlight': a:hlGroup}, get(a:, 1, {})))
   13              0.000008     endif
 1115              0.000237   endif
 1115              0.001789   let end = a:colEnd == -1 ? strlen(getbufline(bufnr, a:line + 1)[0]) + 1 : a:colEnd + 1
 1115              0.000647   if end < a:colStart + 1
                                return
 1115              0.000244   endif
 1115   0.005738   0.001805   let id = s:generate_id(a:bufnr)
 1115              0.000339   try
 1115              0.002846     call prop_add(a:line + 1, a:colStart + 1, {'bufnr': bufnr, 'type': type, 'id': id, 'end_col': end})
                              catch /^Vim\%((\a\+)\)\=:E967/
                                " ignore 967
 1115              0.000351   endtry
 1115              0.000520   if a:srcId == 0
                                " return generated srcId
                                return srcId
 1115              0.000245   endif

FUNCTION  326()
    Defined: ~/.vimgo/plugged/coc.nvim/autoload/coc/api.vim:311
Called 22 times
Total time:   0.000569
 Self time:   0.000569

count  total (s)   self (s)
   22              0.000052   if !has('patch-8.1.1719')
                                return
   22              0.000008   endif
   22              0.000029   let bufnr = a:bufnr == 0 ? bufnr('%') : a:bufnr
   22              0.000025   let start = a:startLine + 1
   22              0.000098   let end = a:endLine == -1 ? len(getbufline(bufnr, 1, '$')) : a:endLine
   22              0.000012   if a:srcId == -1
   20              0.000030     if has_key(s:buffer_id, a:bufnr)
   18              0.000023       unlet s:buffer_id[a:bufnr]
   20              0.000008     endif
   20              0.000054     call prop_clear(start, end, {'bufnr' : bufnr})
    2              0.000001   else
    3              0.000014     for type in get(s:id_types, a:srcId, [])
    1              0.000000       try
    1              0.000013         call prop_remove({'bufnr': bufnr, 'all': 1, 'type': type}, start, end)
                                  catch /^Vim\%((\a\+)\)\=:E968/
                                    " ignore 968
    1              0.000001       endtry
    3              0.000003     endfor
   22              0.000007   endif

FUNCTION  coc#float#close()
    Defined: ~/.vimgo/plugged/coc.nvim/autoload/coc/float.vim:561
Called 7 times
Total time:   0.002180
 Self time:   0.000061

count  total (s)   self (s)
    7              0.000016   let noautocmd = get(a:, 1, 0)
    7   0.000815   0.000018   call coc#float#close_related(a:winid)
    7   0.001343   0.000021   call s:close_win(a:winid, noautocmd)
    7              0.000003   return 1

FUNCTION  airline#util#doautocmd()
    Defined: ~/.vimgo/plugged/vim-airline/autoload/airline/util.vim:178
Called 10 times
Total time:   0.000493
 Self time:   0.000201

count  total (s)   self (s)
   10              0.000036   if !exists('#airline') && a:event !=? 'AirlineToggledOff'
                                " airline disabled
                                return
   10              0.000006   endif
   10              0.000009   try
   10   0.000395   0.000103     exe printf("silent doautocmd %s User %s", s:nomodeline, a:event)
                              catch /^Vim\%((\a\+)\)\=:E48:/
                                " Catch: Sandbox mode
                                " no-op
   10              0.000009   endtry

FUNCTION  ale#handlers#xo#GetType()
    Defined: ~/.vimgo/plugged/ale/autoload/ale/handlers/xo.vim:35
Called 1 time
Total time:   0.000011
 Self time:   0.000011

count  total (s)   self (s)
    1              0.000003     let l:filetype = getbufvar(a:buffer, '&filetype')
    1              0.000001     let l:type = 'javascript'
                            
    1              0.000005     if l:filetype =~# 'typescript'
    1              0.000001         let l:type = 'typescript'
    1              0.000000     endif
                            
    1              0.000001     return l:type

FUNCTION  <SNR>230_win_execute()
    Defined: ~/.vimgo/plugged/coc.nvim/autoload/coc/api.vim:495
Called 37 times
Total time:   0.000353
 Self time:   0.000353

count  total (s)   self (s)
   37              0.000068     let ref = get(a:000, 0, v:null)
   37              0.000066     let cmd = ref is v:null ? a:cmd : 'let ref["out"] = ' . a:cmd
   37              0.000207     call win_execute(a:win_id, cmd)

FUNCTION  ale#handlers#tsserver#GetProjectRoot()
    Defined: ~/.vimgo/plugged/ale/autoload/ale/handlers/tsserver.vim:4
Called 1 time
Total time:   0.000059
 Self time:   0.000006

count  total (s)   self (s)
    1   0.000056   0.000003     let l:tsconfig_file = ale#path#FindNearestFile(a:buffer, 'tsconfig.json')
                            
    1              0.000003     return !empty(l:tsconfig_file) ? fnamemodify(l:tsconfig_file, ':h') : ''

FUNCTION  298()
    Defined: ~/.vimgo/plugged/coc.nvim/autoload/coc/api.vim:127
Called 23 times
Total time:   0.000356
 Self time:   0.000356

count  total (s)   self (s)
                              " command that could cause cursor vanish
   23              0.000095   if a:command =~# '^echo' || a:command =~# '^redraw' || a:command =~# '^sign place'
   23              0.000114     call timer_start(0, {-> s:execute(a:command)})
                              else
                                execute a:command
                                let err = get(g:, 'errmsg', '')
                                " get error from python script run.
                                if !empty(err)
                                  unlet g:errmsg
                                  throw err
                                endif
   23              0.000010   endif

FUNCTION  <SNR>194_add_section()
    Defined: ~/.vimgo/plugged/vim-airline/autoload/airline/extensions/default.vim:47
Called 32 times
Total time:   0.002663
 Self time:   0.000841

count  total (s)   self (s)
   32              0.000146     let condition = (a:key is# "warning" || a:key is# "error") && (v:version == 704 && !has("patch1511"))
                                " i have no idea why the warning section needs special treatment, but it's
                                " needed to prevent separators from showing up
   32   0.000486   0.000158     if ((a:key == 'error' || a:key == 'warning') && empty(s:get_section(a:context.winnr, a:key)))
                                  return
   32              0.000017     endif
   32              0.000034     if condition
                                  call a:builder.add_raw('%(')
   32              0.000018     endif
   32   0.001719   0.000225     call a:builder.add_section('airline_'.a:key, s:get_section(a:context.winnr, a:key))
   32              0.000029     if condition
                                  call a:builder.add_raw('%)')
   32              0.000020     endif

FUNCTION  334()
    Defined: ~/.vimgo/plugged/coc.nvim/autoload/coc/api.vim:448
Called 1 time
Total time:   0.000011
 Self time:   0.000011

count  total (s)   self (s)
    1              0.000005   if !bufloaded(a:bufnr) | return | endif
    1              0.000006   call setbufvar(a:bufnr, a:name, a:val)

FUNCTION  coc#dialog#place_sign()
    Defined: ~/.vimgo/plugged/coc.nvim/autoload/coc/dialog.vim:581
Called 17 times
Total time:   0.000131
 Self time:   0.000131

count  total (s)   self (s)
   17              0.000055   call sign_unplace(s:sign_group, { 'buffer': a:bufnr })
   17              0.000012   if a:line > 0
   17              0.000054     call sign_place(6, s:sign_group, 'CocCurrentLine', a:bufnr, {'lnum': a:line})
   17              0.000005   endif

FUNCTION  343()
    Defined: ~/.vimgo/plugged/coc.nvim/autoload/coc/api.vim:530
Called 37 times
Total time:   0.000795
 Self time:   0.000246

count  total (s)   self (s)
   37   0.000670   0.000121   let tabnr = s:get_tabnr(a:win_id)
   37              0.000019   if tabnr
   37              0.000094     return gettabwinvar(tabnr, a:win_id, a:name, get(a:, 1, v:null))
                              endif
                              throw 'window '.a:win_id. ' not a visible window'

FUNCTION  <SNR>223_StopCursorTimer()
    Defined: ~/.vimgo/plugged/ale/autoload/ale/cursor.vim:65
Called 5 times
Total time:   0.000046
 Self time:   0.000046

count  total (s)   self (s)
    5              0.000014     if s:cursor_timer != -1
    1              0.000002         call timer_stop(s:cursor_timer)
    1              0.000001         let s:cursor_timer = -1
    5              0.000003     endif

FUNCTION  <SNR>181_ale_refresh()
    Defined: ~/.vimgo/plugged/vim-airline/autoload/airline/extensions/ale.vim:130
Called 4 times
Total time:   0.025997
 Self time:   0.000112

count  total (s)   self (s)
    4              0.000017   if !exists('#airline')
                                " airline disabled
                                return
    4              0.000003   endif
    4              0.000016   if get(g:, 'airline_skip_empty_sections', 0)
    4   0.025944   0.000059     exe ':AirlineRefresh!'
    4              0.000002   endif

FUNCTION  ale#sign#GetSignCommands()
    Defined: ~/.vimgo/plugged/ale/autoload/ale/sign.vim:376
Called 1 time
Total time:   0.000029
 Self time:   0.000029

count  total (s)   self (s)
    1              0.000001     let l:command_list = []
    1              0.000001     let l:is_dummy_sign_set = a:was_sign_set
                            
                                " Set the dummy sign if we need to.
                                " The dummy sign is needed to keep the sign column open while we add
                                " and remove signs.
    1              0.000002     if !l:is_dummy_sign_set && (!empty(a:sign_map) || g:ale_sign_column_always)
                                    call add(l:command_list, 'sign place '   .  g:ale_sign_offset   . s:GroupCmd()   . s:PriorityCmd()   . ' line=1 name=ALEDummySign '   . ' buffer=' . a:buffer)
                                    let l:is_dummy_sign_set = 1
    1              0.000000     endif
                            
                                " Place new items first.
    1              0.000002     for [l:line_str, l:info] in items(a:sign_map)
                                    if l:info.new_id
                                        " Save the sign IDs we are setting back on our loclist objects.
                                        " These IDs will be used to preserve items which are set many times.
                                        for l:item in l:info.items
                                            let l:item.sign_id = l:info.new_id
                                        endfor
                            
                                        if index(l:info.current_id_list, l:info.new_id) < 0
                                            call add(l:command_list, 'sign place '   . (l:info.new_id)   . s:GroupCmd()   . s:PriorityCmd()   . ' line=' . l:line_str   . ' name=' . (l:info.new_name)   . ' buffer=' . a:buffer)
                                        endif
                                    endif
    1              0.000000     endfor
                            
                                " Remove signs without new IDs.
    1              0.000002     for l:info in values(a:sign_map)
                                    for l:current_id in l:info.current_id_list
                                        if l:current_id isnot l:info.new_id
                                            call add(l:command_list, 'sign unplace '   . l:current_id   . s:GroupCmd()   . ' buffer=' . a:buffer)
                                        endif
                                    endfor
    1              0.000001     endfor
                            
                                " Remove the dummy sign to close the sign column if we need to.
    1              0.000001     if l:is_dummy_sign_set && !g:ale_sign_column_always
                                    call add(l:command_list, 'sign unplace '   . g:ale_sign_offset   . s:GroupCmd()   . ' buffer=' . a:buffer)
    1              0.000000     endif
                            
    1              0.000001     return l:command_list

FUNCTION  airline#extensions#tabline#tabs#map_keys()
    Defined: ~/.vimgo/plugged/vim-airline/autoload/airline/extensions/tabline/tabs.vim:112
Called 39 times
Total time:   0.000950
 Self time:   0.000950

count  total (s)   self (s)
   39              0.000909   if maparg('<Plug>AirlineSelectTab1', 'n') is# ':1tabn<CR>'
   39              0.000021     return
                              endif
                              let bidx_mode = get(g:, 'airline#extensions#tabline#buffer_idx_mode', 1)
                              if bidx_mode == 1
                                for i in range(1, 10)
                                  exe printf('noremap <silent> <Plug>AirlineSelectTab%d :%dtabn<CR>', i%10, i)
                                endfor
                              else
                                  for i in range(11, 99)
                                    exe printf('noremap <silent> <Plug>AirlineSelectTab%d :%dtabn<CR>', i, i-10)
                                  endfor
                                endif
                              noremap <silent> <Plug>AirlineSelectPrevTab gT
                              " tabn {count} goes to count tab does not go {count} tab pages forward!
                              noremap <silent> <Plug>AirlineSelectNextTab :<C-U>exe repeat(':tabn\|', v:count1)<cr>

FUNCTION  <SNR>67_on_cursor_moved()
    Defined: ~/.vimgo/plugged/vim-airline/plugin/airline.vim:87
Called 2 times
Total time:   0.000020
 Self time:   0.000013

count  total (s)   self (s)
    2              0.000006   if winnr() != s:active_winnr || !exists('w:airline_active')
                                call s:on_window_changed('CursorMoved')
    2              0.000001   endif
    2   0.000009   0.000002   call airline#update_tabline()

FUNCTION  coc#highlight#get_highlights()
    Defined: ~/.vimgo/plugged/coc.nvim/autoload/coc/highlight.vim:145
Called 1 time
Total time:   0.000107
 Self time:   0.000103

count  total (s)   self (s)
    1              0.000002   if !bufloaded(a:bufnr)
                                return v:null
    1              0.000000   endif
    1              0.000003   if !has_key(s:namespace_map, a:key)
                                return []
    1              0.000001   endif
    1              0.000003   let start = get(a:, 1, 0)
    1              0.000002   let end = get(a:, 2, -1)
    1              0.000005   if has('nvim-0.5.0')
                                return v:lua.require('coc.highlight').getHighlights(a:bufnr, a:key, start, end)
    1              0.000001   endif
    1              0.000002   let res = []
    1              0.000002   let ns = s:namespace_map[a:key]
    1              0.000003   if exists('*prop_list')
    1   0.000009   0.000005     let types = coc#api#get_types(ns)
    1              0.000002     if empty(types)
                                  return res
    1              0.000000     endif
                                " Could filter by end_lnum and types
    1              0.000003     if has('patch-8.2.3652')
    1              0.000002       let endLnum = end == -1 ? -1 : end + 1
    1              0.000008       for prop in prop_list(start + 1, {'bufnr': a:bufnr, 'types': types, 'end_lnum': endLnum})
                                    if prop['start'] == 0 || prop['end'] == 0
                                      " multi line textprop are not supported, simply ignore it
                                      continue
                                    endif
                                    let startCol = prop['col'] - 1
                                    let endCol = startCol + prop['length']
                                    call add(res, [s:prop_type_hlgroup(prop['type']), prop['lnum'] - 1, startCol, endCol, prop['id']])
    1              0.000001       endfor
                                else
                                  if end == -1
                                    let end = coc#compat#buf_line_count(a:bufnr)
                                  else
                                    let end = end + 1
                                  endif
                                  for line in range(start + 1, end)
                                    for prop in prop_list(line, {'bufnr': a:bufnr})
                                      if index(types, prop['type']) == -1 || prop['start'] == 0 || prop['end'] == 0
                                        " multi line textprop are not supported, simply ignore it
                                        continue
                                      endif
                                      let startCol = prop['col'] - 1
                                      let endCol = startCol + prop['length']
                                      call add(res, [s:prop_type_hlgroup(prop['type']), line - 1, startCol, endCol, prop['id']])
                                    endfor
                                  endfor
    1              0.000000     endif
                              else
                                throw 'Get highlights requires neovim 0.5.0 or vim support prop_list'
    1              0.000000   endif
    1              0.000001   return res

FUNCTION  ale#engine#InitBufferInfo()
    Defined: ~/.vimgo/plugged/ale/autoload/ale/engine.vim:82
Called 1 time
Total time:   0.000029
 Self time:   0.000029

count  total (s)   self (s)
    1              0.000006     if !has_key(g:ale_buffer_info, a:buffer)
                                    " active_linter_list will hold the list of active linter names
                                    " loclist holds the loclist items after all jobs have completed.
                                    let g:ale_buffer_info[a:buffer] = {   'active_linter_list': [],   'active_other_sources_list': [],   'loclist': [],}
                            
                                    return 1
    1              0.000002     endif
                            
    1              0.000002     return 0

FUNCTION  ale#statusline#Count()
    Defined: ~/.vimgo/plugged/ale/autoload/ale/statusline.vim:119
Called 8 times
Total time:   0.000138
 Self time:   0.000026

count  total (s)   self (s)
                                " The Dictionary is copied here before exposing it to other plugins.
    8   0.000135   0.000023     return copy(s:GetCounts(a:buffer))

FUNCTION  <SNR>202_GetLinterNames()
    Defined: ~/.vimgo/plugged/ale/autoload/ale/linter.vim:336
Called 1 time
Total time:   0.000092
 Self time:   0.000092

count  total (s)   self (s)
    1              0.000010     let l:buffer_ale_linters = get(b:, 'ale_linters', {})
                            
                                " b:ale_linters can be set to 'all'
    1              0.000005     if l:buffer_ale_linters is# 'all'
                                    return 'all'
    1              0.000001     endif
                            
                                " b:ale_linters can be set to a List.
    1              0.000006     if type(l:buffer_ale_linters) is v:t_list
                                    return l:buffer_ale_linters
    1              0.000001     endif
                            
                                " Try to get a buffer-local setting for the filetype
    1              0.000008     if has_key(l:buffer_ale_linters, a:original_filetype)
                                    return l:buffer_ale_linters[a:original_filetype]
    1              0.000001     endif
                            
                                " Try to get a global setting for the filetype
    1              0.000006     if has_key(g:ale_linters, a:original_filetype)
                                    return g:ale_linters[a:original_filetype]
    1              0.000001     endif
                            
                                " If the user has configured ALE to only enable linters explicitly, then
                                " don't enable any linters by default.
    1              0.000003     if g:ale_linters_explicit
                                    return []
    1              0.000001     endif
                            
                                " Try to get a default setting for the filetype
    1              0.000008     if has_key(s:default_ale_linters, a:original_filetype)
                                    return s:default_ale_linters[a:original_filetype]
    1              0.000002     endif
                            
    1              0.000003     return 'all'

FUNCTION  <SNR>102_IsInString()
    Defined: ~/.vimgo/plugged/yats.vim/indent/typescript.vim:73
Called 4 times
Total time:   0.000304
 Self time:   0.000304

count  total (s)   self (s)
    4              0.000302   return synIDattr(synID(a:lnum, a:col, 1), 'name') =~ s:syng_string

FUNCTION  airline#extensions#tabline#add_label()
    Defined: ~/.vimgo/plugged/vim-airline/autoload/airline/extensions/tabline.vim:30
Called 1 time
Total time:   0.000041
 Self time:   0.000020

count  total (s)   self (s)
    1              0.000004   if get(g:, 'airline#extensions#tabline#show_tab_type', 1)
    1   0.000035   0.000014     call a:dict.add_section_spaced('airline_tablabel'. (a:right ? '_right' : ''), get(g:, 'airline#extensions#tabline#'.a:type.'_label', a:type))
    1              0.000001   endif

FUNCTION  coc#util#do_autocmd()
    Defined: ~/.vimgo/plugged/coc.nvim/autoload/coc/util.vim:362
Called 8 times
Total time:   0.000076
 Self time:   0.000076

count  total (s)   self (s)
    8              0.000062   if exists('#User#'.a:name)
                                exe 'doautocmd <nomodeline> User '.a:name
    8              0.000001   endif

FUNCTION  airline#extensions#default#apply()
    Defined: ~/.vimgo/plugged/vim-airline/autoload/airline/extensions/default.vim:79
Called 4 times
Total time:   0.003499
 Self time:   0.000211

count  total (s)   self (s)
    4              0.000012   let winnr = a:context.winnr
    4              0.000009   let active = a:context.active
                            
    4   0.000043   0.000026   if airline#util#getwinvar(winnr, 'airline_render_left', active || (!active && !g:airline_inactive_collapse))
    4   0.001186   0.000032     call s:build_sections(a:builder, a:context, s:layout[0])
                              else
                                let text = !empty(s:get_section(winnr, 'c')) ? s:get_section(winnr, 'c') : ' %f%m '
                                call a:builder.add_section('airline_c'.(a:context.bufnr), text)
    4              0.000003   endif
                            
    4   0.000187   0.000033   call a:builder.split(s:get_section(winnr, 'gutter', '', ''))
                            
    4   0.000029   0.000017   if airline#util#getwinvar(winnr, 'airline_render_right', 1)
    4   0.001974   0.000023     call s:build_sections(a:builder, a:context, s:layout[1])
    4              0.000004   endif
                            
    4              0.000002   return 1

FUNCTION  <SNR>73_Autocmd()
    Defined: ~/.vimgo/plugged/coc.nvim/plugin/coc.vim:280
Called 150 times
Total time:   0.015601
 Self time:   0.001647

count  total (s)   self (s)
  150              0.000606   if !get(g:, 'coc_workspace_initialized', 0)
                                return
  150              0.000102   endif
  150   0.014597   0.000643   call coc#rpc#notify('CocAutocmd', a:000)

FUNCTION  ale#FileTooLarge()
    Defined: ~/.vimgo/plugged/ale/autoload/ale.vim:24
Called 5 times
Total time:   0.000056
 Self time:   0.000056

count  total (s)   self (s)
    5              0.000029     let l:max = getbufvar(a:buffer, 'ale_maximum_file_size', get(g:, 'ale_maximum_file_size', 0))
                            
    5              0.000023     return l:max > 0 ? (line2byte(line('$') + 1) > l:max) : 0

FUNCTION  <SNR>243_index_to_lnum()
    Defined: ~/.vimgo/plugged/coc.nvim/autoload/coc/pum.vim:449
Called 17 times
Total time:   0.000087
 Self time:   0.000087

count  total (s)   self (s)
   17              0.000012   if s:reversed
                                if a:index <= 0
                                  return s:pum_size
                                endif
                                return s:pum_size - a:index
   17              0.000003   endif
   17              0.000026   return max([1, a:index + 1])

FUNCTION  airline#util#stl_disabled()
    Defined: ~/.vimgo/plugged/vim-airline/autoload/airline/util.vim:196
Called 8 times
Total time:   0.000268
 Self time:   0.000167

count  total (s)   self (s)
                              " setting the statusline is disabled,
                              " either globally, per window, or per buffer
                              " w:airline_disabled is deprecated!
    8   0.000247   0.000146   return get(g:, 'airline_disable_statusline', 0) || airline#util#getwinvar(a:winnr, 'airline_disable_statusline', 0) || airline#util#getwinvar(a:winnr, 'airline_disabled', 0) || airline#util#getbufvar(winbufnr(a:winnr), 'airline_disable_statusline', 0)

FUNCTION  coc#string#character_index()
    Defined: ~/.vimgo/plugged/coc.nvim/autoload/coc/string.vim:8
Called 3 times
Total time:   0.000006
 Self time:   0.000006

count  total (s)   self (s)
    3              0.000003   if a:byteIdx <= 0
    3              0.000001     return 0
                              endif
                              let i = 0
                              for char in split(strpart(a:line, 0, a:byteIdx), '\zs')
                                let i += char2nr(char) > 65535 ? 2 : 1
                              endfor
                              return i

FUNCTION  coc#api#call()
    Defined: ~/.vimgo/plugged/coc.nvim/autoload/coc/api.vim:682
Called 85 times
Total time:   0.074648
 Self time:   0.002012

count  total (s)   self (s)
   85              0.000489   let err = v:null
   85              0.000107   let res = v:null
   85              0.000092   try
   85   0.073284   0.000648     let res = call(s:funcs[a:method], a:args)
                              catch /.*/
                                let err = v:exception .' on api "'.a:method.'" '.json_encode(a:args)
   85              0.000089   endtry
   85              0.000132   return [err, res]

FUNCTION  ale#sign#ParseSignsWithGetPlaced()
    Defined: ~/.vimgo/plugged/ale/autoload/ale/sign.vim:205
Called 1 time
Total time:   0.000017
 Self time:   0.000017

count  total (s)   self (s)
    1              0.000007     let l:signs = sign_getplaced(a:buffer, { 'group': s:supports_sign_groups ? 'ale' : '' })[0].signs
    1              0.000001     let l:result = []
    1              0.000001     let l:is_dummy_sign_set = 0
                            
    1              0.000001     for l:sign in l:signs
                                    if l:sign['name'] is# 'ALEDummySign'
                                        let l:is_dummy_sign_set = 1
                                    else
                                        call add(l:result, [   str2nr(l:sign['lnum']),   str2nr(l:sign['id']),   l:sign['name'],])
                                    endif
    1              0.000000     endfor
                            
    1              0.000001     return [l:is_dummy_sign_set, l:result]

FUNCTION  airline#extensions#tabline#formatters#tabnr#format()
    Defined: ~/.vimgo/plugged/vim-airline/autoload/airline/extensions/tabline/formatters/tabnr.vim:6
Called 1 time
Total time:   0.000004
 Self time:   0.000004

count  total (s)   self (s)
    1              0.000002   let spc=g:airline_symbols.space
    1              0.000000   if a:tab_nr_type == 0 " nr of splits
    1              0.000002     return spc. '%{len(tabpagebuflist('.a:nr.'))}'
                              elseif a:tab_nr_type == 1 " tab number
                                return spc. a:nr
                              else "== 2 splits and tab number
                                return spc. a:nr. '.%{len(tabpagebuflist('.a:nr.'))}'
                              endif

FUNCTION  ale#engine#IsCheckingBuffer()
    Defined: ~/.vimgo/plugged/ale/autoload/ale/engine.vim:101
Called 11 times
Total time:   0.000081
 Self time:   0.000081

count  total (s)   self (s)
   11              0.000028     let l:info = get(g:ale_buffer_info, a:buffer, {})
                            
   11              0.000045     return !empty(get(l:info, 'active_linter_list', []))   || !empty(get(l:info, 'active_other_sources_list', []))

FUNCTION  airline#highlighter#add_separator()
    Defined: ~/.vimgo/plugged/vim-airline/autoload/airline/highlighter.vim:184
Called 29 times
Total time:   0.010417
 Self time:   0.000210

count  total (s)   self (s)
   29              0.000090     let s:separators[a:from.a:to] = [a:from, a:to, a:inverse]
   29   0.010320   0.000113     call <sid>exec_separator({}, a:from, a:to, a:inverse, '')

FUNCTION  FugitiveGitDir()
    Defined: ~/.vimgo/plugged/vim-fugitive/plugin/fugitive.vim:18
Called 202 times
Total time:   0.005712
 Self time:   0.005712

count  total (s)   self (s)
  202              0.000239   if v:version < 704
                                return ''
  202              0.000574   elseif !a:0 || type(a:1) == type(0) && a:1 < 0 || a:1 is# get(v:, 'true', -1)
  202              0.000308     if exists('g:fugitive_event')
                                  return g:fugitive_event
  202              0.000089     endif
  202              0.000392     let dir = get(b:, 'git_dir', '')
  202              0.000502     if empty(dir) && (empty(bufname('')) || &buftype =~# '^\%(nofile\|acwrite\|quickfix\|terminal\|prompt\)$')
                                  return FugitiveExtractGitDir(getcwd())
  202              0.001299     elseif (!exists('b:git_dir') || b:git_dir =~# s:bad_git_dir) && &buftype =~# '^\%(nowrite\)\=$'
                                  let b:git_dir = FugitiveExtractGitDir(bufnr(''))
                                  return b:git_dir
  202              0.000071     endif
  202              0.000878     return dir =~# s:bad_git_dir ? '' : dir
                              elseif type(a:1) == type(0) && a:1 isnot# 0
                                if a:1 == bufnr('') && (!exists('b:git_dir') || b:git_dir =~# s:bad_git_dir) && &buftype =~# '^\%(nowrite\)\=$'
                                  let b:git_dir = FugitiveExtractGitDir(a:1)
                                endif
                                let dir = getbufvar(a:1, 'git_dir')
                                return dir =~# s:bad_git_dir ? '' : dir
                              elseif type(a:1) == type('')
                                return substitute(s:Slash(a:1), '/$', '', '')
                              elseif type(a:1) == type({})
                                return get(a:1, 'fugitive_dir', get(a:1, 'git_dir', ''))
                              else
                                return ''
                              endif

FUNCTION  CocActionAsync()
    Defined: ~/.vimgo/plugged/coc.nvim/plugin/coc.vim:108
Called 3 times
Total time:   0.000902
 Self time:   0.000068

count  total (s)   self (s)
    3   0.000897   0.000063   return s:AsyncRequest(a:name, a:000)

FUNCTION  coc#string#content_height()
    Defined: ~/.vimgo/plugged/coc.nvim/autoload/coc/string.vim:77
Called 3 times
Total time:   0.000736
 Self time:   0.000736

count  total (s)   self (s)
    3              0.000002   let len = 0
    3              0.000024   let pattern = empty(&breakat) ? '.\zs' : '['.substitute(&breakat, '\([\[\]]\)', '\\\1', 'g').']\zs'
   18              0.000010   for line in a:lines
   15              0.000017     if strwidth(line) <= a:width
   14              0.000009       let len += 1
    1              0.000001     else
    1              0.000000       let currlen = 0
   61              0.000033       for part in split(line, pattern)
   60              0.000043         let wl = strwidth(part)
   60              0.000038         if currlen == 0 && wl > 0
    1              0.000000           let len += 1
   60              0.000016         endif
   60              0.000036         let delta = currlen + wl - a:width
   60              0.000024         if delta >= 0
    4              0.000003           let len = len + (delta > 0)
    4              0.000002           let currlen = delta == 0 ? 0 : wl
    4              0.000003           if wl >= a:width
                                        let currlen = wl%a:width
                                        let len += float2nr(ceil(wl/(a:width + 0.0))) - (currlen == 0)
    4              0.000000           endif
   56              0.000009         else
   56              0.000034           let currlen = currlen + wl
   60              0.000010         endif
   61              0.000013       endfor
   15              0.000003     endif
   18              0.000013   endfor
    3              0.000001   return len

FUNCTION  airline#extensions#ale#get()
    Defined: ~/.vimgo/plugged/vim-airline/autoload/airline/extensions/ale.vim:77
Called 8 times
Total time:   0.000504
 Self time:   0.000260

count  total (s)   self (s)
    8              0.000014   if !exists(':ALELint')
                                return ''
    8              0.000003   endif
                            
    8              0.000012   let error_symbol = get(g:, 'airline#extensions#ale#error_symbol', 'E:')
    8              0.000012   let warning_symbol = get(g:, 'airline#extensions#ale#warning_symbol', 'W:')
    8              0.000009   let checking_symbol = get(g:, 'airline#extensions#ale#checking_symbol', '...')
    8              0.000012   let show_line_numbers = get(g:, 'airline#extensions#ale#show_line_numbers', 1)
                            
    8              0.000007   let is_err = a:type ==# 'error'
                            
    8   0.000063   0.000018   if ale#engine#IsCheckingBuffer(bufnr('')) == 1
                                return is_err ? '' : checking_symbol
    8              0.000001   endif
                            
    8              0.000010   let symbol = is_err ? error_symbol : warning_symbol
                            
    8   0.000155   0.000017   let counts = ale#statusline#Count(bufnr(''))
    8              0.000046   if type(counts) == type({}) && has_key(counts, 'error')
                                " Use the current Dictionary format.
    8              0.000009     let errors = counts.error + counts.style_error
    8              0.000011     let num = is_err ? errors : counts.total - errors
                              else
                                " Use the old List format.
                                let num = is_err ? counts[0] : counts[1]
    8              0.000004   endif
                            
    8              0.000005   if show_line_numbers == 1
    8   0.000092   0.000031     return s:airline_ale_count(num, symbol) . <sid>airline_ale_get_line_number(num, a:type)
                              else
                                return s:airline_ale_count(num, symbol)
                              endif

FUNCTION  ale#statusline#Update()
    Defined: ~/.vimgo/plugged/ale/autoload/ale/statusline.vim:21
Called 1 time
Total time:   0.000041
 Self time:   0.000037

count  total (s)   self (s)
    1              0.000003     if !exists('g:ale_buffer_info') || !has_key(g:ale_buffer_info, a:buffer)
                                    return
    1              0.000000     endif
                            
    1              0.000002     let l:loclist = filter(copy(a:loclist), 'v:val.bufnr == a:buffer')
    1   0.000007   0.000003     let l:count = s:CreateCountDict()
    1              0.000001     let l:count.total = len(l:loclist)
                            
                                " Allows easy access to the first instance of each problem type.
    1              0.000001     let l:first_problems = {}
                            
    1              0.000000     for l:entry in l:loclist
                                    if l:entry.type is# 'W'
                                        if get(l:entry, 'sub_type', '') is# 'style'
                                            let l:count.style_warning += 1
                            
                                            if l:count.style_warning == 1
                                                let l:first_problems.style_warning = l:entry
                                            endif
                                        else
                                            let l:count.warning += 1
                            
                                            if l:count.warning == 1
                                                let l:first_problems.warning = l:entry
                                            endif
                                        endif
                                    elseif l:entry.type is# 'I'
                                        let l:count.info += 1
                            
                                        if l:count.info == 1
                                            let l:first_problems.info = l:entry
                                        endif
                                    elseif get(l:entry, 'sub_type', '') is# 'style'
                                        let l:count.style_error += 1
                            
                                        if l:count.style_error == 1
                                            let l:first_problems.style_error = l:entry
                                        endif
                                    else
                                        let l:count.error += 1
                            
                                        if l:count.error == 1
                                            let l:first_problems.error = l:entry
                                        endif
                                    endif
    1              0.000001     endfor
                            
                                " Set keys for backwards compatibility.
    1              0.000002     let l:count[0] = l:count.error + l:count.style_error
    1              0.000001     let l:count[1] = l:count.total - l:count[0]
                            
    1              0.000002     let g:ale_buffer_info[a:buffer].count = l:count
    1              0.000002     let g:ale_buffer_info[a:buffer].first_problems = l:first_problems

FUNCTION  <SNR>197_GetLintFileSlots()
    Defined: ~/.vimgo/plugged/ale/autoload/ale/engine.vim:601
Called 1 time
Total time:   0.000408
 Self time:   0.000408

count  total (s)   self (s)
    1              0.000005     let l:linter_slots = []
                            
    9              0.000025     for l:linter in a:linters
    8              0.000032         let l:LintFile = l:linter.lint_file
                            
    8              0.000193         if type(l:LintFile) is v:t_func
                                        let l:LintFile = l:LintFile(a:buffer)
    8              0.000011         endif
                            
    8              0.000053         call add(l:linter_slots, [l:LintFile, l:linter])
    9              0.000014     endfor
                            
    1              0.000004     return l:linter_slots

FUNCTION  airline#util#wrap()
    Defined: ~/.vimgo/plugged/vim-airline/autoload/airline/util.vim:44
Called 719 times
Total time:   0.003678
 Self time:   0.002513

count  total (s)   self (s)
  719   0.002351   0.001186   if a:minwidth > 0 && airline#util#winwidth() < a:minwidth
                                return ''
  719              0.000216   endif
  719              0.000527   return a:text

FUNCTION  280()
    Defined: ~/.vimgo/plugged/vim-airline/autoload/airline/extensions/tabline/builder.vim:41
Called 1 time
Total time:   0.000153
 Self time:   0.000023

count  total (s)   self (s)
    1   0.000026   0.000002   let title = self.get_title(a:index)
    1   0.000107   0.000004   let title_size = s:tabline_evaluated_length(title) + a:sep_size
    1              0.000001   if a:force || self._remaining_space >= title_size
    1              0.000001     let pos = a:pos
    1              0.000001     if has_key(self, "get_pretitle")
                                  call self.insert_raw(self.get_pretitle(a:index), pos)
                                  let self._right_position += 1
                                  let pos += 1
    1              0.000000     endif
                            
    1   0.000006   0.000003     call self.insert_section(a:group, title, pos)
    1              0.000001     let self._right_position += 1
    1              0.000000     let pos += 1
                            
    1              0.000001     if has_key(self, "get_posttitle")
                                  call self.insert_raw(self.get_posttitle(a:index), pos)
                                  let self._right_position += 1
                                  let pos += 1
    1              0.000000     endif
                            
    1              0.000001     let self._remaining_space -= title_size
    1              0.000001     return 1
                              endif
                              return 0

FUNCTION  airline#extensions#tabline#get()
    Defined: ~/.vimgo/plugged/vim-airline/autoload/airline/extensions/tabline.vim:169
Called 39 times
Total time:   0.010850
 Self time:   0.001205

count  total (s)   self (s)
   39              0.000118     let show_buffers = get(g:, 'airline#extensions#tabline#show_buffers', 1)
   39              0.000065     let show_tabs = get(g:, 'airline#extensions#tabline#show_tabs', 1)
                            
   39              0.000062     let curtabcnt = tabpagenr('$')
   39              0.000083     if curtabcnt != s:current_tabcnt
                                  let s:current_tabcnt = curtabcnt
                                  call airline#extensions#tabline#tabs#invalidate()
                                  call airline#extensions#tabline#buffers#invalidate()
                                  call airline#extensions#tabline#ctrlspace#invalidate()
                                  call airline#extensions#tabline#tabws#invalidate()
   39              0.000015     endif
                            
   39              0.000102     if !exists('#airline#BufAdd#*')
                                  autocmd airline BufAdd * call <sid>update_tabline(0)
   39              0.000014     endif
   39              0.000080     if !exists('#airline#SessionLoadPost')
                                  autocmd airline SessionLoadPost * call <sid>update_tabline(1)
   39              0.000014     endif
   39              0.000022     if s:ctrlspace
                                  return airline#extensions#tabline#ctrlspace#get()
   39              0.000028     elseif s:tabws
                                  return airline#extensions#tabline#tabws#get()
   39              0.000063     elseif show_buffers && curtabcnt == 1 || !show_tabs
                                  return airline#extensions#tabline#buffers#get()
   39              0.000013     else
   39   0.009724   0.000079       return airline#extensions#tabline#tabs#get()
                                endif

FUNCTION  <SNR>233_popup_position()
    Defined: ~/.vimgo/plugged/coc.nvim/autoload/coc/float.vim:1185
Called 20 times
Total time:   0.000428
 Self time:   0.000320

count  total (s)   self (s)
   20              0.000037   let relative = get(a:config, 'relative', 'editor')
   20              0.000033   let border = get(a:config, 'border', [0, 0, 0, 0])
   20              0.000038   let delta = get(border, 0, 0)  + get(border, 2, 0)
   20              0.000013   if relative ==# 'cursor'
   17              0.000014     if a:config['row'] < 0
   17              0.000017       let delta = - delta
                                elseif a:config['row'] == 0
                                  let delta = - get(border, 0, 0)
                                else
                                  let delta = 0
   17              0.000003     endif
   17   0.000183   0.000075     return [s:popup_cursor(a:config['row'] + delta), s:popup_cursor(a:config['col'])]
    3              0.000001   endif
    3              0.000003   return [a:config['row'] + 1, a:config['col'] + 1]

FUNCTION  <SNR>221_UpdateLineNumbers()
    Defined: ~/.vimgo/plugged/ale/autoload/ale/sign.vim:282
Called 1 time
Total time:   0.000014
 Self time:   0.000014

count  total (s)   self (s)
    1              0.000001     let l:line_map = {}
    1              0.000001     let l:line_numbers_changed = 0
                            
    1              0.000001     for [l:line, l:sign_id, l:name] in a:current_sign_list
                                    let l:line_map[l:sign_id] = l:line
    1              0.000000     endfor
                            
    1              0.000001     for l:item in a:loclist
                                    if l:item.bufnr == a:buffer
                                        let l:lnum = get(l:line_map, get(l:item, 'sign_id', 0), 0)
                            
                                        if l:lnum && l:item.lnum != l:lnum
                                            let l:item.lnum = l:lnum
                                            let l:line_numbers_changed = 1
                                        endif
                                    endif
    1              0.000001     endfor
                            
                                " When the line numbers change, sort the list again
    1              0.000001     if l:line_numbers_changed
                                    call sort(a:loclist, 'ale#util#LocItemCompare')
    1              0.000000     endif

FUNCTION  airline#util#getwinvar()
    Defined: ~/.vimgo/plugged/vim-airline/autoload/airline/util.vim:84
Called 68 times
Total time:   0.000240
 Self time:   0.000240

count  total (s)   self (s)
   68              0.000227     return getwinvar(a:winnr, a:key, a:def)

FUNCTION  airline#extensions#whitespace#check()
    Defined: ~/.vimgo/plugged/vim-airline/autoload/airline/extensions/whitespace.vim:64
Called 4 times
Total time:   0.000283
 Self time:   0.000230

count  total (s)   self (s)
    4              0.000005   let max_lines = get(g:, 'airline#extensions#whitespace#max_lines', 20000)
    4              0.000013   if &readonly || !&modifiable || !s:enabled || line('$') > max_lines || get(b:, 'airline_whitespace_disabled', 0)
                                return ''
    4              0.000004   endif
    4              0.000009   let skip_check_ft = extend(s:skip_check_ft, get(g:, 'airline#extensions#whitespace#skip_indent_check_ft', {}), 'force')
                            
    4              0.000006   if !exists('b:airline_whitespace_check')
                                let b:airline_whitespace_check = ''
                                let checks = get(b:, 'airline_whitespace_checks', get(g:, 'airline#extensions#whitespace#checks', s:default_checks))
                            
                                let trailing = 0
                                let check = 'trailing'
                                if index(checks, check) > -1 && index(get(skip_check_ft, &ft, []), check) < 0
                                  try
                                    let regexp = get(b:, 'airline_whitespace_trailing_regexp', get(g:, 'airline#extensions#whitespace#trailing_regexp', '\s$'))
                                    let trailing = search(regexp, 'nw')
                                  catch
                                    call airline#util#warning(printf('Whitespace: error occurred evaluating "%s"', regexp))
                                    echomsg v:exception
                                    return ''
                                  endtry
                                endif
                            
                                let mixed = 0
                                let check = 'indent'
                                if index(checks, check) > -1 && index(get(skip_check_ft, &ft, []), check) < 0
                                  let mixed = s:check_mixed_indent()
                                endif
                            
                                let mixed_file = ''
                                let check = 'mixed-indent-file'
                                if index(checks, check) > -1 && index(get(skip_check_ft, &ft, []), check) < 0
                                  let mixed_file = s:check_mixed_indent_file()
                                endif
                            
                                let long = 0
                                if index(checks, 'long') > -1 && &tw > 0
                                  let long = search('\%>'.&tw.'v.\+', 'nw')
                                endif
                            
                                let conflicts = 0
                                if index(checks, 'conflicts') > -1
                                  let conflicts = s:conflict_marker()
                                endif
                            
                                if trailing != 0 || mixed != 0 || long != 0 || !empty(mixed_file) || conflicts != 0
                                  let b:airline_whitespace_check = s:symbol
                                  if strlen(s:symbol) > 0
                                    let space = (g:airline_symbols.space)
                                  else
                                    let space = ''
                                  endif
                            
                                  if s:show_message
                                    if trailing != 0
                                      let trailing_fmt = get(g:, 'airline#extensions#whitespace#trailing_format', '[%s]trailing')
                                      let b:airline_whitespace_check .= space.printf(trailing_fmt, trailing)
                                    endif
                                    if mixed != 0
                                      let mixed_indent_fmt = get(g:, 'airline#extensions#whitespace#mixed_indent_format', '[%s]mixed-indent')
                                      let b:airline_whitespace_check .= space.printf(mixed_indent_fmt, mixed)
                                    endif
                                    if long != 0
                                      let long_fmt = get(g:, 'airline#extensions#whitespace#long_format', '[%s]long')
                                      let b:airline_whitespace_check .= space.printf(long_fmt, long)
                                    endif
                                    if !empty(mixed_file)
                                      let mixed_indent_file_fmt = get(g:, 'airline#extensions#whitespace#mixed_indent_file_format', '[%s]mix-indent-file')
                                      let b:airline_whitespace_check .= space.printf(mixed_indent_file_fmt, mixed_file)
                                    endif
                                    if conflicts != 0
                                      let conflicts_fmt = get(g:, 'airline#extensions#whitespace#conflicts_format', '[%s]conflicts')
                                      let b:airline_whitespace_check .= space.printf(conflicts_fmt, conflicts)
                                    endif
                                  endif
                                endif
    4              0.000001   endif
    4   0.000061   0.000008   return airline#util#shorten(b:airline_whitespace_check, 120, 9)

FUNCTION  airline#extensions#tabline#title()
    Defined: ~/.vimgo/plugged/vim-airline/autoload/airline/extensions/tabline.vim:199
Called 40 times
Total time:   0.003614
 Self time:   0.001233

count  total (s)   self (s)
   40              0.000040     let title = ''
   40              0.000028     if s:taboo
                                  let title = TabooTabTitle(a:n)
   40              0.000010     endif
                            
   40              0.000091     if empty(title) && exists('*gettabvar')
   40              0.000061       let title = gettabvar(a:n, 'title')
   40              0.000011     endif
                            
   40              0.000069     let formatter = get(g:, 'airline#extensions#tabline#tabtitle_formatter')
   40              0.000103     if empty(title) && formatter !=# '' && exists("*".formatter)
                                  let title = call(formatter, [a:n])
   40              0.000009     endif
                            
   40              0.000032     if empty(title)
   40              0.000057       let buflist = tabpagebuflist(a:n)
   40              0.000051       let winnr = tabpagewinnr(a:n)
   40   0.000198   0.000082       let all_buffers = airline#extensions#tabline#buflist#list()
   40              0.000148       let curbuf = filter(buflist, 'index(all_buffers, v:val) != -1')
   40              0.000043       if len(curbuf) ==  0
                                    call add(curbuf, tabpagebuflist(a:n)[0])
   40              0.000013       endif
   40   0.002391   0.000126       return airline#extensions#tabline#get_buffer_name(curbuf[0], curbuf)
                                endif
                            
                                return title

FUNCTION  <SNR>102_IndentWithContinuation()
    Defined: ~/.vimgo/plugged/yats.vim/indent/typescript.vim:213
Called 1 time
Total time:   0.000298
 Self time:   0.000043

count  total (s)   self (s)
                              " Set up variables to use and search for MSL to the previous line.
    1              0.000002   let p_lnum = a:lnum
    1   0.000243   0.000007   let lnum = s:GetMSL(a:lnum, 1)
    1              0.000003   let line = getline(lnum)
                            
                              " If the previous line wasn't a MSL and is continuation return its indent.
                              " TODO: the || s:IsInString() thing worries me a bit.
    1              0.000002   if p_lnum != lnum
                                if s:Match(p_lnum,s:continuation_regex)||s:IsInString(p_lnum,strlen(line))
                                  return a:ind
                                endif
    1              0.000000   endif
                            
                              " Set up more variables now that we know we aren't continuation bound.
    1              0.000003   let msl_ind = indent(lnum)
                            
                              " If the previous line ended with [*+/.-=], start a continuation that
                              " indents an extra level.
    1   0.000024   0.000005   if s:Match(lnum, s:continuation_regex)
                                if lnum == p_lnum
                                  return msl_ind + a:width
                                else
                                  return msl_ind
                                endif
    1              0.000001   endif
                            
    1              0.000001   return a:ind

FUNCTION  airline#extensions#hunks#get_raw_hunks()
    Defined: ~/.vimgo/plugged/vim-airline/autoload/airline/extensions/hunks.vim:69
Called 101 times
Total time:   0.003336
 Self time:   0.002654

count  total (s)   self (s)
  101              0.000308   if !exists('b:source_func') || get(b:, 'source_func', '') is# 's:get_hunks_empty'
  101              0.000211     if get(g:, 'loaded_signify') && sy#buffer_is_active()
                                  let b:source_func = 's:get_hunks_signify'
  101              0.000240     elseif exists('*GitGutterGetHunkSummary')
                                  let b:source_func = 's:get_hunks_gitgutter'
  101              0.000183     elseif exists('*changes#GetStats')
                                  let b:source_func = 's:get_hunks_changes'
  101              0.000225     elseif exists('*quickfixsigns#vcsdiff#GetHunkSummary')
                                  let b:source_func = 'quickfixsigns#vcsdiff#GetHunkSummary'
  101   0.000829   0.000257     elseif s:coc_git_enabled()
                                  let b:source_func = 's:get_hunks_coc'
  101              0.000057     else
  101              0.000121       let b:source_func = 's:get_hunks_empty'
  101              0.000035     endif
  101              0.000035   endif
  101   0.000525   0.000415   return {b:source_func}()

FUNCTION  airline#extensions#tabline#formatters#default#wrap_name()
    Defined: ~/.vimgo/plugged/vim-airline/autoload/airline/extensions/tabline/formatters/default.vim:34
Called 80 times
Total time:   0.001014
 Self time:   0.001014

count  total (s)   self (s)
   80              0.000145     let buf_nr_format = get(g:, 'airline#extensions#tabline#buffer_nr_format', '%s: ')
   80              0.000133     let buf_nr_show = get(g:, 'airline#extensions#tabline#buffer_nr_show', 0)
                            
   80              0.000125     let _ = buf_nr_show ? printf(buf_nr_format, a:bufnr) : ''
   80              0.000227     let _ .= substitute(a:buffer_name, '\\', '/', 'g')
                            
   80              0.000133     if getbufvar(a:bufnr, '&modified') == 1
   78              0.000110       let _ .= g:airline_symbols.modified
   80              0.000018     endif
   80              0.000045     return _

FUNCTION  <SNR>176_exec_separator()
    Defined: ~/.vimgo/plugged/vim-airline/autoload/airline/highlighter.vim:189
Called 107 times
Total time:   0.030265
 Self time:   0.001914

count  total (s)   self (s)
  107              0.000109     if pumvisible()
                                  return
  107              0.000039     endif
  107              0.000154     let group = a:from.'_to_'.a:to.a:suffix
  107   0.008106   0.000349     let l:from = airline#themes#get_highlight(a:from.a:suffix)
  107   0.007437   0.000230     let l:to = airline#themes#get_highlight(a:to.a:suffix)
  107              0.000066     if a:inverse
   49              0.000116       let colors = [ l:from[1], l:to[1], l:from[3], l:to[3] ]
   58              0.000012     else
   58              0.000139       let colors = [ l:to[1], l:from[1], l:to[3], l:from[3] ]
  107              0.000029     endif
  107              0.000140     let a:dict[group] = colors
  107   0.013662   0.000275     call airline#highlighter#exec(group, colors)

FUNCTION  ale#Queue()
    Defined: ~/.vimgo/plugged/ale/autoload/ale.vim:123
Called 1 time
Total time:   0.383836
 Self time:   0.000149

count  total (s)   self (s)
    1              0.000006     if a:0 > 2
                                    throw 'too many arguments!'
    1              0.000002     endif
                            
    1              0.000012     let l:buffer = get(a:000, 1, v:null)
                            
    1              0.000007     if l:buffer is v:null
    1              0.000009         let l:buffer = bufnr('')
    1              0.000002     endif
                            
    1              0.000008     if type(l:buffer) isnot v:t_number
                                    throw 'buffer_number must be a Number'
    1              0.000001     endif
                            
    1   0.000385   0.000012     if ale#ShouldDoNothing(l:buffer)
                                    return
    1              0.000001     endif
                            
                                " Default linting_flag to ''
    1              0.000010     let l:should_lint_file = get(a:000, 0) is# 'lint_file'
                            
    1              0.000005     if s:lint_timer != -1
                                    call timer_stop(s:lint_timer)
                                    let s:lint_timer = -1
    1              0.000001     endif
                            
    1              0.000004     if a:delay > 0
                                    let s:lint_timer = timer_start(   a:delay,   function('s:Lint', [l:buffer, l:should_lint_file]))
    1              0.000002     else
    1   0.383334   0.000020         call s:Lint(l:buffer, l:should_lint_file, 0)
    1              0.000000     endif

FUNCTION  <SNR>179_update_untracked()
    Defined: ~/.vimgo/plugged/vim-airline/autoload/airline/extensions/branch.vim:202
Called 101 times
Total time:   0.005893
 Self time:   0.004963

count  total (s)   self (s)
  101              0.000718   let file = expand("%:p")
  101              0.000430   if empty(file) || isdirectory(file) || !empty(&buftype)
                                return
  101              0.000034   endif
                            
  101              0.000110   let needs_update = 1
  101              0.000307   let vcs_checks   = get(g:, "airline#extensions#branch#vcs_checks", ["untracked", "dirty"])
  303              0.000342   for vcs in keys(s:vcs_config)
  202              0.000463     if file =~ s:vcs_config[vcs].exclude
                                  " Skip check for files that live in the exclude directory
                                  let needs_update = 0
  202              0.000071     endif
  202              0.000398     if has_key(s:vcs_config[vcs].untracked, file)
  101              0.000092       let needs_update = 0
  101   0.001310   0.000380       call airline#extensions#branch#update_untracked_config(file, vcs)
  202              0.000067     endif
  303              0.000160   endfor
                            
  101              0.000076   if !needs_update
  101              0.000048     return
                              endif
                            
                              for vcs in keys(s:vcs_config)
                                " only check, for git, if fugitive is installed
                                " and for 'hg' if lawrencium is installed, else skip
                                if vcs is# 'git' && (!airline#util#has_fugitive() && !airline#util#has_gina())
                                  continue
                                elseif vcs is# 'mercurial' && !airline#util#has_lawrencium()
                                  continue
                                endif
                                let config = s:vcs_config[vcs]
                                " Note that asynchronous update updates s:vcs_config only, and only
                                " s:update_untracked updates b:buffer_vcs_config. If s:vcs_config is
                                " invalidated again before s:update_untracked is called, then we lose the
                                " result of the previous call, i.e. the head string is not updated. It
                                " doesn't happen often in practice, so we let it be.
                                if index(vcs_checks, 'untracked') > -1
                                  call airline#async#vcs_untracked(config, file, vcs)
                                endif
                                " Check clean state of repo
                                if index(vcs_checks, 'dirty') > -1
                                  call airline#async#vcs_clean(config.dirty, file, vcs)
                                endif
                              endfor

FUNCTION  ale#path#FindExecutable()
    Defined: ~/.vimgo/plugged/ale/autoload/ale/path.vim:102
Called 6 times
Total time:   0.001738
 Self time:   0.000115

count  total (s)   self (s)
    6   0.000158   0.000021     if ale#Var(a:buffer, a:base_var_name . '_use_global')
                                    return ale#Var(a:buffer, a:base_var_name . '_executable')
    6              0.000002     endif
                            
    6   0.001468   0.000030     let l:nearest = ale#path#FindNearestExecutable(a:buffer, a:path_list)
                            
    6              0.000007     if !empty(l:nearest)
                                    return l:nearest
    6              0.000002     endif
                            
    6   0.000070   0.000022     return ale#Var(a:buffer, a:base_var_name . '_executable')

FUNCTION  <SNR>102_Match()
    Defined: ~/.vimgo/plugged/yats.vim/indent/typescript.vim:208
Called 5 times
Total time:   0.000094
 Self time:   0.000094

count  total (s)   self (s)
    5              0.000071   let col = match(getline(a:lnum), a:regex) + 1
    5              0.000019   return col > 0 && !s:IsInStringOrComment(a:lnum, col) ? col : 0

FUNCTION  ale#engine#IsExecutable()
    Defined: ~/.vimgo/plugged/ale/autoload/ale/engine.vim:53
Called 8 times
Total time:   0.372117
 Self time:   0.371889

count  total (s)   self (s)
    8              0.000011     if empty(a:executable)
                                    " Don't log the executable check if the executable string is empty.
                                    return 0
    8              0.000002     endif
                            
                                " Check for a cached executable() check.
    8              0.000025     let l:result = get(s:executable_cache_map, a:executable, v:null)
                            
    8              0.000011     if l:result isnot v:null
                                    return l:result
    8              0.000002     endif
                            
                                " Check if the file is executable, and convert -1 to 1.
    8              0.371539     let l:result = executable(a:executable) isnot 0
                            
                                " Cache the executable check if we found it, or if the option to cache
                                " failing checks is on.
    8              0.000072     if l:result || get(g:, 'ale_cache_executable_check_failures', 0)
                                    let s:executable_cache_map[a:executable] = l:result
    8              0.000005     endif
                            
    8              0.000011     if g:ale_history_enabled
    8   0.000331   0.000103         call ale#history#Add(a:buffer, l:result, 'executable', a:executable)
    8              0.000004     endif
                            
    8              0.000009     return l:result

FUNCTION  airline#update_statusline_inactive()
    Defined: ~/.vimgo/plugged/vim-airline/autoload/airline.vim:179
Called 4 times
Total time:   0.000308
 Self time:   0.000200

count  total (s)   self (s)
    4   0.000124   0.000016   if airline#util#stl_disabled(winnr())
                                return
    4              0.000002   endif
    4              0.000011   for nr in a:range
                                if airline#util#stl_disabled(nr)
                                  continue
                                endif
                                call setwinvar(nr, 'airline_active', 0)
                                let context = { 'winnr': nr, 'active': 0, 'bufnr': winbufnr(nr) }
                                if get(g:, 'airline_inactive_alt_sep', 0)
                                  call extend(context, { 'left_sep': g:airline_left_alt_sep, 'right_sep': g:airline_right_alt_sep }, 'keep')
                                endif
                                try
                                  call s:invoke_funcrefs(context, g:airline_inactive_funcrefs)
                                catch /^Vim\%((\a\+)\)\=:E48:/
                                  " Catch: Sandbox mode
                                  " no-op
                                endtry
    4              0.000039   endfor

FUNCTION  <SNR>179_config_fugitive_branch()
    Defined: ~/.vimgo/plugged/vim-airline/autoload/airline/extensions/branch.vim:99
Called 101 times
Total time:   0.014521
 Self time:   0.000898

count  total (s)   self (s)
  101   0.014079   0.000456   let s:vcs_config['git'].branch =  FugitiveHead(s:sha1size)
  101              0.000232   if s:vcs_config['git'].branch is# 'master' && airline#util#winwidth() < 81
                                " Shorten default a bit
                                let s:vcs_config['git'].branch='mas'
  101              0.000033   endif

FUNCTION  airline#extensions#tabline#group_of_bufnr()
    Defined: ~/.vimgo/plugged/vim-airline/autoload/airline/extensions/tabline.vim:252
Called 1 time
Total time:   0.000035
 Self time:   0.000035

count  total (s)   self (s)
    1              0.000004     let cur = bufnr('%')
    1              0.000002     if cur == a:bufnr
    1              0.000006       if g:airline_detect_modified && getbufvar(a:bufnr, '&modified')
    1              0.000003         let group = 'airline_tabmod'
                                  else
                                    let group = 'airline_tabsel'
    1              0.000001       endif
                                else
                                  if g:airline_detect_modified && getbufvar(a:bufnr, '&modified')
                                    let group = 'airline_tabmod_unsel'
                                  elseif index(a:tab_bufs, a:bufnr) > -1
                                    let group = 'airline_tab'
                                  else
                                    let group = 'airline_tabhid'
                                  endif
    1              0.000001     endif
    1              0.000002     return group

FUNCTION  ale#path#IsAbsolute()
    Defined: ~/.vimgo/plugged/ale/autoload/ale/path.vim:117
Called 14 times
Total time:   0.000111
 Self time:   0.000111

count  total (s)   self (s)
   14              0.000041     if has('win32') && a:filename[:0] is# '\'
                                    return 1
   14              0.000005     endif
                            
                                " Check for /foo and C:\foo, etc.
   14              0.000043     return a:filename[:0] is# '/' || a:filename[1:2] is# ':\'

FUNCTION  <SNR>197_GetLintFileValues()
    Defined: ~/.vimgo/plugged/ale/autoload/ale/engine.vim:617
Called 1 time
Total time:   0.381044
 Self time:   0.000399

count  total (s)   self (s)
    1              0.000007     let l:deferred_list = []
    1              0.000003     let l:new_slots = []
                            
    9              0.000029     for [l:lint_file, l:linter] in a:slots
    8   0.000115   0.000063         while ale#command#IsDeferred(l:lint_file) && has_key(l:lint_file, 'value')
                                        " If we've already computed the return value, use it.
                                        let l:lint_file = l:lint_file.value
    8              0.000009         endwhile
                            
    8   0.000087   0.000042         if ale#command#IsDeferred(l:lint_file)
                                        " If we are going to return the result later, wait for it.
                                        call add(l:deferred_list, l:lint_file)
    8              0.000008         else
                                        " If we have the value now, coerce it to 0 or 1.
    8              0.000029             let l:lint_file = l:lint_file is 1
    8              0.000008         endif
                            
    8              0.000044         call add(l:new_slots, [l:lint_file, l:linter])
    9              0.000011     endfor
                            
    1              0.000005     if !empty(l:deferred_list)
                                    for l:deferred in l:deferred_list
                                        let l:deferred.result_callback =   {-> s:GetLintFileValues(l:new_slots, a:Callback)}
                                    endfor
    1              0.000001     else
    1   0.380557   0.000009         call a:Callback(l:new_slots)
    1              0.000001     endif

FUNCTION  coc#float#get_float_win_list()
    Defined: ~/.vimgo/plugged/coc.nvim/autoload/coc/float.vim:569
Called 13 times
Total time:   0.000207
 Self time:   0.000207

count  total (s)   self (s)
   13              0.000014   let res = []
   13              0.000039   let list_all = get(a:, 1, 0)
   13              0.000014   if s:is_vim
   13              0.000015     if s:popup_list_api
   13              0.000108       return filter(popup_list(), 'popup_getpos(v:val)["visible"]'.(list_all ? '' : '&& getwinvar(v:val, "float", 0)'))
                                endif
                                return filter(s:popup_list, 's:popup_visible(v:val)')
                              else
                                let res = []
                                for i in range(1, winnr('$'))
                                  let id = win_getid(i)
                                  let config = nvim_win_get_config(id)
                                  if empty(config) || empty(config['relative'])
                                    continue
                                  endif
                                  " ignore border & button window & others
                                  if list_all == 0 && !getwinvar(id, 'float', 0)
                                    continue
                                  endif
                                  call add(res, id)
                                endfor
                                return res
                              endif
                              return []

FUNCTION  <SNR>197_RunIfExecutable()
    Defined: ~/.vimgo/plugged/ale/autoload/ale/engine.vim:537
Called 6 times
Total time:   0.280077
 Self time:   0.000176

count  total (s)   self (s)
    6   0.000038   0.000017     if ale#command#IsDeferred(a:executable)
                                    let a:executable.result_callback = {   executable -> s:RunIfExecutable(       a:buffer,       a:linter,       a:lint_file,       executable   )}
                            
                                    return 1
    6              0.000004     endif
                            
    6   0.279898   0.000018     if ale#engine#IsExecutable(a:buffer, a:executable)
                                    " Use different job types for file or linter jobs.
                                    let l:job_type = a:lint_file ? 'file_linter' : 'linter'
                                    call setbufvar(a:buffer, 'ale_job_type', l:job_type)
                            
                                    " Get the cwd for the linter and set it before we call GetCommand.
                                    " This will ensure that ale#command#Run uses it by default.
                                    let l:cwd = ale#linter#GetCwd(a:buffer, a:linter)
                            
                                    if l:cwd isnot v:null
                                        call ale#command#SetCwd(a:buffer, l:cwd)
                                    endif
                            
                                    let l:command = ale#linter#GetCommand(a:buffer, a:linter)
                            
                                    if l:cwd isnot v:null
                                        call ale#command#ResetCwd(a:buffer)
                                    endif
                            
                                    let l:options = {   'cwd': l:cwd,   'executable': a:executable,   'buffer': a:buffer,   'linter': a:linter,   'output_stream': get(a:linter, 'output_stream', 'stdout'),   'read_buffer': a:linter.read_buffer,   'lint_file': a:lint_file,}
                            
                                    return s:RunJob(l:command, l:options)
    6              0.000002     endif
                            
    6              0.000005     return 0

FUNCTION  <SNR>181_airline_ale_count()
    Defined: ~/.vimgo/plugged/vim-airline/autoload/airline/extensions/ale.vim:11
Called 8 times
Total time:   0.000010
 Self time:   0.000010

count  total (s)   self (s)
    8              0.000006   return a:cnt ? a:symbol. a:cnt : ''

FUNCTION  <SNR>245_close_auto_hide_wins()
    Defined: ~/.vimgo/plugged/coc.nvim/autoload/coc/dialog.vim:635
Called 3 times
Total time:   0.000212
 Self time:   0.000044

count  total (s)   self (s)
    3   0.000041   0.000006   let winids = coc#float#get_float_win_list()
    3              0.000005   let except = get(a:, 1, 0)
    6              0.000003   for id in winids
    3              0.000001     if except && id == except
                                  continue
    3              0.000001     endif
    3   0.000140   0.000007     if coc#window#get_var(id, 'autohide', 0)
                                  call coc#float#close(id)
    3              0.000000     endif
    6              0.000005   endfor

FUNCTION  <SNR>243_restore_indentkeys()
    Defined: ~/.vimgo/plugged/coc.nvim/autoload/coc/pum.vim:145
Called 4 times
Total time:   0.000023
 Self time:   0.000023

count  total (s)   self (s)
    4              0.000009   if get(s:saved_indenetkeys, 0, 0) == bufnr('%')
                                call setbufvar(s:saved_indenetkeys[0], '&indentkeys', get(s:saved_indenetkeys, 1, ''))
                                let s:saved_indenetkeys = []
    4              0.000001   endif

FUNCTION  FugitiveHead()
    Defined: ~/.vimgo/plugged/vim-fugitive/plugin/fugitive.vim:236
Called 101 times
Total time:   0.013623
 Self time:   0.002175

count  total (s)   self (s)
  101              0.000447   if a:0 && (type(a:1) ==# type({}) || type(a:1) ==# type('') && a:1 !~# '^\d\+$')
                                let dir = FugitiveGitDir(a:1)
                                let arg = get(a:, 2, 0)
  101              0.000080   elseif a:0 > 1
                                let dir = FugitiveGitDir(a:2)
                                let arg = a:1
  101              0.000038   else
  101   0.003409   0.000239     let dir = FugitiveGitDir()
  101              0.000207     let arg = get(a:, 1, 0)
  101              0.000039   endif
  101              0.000110   if empty(dir)
                                return ''
  101              0.000030   endif
  101   0.008642   0.000364   return fugitive#Head(arg, dir)

FUNCTION  coc#pum#create()
    Defined: ~/.vimgo/plugged/coc.nvim/autoload/coc/pum.vim:351
Called 18 times
Total time:   0.065235
 Self time:   0.002183

count  total (s)   self (s)
   18              0.000085   if mode() !=# 'i' || a:opt['line'] != line('.')
    1              0.000001     return
   17              0.000007   endif
   17              0.000089   let len = col('.') - a:opt['col'] - 1
   17              0.000015   if len < 0
                                return
   17              0.000005   endif
   17              0.000067   let input = len == 0 ? '' : strpart(getline('.'), a:opt['col'], len)
   17              0.000022   if input !=# a:opt['input']
                                return
   17              0.000004   endif
   17   0.001144   0.000094   let config = s:get_pum_dimension(a:lines, a:opt['col'], a:config)
   17              0.000014   if empty(config)
                                return
   17              0.000005   endif
   17              0.000048   let s:reversed = get(a:config, 'reverse', 0) && config['row'] < 0
   17              0.000034   let s:virtual_text = s:virtual_text_support && a:opt['virtualText']
   17              0.000026   let s:pum_size = len(a:lines)
   17              0.000018   let s:pum_index = a:opt['index']
   17   0.000134   0.000047   let lnum = s:index_to_lnum(s:pum_index)
   17              0.000113   call extend(config, { 'lines': s:reversed ? reverse(copy(a:lines)) : a:lines, 'relative': 'cursor', 'nopad': 1, 'cursorline': 1, 'index': lnum - 1, 'focusable': v:false })
   17   0.000478   0.000150   call extend(config, coc#dict#pick(a:config, ['highlight', 'rounded', 'highlights', 'winblend', 'shadow', 'border', 'borderhighlight']))
   17              0.000009   if s:reversed
                                for item in config['highlights']
                                  let item['lnum'] = s:pum_size - item['lnum'] - 1
                                endfor
   17              0.000004   endif
   17              0.000095   if empty(get(config, 'winblend', 0)) && exists('&pumblend')
                                let config['winblend'] = &pumblend
   17              0.000007   endif
   17   0.059282   0.000070   let result =  coc#float#create_float_win(s:pum_winid, s:pum_bufnr, config)
   17              0.000016   if empty(result)
                                return
   17              0.000002   endif
   17              0.000017   let s:inserted = 0
   17              0.000022   let s:pum_winid = result[0]
   17              0.000015   let s:pum_bufnr = result[1]
   17              0.000019   let s:start_col = a:opt['startcol']
   17              0.000038   call setwinvar(s:pum_winid, 'above', config['row'] < 0)
   17   0.000171   0.000079   let firstline = s:get_firstline(lnum, s:pum_size, config['height'])
   17              0.000009   if s:is_vim
   17              0.000182     call popup_setoptions(s:pum_winid, { 'firstline': firstline })
                              else
                                call coc#compat#execute(s:pum_winid, 'call winrestview({"lnum":'.lnum.',"topline":'.firstline.'})')
   17              0.000006   endif
   17   0.000450   0.000119   call coc#dialog#place_sign(s:pum_bufnr, s:pum_index == -1 ? 0 : lnum)
                              " content before col and content after cursor
   17              0.000023   let linetext = getline('.')
   17              0.000060   let parts = [strpart(linetext, 0, s:start_col), strpart(linetext, col('.') - 1)]
   17              0.000040   let input = strpart(getline('.'), s:start_col, col('.') - 1 - s:start_col)
   17              0.000027   call setwinvar(s:pum_winid, 'input', input)
   17              0.000025   call setwinvar(s:pum_winid, 'parts', parts)
   17              0.000038   call setwinvar(s:pum_winid, 'words', a:opt['words'])
   17              0.000021   call setwinvar(s:pum_winid, 'kind', 'pum')
   17              0.000010   if !s:is_vim
                                if s:pum_size > config['height']
                                  redraw
                                  call coc#float#nvim_scrollbar(s:pum_winid)
                                else
                                  call coc#float#close_related(s:pum_winid, 'scrollbar')
                                endif
   17              0.000001   endif
   17   0.002003   0.000051   call s:on_pum_change(0)

FUNCTION  airline#highlighter#highlight()
    Defined: ~/.vimgo/plugged/vim-airline/autoload/airline/highlighter.vim:255
Called 6 times
Total time:   0.041376
 Self time:   0.005172

count  total (s)   self (s)
    6              0.000013     let bufnr = a:0 ? a:1 : ''
    6              0.000020     let p = g:airline#themes#{g:airline_theme}#palette
                            
                                " draw the base mode, followed by any overrides
    6              0.000047     let mapped = map(a:modes, 'v:val == a:modes[0] ? v:val : a:modes[0]."_".v:val')
    6              0.000016     let suffix = a:modes[0] == 'inactive' ? '_inactive' : ''
    6              0.000010     let airline_grouplist = []
    6              0.000022     let buffers_in_tabpage = sort(tabpagebuflist())
    6              0.000013     if exists("*uniq")
    6              0.000018       let buffers_in_tabpage = uniq(buffers_in_tabpage)
    6              0.000000     endif
                                " mapped might be something like ['normal', 'normal_modified']
                                " if a group is in both modes available, only define the second
                                " that is how this was done previously overwrite the previous definition
   15              0.000023     for mode in reverse(mapped)
    9              0.000037       if exists('g:airline#themes#{g:airline_theme}#palette[mode]')
    6              0.000013         let dict = g:airline#themes#{g:airline_theme}#palette[mode]
   83              0.000082         for kvp in items(dict)
   77              0.000081           let mode_colors = kvp[1]
   77              0.000072           let name = kvp[0]
   77              0.000104           if name is# 'airline_c' && !empty(bufnr) && suffix is# '_inactive'
                                        let name = 'airline_c'.bufnr
   77              0.000032           endif
                                      " do not re-create highlighting for buffers that are no longer visible
                                      " in the current tabpage
   77              0.000139           if name =~# 'airline_c\d\+'
                                        let bnr = matchstr(name, 'airline_c\zs\d\+') + 0
                                        if bnr > 0 && index(buffers_in_tabpage, bnr) == -1
                                          continue
                                        endif
   77              0.000190           elseif (name =~# '_to_') || (name[0:10] is# 'airline_tab' && !empty(suffix))
                                        " group will be redefined below at exec_separator
                                        " or is not needed for tabline with '_inactive' suffix
                                        " since active flag is 1 for builder)
   33              0.000015             continue
   44              0.000011           endif
   44   0.000279   0.000107           if s:group_not_done(airline_grouplist, name.suffix)
   36   0.006210   0.000092             call airline#highlighter#exec(name.suffix, mode_colors)
   44              0.000015           endif
                            
   44              0.000050           if !has_key(p, 'accents')
                                        " work around a broken installation
                                        " shouldn't actually happen, p should always contain accents
                                        continue
   44              0.000018           endif
                            
  132              0.000113           for accent in keys(s:accents)
   88              0.000109             if !has_key(p.accents, accent)
                                          continue
   88              0.000019             endif
   88              0.000132             let colors = copy(mode_colors)
   88              0.000107             if p.accents[accent][0] != ''
   44              0.000056               let colors[0] = p.accents[accent][0]
   88              0.000025             endif
   88              0.000087             if p.accents[accent][2] != ''
   44              0.000048               let colors[2] = p.accents[accent][2]
   88              0.000027             endif
   88              0.000079             if len(colors) >= 5
   84              0.000150               let colors[4] = get(p.accents[accent], 4, '')
    4              0.000001             else
    4              0.000007               call add(colors, get(p.accents[accent], 4, ''))
   88              0.000023             endif
   88   0.000556   0.000232             if s:group_not_done(airline_grouplist, name.suffix.'_'.accent)
   72   0.009732   0.000200               call airline#highlighter#exec(name.suffix.'_'.accent, colors)
   88              0.000027             endif
  132              0.000049           endfor
   50              0.000021         endfor
                            
    6              0.000007         if empty(s:separators)
                                      " nothing to be done
                                      continue
    6              0.000004         endif
                                    " TODO: optimize this
   84              0.000062         for sep in items(s:separators)
                                      " we cannot check, that the group already exists, else the separators
                                      " might not be correctly defined. But perhaps we can skip above groups
                                      " that match the '_to_' name, because they would be redefined here...
   78   0.020364   0.000306           call <sid>exec_separator(dict, sep[1][0], sep[1][1], sep[1][2], suffix)
   84              0.000033         endfor
    9              0.000004       endif
   15              0.000014     endfor

FUNCTION  coc#rpc#ready()
    Defined: ~/.vimgo/plugged/coc.nvim/autoload/coc/rpc.vim:33
Called 170 times
Total time:   0.001286
 Self time:   0.001286

count  total (s)   self (s)
  170              0.000712   if empty(s:client) || s:client['running'] == 0
                                return 0
  170              0.000098   endif
  170              0.000147   return 1

FUNCTION  airline#builder#get_next_group()
    Defined: ~/.vimgo/plugged/vim-airline/autoload/airline/builder.vim:49
Called 1 time
Total time:   0.000012
 Self time:   0.000012

count  total (s)   self (s)
    1              0.000001   let x = a:i + 1
    1              0.000001   let l = len(a:sections)
    2              0.000002   while x < l
    2              0.000002     let group = a:sections[x][0]
    2              0.000001     if group != '' && group != '|'
    1              0.000000       return group
    1              0.000001     endif
    1              0.000000     let x = x + 1
    1              0.000001   endwhile
                              return ''

FUNCTION  airline#parts#ffenc()
    Defined: ~/.vimgo/plugged/vim-airline/autoload/airline/parts.vim:196
Called 101 times
Total time:   0.001995
 Self time:   0.001995

count  total (s)   self (s)
  101              0.000193   let expected = get(g:, 'airline#parts#ffenc#skip_expected_string', '')
  101              0.000130   let bomb     = &bomb ? '[BOM]' : ''
  101              0.000298   let noeolf   = &eol ? '' : '[!EOL]'
  101              0.000540   let ff       = strlen(&ff) ? '['.&ff.']' : ''
  101              0.000360   if expected is# &fenc.bomb.noeolf.ff
                                return ''
  101              0.000024   else
  101              0.000313     return &fenc.bomb.noeolf.ff
                              endif

FUNCTION  ale#Var()
    Defined: ~/.vimgo/plugged/ale/autoload/ale.vim:180
Called 24 times
Total time:   0.000370
 Self time:   0.000370

count  total (s)   self (s)
   24              0.000069     let l:full_name = 'ale_' . a:variable_name
   24              0.000175     let l:vars = getbufvar(str2nr(a:buffer), '', {})
                            
   24              0.000102     return get(l:vars, l:full_name, g:[l:full_name])

FUNCTION  <SNR>233_add_highlights()
    Defined: ~/.vimgo/plugged/coc.nvim/autoload/coc/float.vim:1392
Called 20 times
Total time:   0.088144
 Self time:   0.000324

count  total (s)   self (s)
   20              0.000028   let codes = get(a:config, 'codes', [])
   20              0.000033   let highlights = get(a:config, 'highlights', [])
   20              0.000026   if empty(codes) && empty(highlights) && a:create
                                return
   20              0.000003   endif
   20              0.000028   let bgGroup = get(a:config, 'highlight', 'CocFloating')
   23              0.000017   for obj in codes
    3              0.000004     let hlGroup = get(obj, 'hlGroup', v:null)
    3              0.000003     if !empty(hlGroup)
                                  let obj['hlGroup'] = coc#highlight#compose_hlgroup(hlGroup, bgGroup)
    3              0.000000     endif
   23              0.000007   endfor
   20   0.087886   0.000066   call coc#highlight#add_highlights(a:winid, codes, highlights)

FUNCTION  airline#util#ignore_buf()
    Defined: ~/.vimgo/plugged/vim-airline/autoload/airline/util.vim:138
Called 97 times
Total time:   0.001321
 Self time:   0.001321

count  total (s)   self (s)
   97              0.000388   let pat = '\c\v'. get(g:, 'airline#ignore_bufadd_pat', ''). get(g:, 'airline#extensions#tabline#ignore_bufadd_pat', '!|defx|gundo|nerd_tree|startify|tagbar|term://|undotree|vimfiler')
   97              0.000878   return match(a:name, pat) > -1

FUNCTION  <SNR>243_get_firstline()
    Defined: ~/.vimgo/plugged/coc.nvim/autoload/coc/pum.vim:432
Called 17 times
Total time:   0.000092
 Self time:   0.000092

count  total (s)   self (s)
   17              0.000009   if a:lnum <= a:height
   17              0.000076     return 1
                              endif
                              return min([a:total - a:height + 1, a:lnum  - (a:height*2/3)])

FUNCTION  <SNR>231_get_priority()
    Defined: ~/.vimgo/plugged/coc.nvim/autoload/coc/highlight.vim:764
Called 4 times
Total time:   0.000062
 Self time:   0.000062

count  total (s)   self (s)
    4              0.000009   if a:hlGroup ==# 'CocListSearch'
                                return 2048
    4              0.000001   endif
    4              0.000005   if a:hlGroup ==# 'CocSearch'
                                return 999
    4              0.000002   endif
    4              0.000013   if strpart(a:key, 0, 10) !=# 'diagnostic'
                                return a:priority
    4              0.000002   endif
    4              0.000015   return a:priority - index(s:diagnostic_hlgroups, a:hlGroup)

FUNCTION  ale#util#StartPartialTimer()
    Defined: ~/.vimgo/plugged/ale/autoload/ale/util.vim:460
Called 1 time
Total time:   0.000007
 Self time:   0.000007

count  total (s)   self (s)
    1              0.000003     let l:timer_id = timer_start(a:delay, function('s:ApplyPartialTimer'))
    1              0.000003     let s:partial_timers[l:timer_id] = [a:callback, a:args]
                            
    1              0.000001     return l:timer_id

FUNCTION  airline#builder#get_prev_group()
    Defined: ~/.vimgo/plugged/vim-airline/autoload/airline/builder.vim:37
Called 50 times
Total time:   0.000369
 Self time:   0.000369

count  total (s)   self (s)
   50              0.000059   let x = a:i - 1
   56              0.000045   while x >= 0
   50              0.000090     let group = a:sections[x][0]
   50              0.000058     if group != '' && group != '|'
   44              0.000022       return group
    6              0.000003     endif
    6              0.000003     let x = x - 1
   12              0.000009   endwhile
    6              0.000007   return ''

FUNCTION  airline#extensions#tabline#tabs#get()
    Defined: ~/.vimgo/plugged/vim-airline/autoload/airline/extensions/tabline/tabs.vim:30
Called 39 times
Total time:   0.009645
 Self time:   0.000853

count  total (s)   self (s)
   39              0.000077   let curbuf = bufnr('%')
   39              0.000050   let curtab = tabpagenr()
   39              0.000023   try
   39   0.001047   0.000097     call airline#extensions#tabline#tabs#map_keys()
                              catch
                                " no-op
   39              0.000023   endtry
   39              0.000114   if curbuf == s:current_bufnr && curtab == s:current_tabnr && &columns == s:column_width
   39              0.000135     if !g:airline_detect_modified || getbufvar(curbuf, '&modified') == s:current_modified
   38              0.000057       return s:current_tabline
    1              0.000001     endif
    1              0.000001   endif
                            
    1   0.000014   0.000007   let s:filtered_buflist =  airline#extensions#tabline#buflist#list()
                            
    1   0.000112   0.000008   let b = airline#extensions#tabline#new_builder()
                            
    1   0.000048   0.000007   call airline#extensions#tabline#add_label(b, 'tabs', 0)
                            
    1              0.000004   function! b.get_group(i) dict
                                let curtab = tabpagenr()
                                let group = 'airline_tab'
                                if a:i == curtab
                                  let group = 'airline_tabsel'
                                  if g:airline_detect_modified
                                    for bi in tabpagebuflist(curtab)
                                      if index(s:filtered_buflist,bi) != -1
                                        if getbufvar(bi, '&modified')
                                          let group = 'airline_tabmod'
                                        endif
                                      endif
                                    endfor
                                  endif
                                  let s:current_modified = (group == 'airline_tabmod') ? 1 : 0
                                endif
                                return group
                              endfunction
                            
    1              0.000002   function! b.get_title(i) dict
                                let val = '%('
                            
                                if get(g:, 'airline#extensions#tabline#show_tab_nr', 1)
                                  let tab_nr_type = get(g:, 'airline#extensions#tabline#tab_nr_type', 0)
                                  let val .= airline#extensions#tabline#tabs#tabnr_formatter(tab_nr_type, a:i)
                                endif
                            
                                return val.'%'.a:i.'T %{airline#extensions#tabline#title('.a:i.')} %)'
                              endfunction
                            
    1   0.000032   0.000008   call b.insert_titles(curtab, 1, tabpagenr('$'))
                            
    1   0.000009   0.000004   call b.add_section('airline_tabfill', '')
    1   0.000009   0.000004   call b.split()
    1   0.000009   0.000005   call b.add_section('airline_tabfill', '')
                            
    1              0.000004   if get(g:, 'airline#extensions#tabline#show_close_button', 1)
    1   0.000012   0.000008     call b.add_section('airline_tab_right', ' %999X'. get(g:, 'airline#extensions#tabline#close_symbol', 'X').'%X ')
    1              0.000001   endif
                            
    1              0.000004   if get(g:, 'airline#extensions#tabline#show_splits', 1) == 1
    1              0.000005     let buffers = tabpagebuflist(curtab)
    2              0.000005     for nr in buffers
    1              0.000006       if index(s:filtered_buflist,nr) != -1
    1   0.000045   0.000010         let group = airline#extensions#tabline#group_of_bufnr(buffers, nr) . "_right"
    1   0.000025   0.000008         call b.add_section_spaced(group, '%(%{airline#extensions#tabline#get_buffer_name('.nr.')}%)')
    1              0.000001       endif
    2              0.000002     endfor
    1              0.000004     if get(g:, 'airline#extensions#tabline#show_buffers', 1)
                                  call airline#extensions#tabline#add_label(b, 'buffers', 1)
    1              0.000001     endif
    1              0.000001   endif
    1   0.000030   0.000005   call airline#extensions#tabline#add_tab_label(b)
                            
    1              0.000004   let s:current_bufnr = curbuf
    1              0.000003   let s:current_tabnr = curtab
    1              0.000002   let s:column_width = &columns
    1   0.007577   0.000006   let s:current_tabline = b.build()
    1              0.000001   return s:current_tabline

FUNCTION  airline#util#ignore_next_focusgain()
    Defined: ~/.vimgo/plugged/vim-airline/autoload/airline/util.vim:206
Called 101 times
Total time:   0.000480
 Self time:   0.000480

count  total (s)   self (s)
  101              0.000178   if has('win32')
                                " Setup an ignore for platforms that trigger FocusLost on calls to
                                " system(). macvim (gui and terminal) and Linux terminal vim do not.
                                let s:focusgained_ignore_time = localtime()
  101              0.000036   endif

FUNCTION  airline#parts#get()
    Defined: ~/.vimgo/plugged/vim-airline/autoload/airline/parts.vim:49
Called 202 times
Total time:   0.000504
 Self time:   0.000504

count  total (s)   self (s)
  202              0.000454   return get(s:parts, a:key, {})

FUNCTION  coc#api#exec()
    Defined: ~/.vimgo/plugged/coc.nvim/autoload/coc/api.vim:693
Called 1174 times
Total time:   0.034006
 Self time:   0.002603

count  total (s)   self (s)
 1174   0.033908   0.002505   return call(s:funcs[a:method], a:args)

FUNCTION  airline#parts#paste()
    Defined: ~/.vimgo/plugged/vim-airline/autoload/airline/parts.vim:63
Called 97 times
Total time:   0.000205
 Self time:   0.000205

count  total (s)   self (s)
   97              0.000173   return g:airline_detect_paste && &paste ? g:airline_symbols.paste : ''

FUNCTION  coc#util#check_refresh()
    Defined: ~/.vimgo/plugged/coc.nvim/autoload/coc/util.vim:112
Called 1 time
Total time:   0.000024
 Self time:   0.000024

count  total (s)   self (s)
    1              0.000009   if !bufloaded(a:bufnr)
                                return 0
    1              0.000002   endif
    1              0.000006   if getbufvar(a:bufnr, 'coc_diagnostic_disable', 0)
                                return 0
    1              0.000001   endif
    1              0.000001   return 1

FUNCTION  airline#update_statusline()
    Defined: ~/.vimgo/plugged/vim-airline/autoload/airline.vim:144
Called 4 times
Total time:   0.025185
 Self time:   0.000354

count  total (s)   self (s)
    4   0.000251   0.000043   if airline#util#stl_disabled(winnr()) || airline#util#is_popup_window(winnr())
                                return
    4              0.000004   endif
                              " TODO: need to ignore popup windows here as well?
    4              0.000041   let range = filter(range(1, winnr('$')), 'v:val != winnr()')
                              " create inactive statusline
    4   0.000332   0.000024   call airline#update_statusline_inactive(range)
                            
    4              0.000047   unlet! w:airline_render_left w:airline_render_right
    4              0.000070   exe 'unlet! ' 'w:airline_section_'. join(s:sections, ' w:airline_section_')
                            
                              " Now create the active statusline
    4              0.000010   let w:airline_active = 1
    4              0.000033   let context = { 'winnr': winnr(), 'active': 1, 'bufnr': winbufnr(winnr()) }
    4              0.000005   try
    4   0.024361   0.000046     call s:invoke_funcrefs(context, g:airline_statusline_funcrefs)
                              catch /^Vim\%((\a\+)\)\=:E48:/
                                " Catch: Sandbox mode
                                " no-op
    4              0.000000   endtry

FUNCTION  airline#extensions#branch#update_untracked_config()
    Defined: ~/.vimgo/plugged/vim-airline/autoload/airline/extensions/branch.vim:193
Called 101 times
Total time:   0.000930
 Self time:   0.000930

count  total (s)   self (s)
  101              0.000246   if !has_key(s:vcs_config[a:vcs].untracked, a:file)
                                return
  101              0.000312   elseif s:vcs_config[a:vcs].untracked[a:file] != b:buffer_vcs_config[a:vcs].untracked
                                let b:buffer_vcs_config[a:vcs].untracked = s:vcs_config[a:vcs].untracked[a:file]
                                unlet! b:airline_head
  101              0.000031   endif

FUNCTION  ale#command#StopJobs()
    Defined: ~/.vimgo/plugged/ale/autoload/ale/command.vim:261
Called 1 time
Total time:   0.000204
 Self time:   0.000204

count  total (s)   self (s)
    1              0.000008     let l:info = get(s:buffer_data, a:buffer, {})
                            
    1              0.000149     if !empty(l:info)
                                    let l:new_map = {}
                            
                                    for [l:job_id, l:job_type] in items(l:info.jobs)
                                        let l:job_id = str2nr(l:job_id)
                            
                                        if a:job_type is# 'all' || a:job_type is# l:job_type
                                            call ale#job#Stop(l:job_id)
                                        else
                                            let l:new_map[l:job_id] = l:job_type
                                        endif
                                    endfor
                            
                                    let l:info.jobs = l:new_map
    1              0.000001     endif

FUNCTION  airline#extensions#hunks#get_hunks()
    Defined: ~/.vimgo/plugged/vim-airline/autoload/airline/extensions/hunks.vim:88
Called 101 times
Total time:   0.009935
 Self time:   0.004847

count  total (s)   self (s)
  101              0.000196   if !get(w:, 'airline_active', 0)
                                return ''
  101              0.000031   endif
                              " Cache values, so that it isn't called too often
  101   0.001660   0.001152   if exists("b:airline_hunks") && get(b:,  'airline_changenr', 0) == b:changedtick && airline#util#winwidth() == get(s:, 'airline_winwidth', 0) && get(b:, 'source_func', '') isnot# 's:get_hunks_signify' && get(b:, 'source_func', '') isnot# 's:get_hunks_gitgutter' && get(b:, 'source_func', '') isnot# 's:get_hunks_empty' && get(b:, 'source_func', '') isnot# 's:get_hunks_changes' && get(b:, 'source_func', '') isnot# 's:get_hunks_coc'
                                return b:airline_hunks
  101              0.000036   endif
  101   0.003678   0.000342   let hunks = airline#extensions#hunks#get_raw_hunks()
  101              0.000095   let string = ''
  101   0.000644   0.000358   let winwidth = get(airline#parts#get('hunks'), 'minwidth', 100)
  101              0.000136   if !empty(hunks)
                                " hunks should contain [added, changed, deleted]
                                for i in [0, 1, 2]
                                  if (s:non_zero_only == 0 && airline#util#winwidth() > winwidth) || hunks[i] > 0
                                    let string .= printf('%s%s ', s:hunk_symbols[i], hunks[i])
                                  endif
                                endfor
  101              0.000037   endif
  101   0.000638   0.000446   if index(airline#extensions#get_loaded_extensions(), 'branch') == -1 && string[-1:] == ' '
                                " branch extension not loaded, skip trailing whitespace
                                let string = string[0:-2]
  101              0.000038   endif
                            
  101              0.000138   let b:airline_hunks = string
  101              0.000145   let b:airline_changenr = b:changedtick
  101   0.000989   0.000223   let s:airline_winwidth = airline#util#winwidth()
  101              0.000072   return string

FUNCTION  ale#util#BinarySearch()
    Defined: ~/.vimgo/plugged/ale/autoload/ale/util.vim:232
Called 4 times
Total time:   0.000024
 Self time:   0.000024

count  total (s)   self (s)
    4              0.000002     let l:min = 0
    4              0.000005     let l:max = len(a:loclist) - 1
                            
    4              0.000002     while 1
    4              0.000003         if l:max < l:min
    4              0.000003             return -1
                                    endif
                            
                                    let l:mid = (l:min + l:max) / 2
                                    let l:item = a:loclist[l:mid]
                            
                                    " Binary search for equal buffers, equal lines, then near columns.
                                    if l:item.bufnr < a:buffer
                                        let l:min = l:mid + 1
                                    elseif l:item.bufnr > a:buffer
                                        let l:max = l:mid - 1
                                    elseif l:item.lnum < a:line
                                        let l:min = l:mid + 1
                                    elseif l:item.lnum > a:line
                                        let l:max = l:mid - 1
                                    else
                                        " This part is a small sequential search.
                                        let l:index = l:mid
                            
                                        " Search backwards to find the first problem on the line.
                                        while l:index > 0&& a:loclist[l:index - 1].bufnr == a:buffer&& a:loclist[l:index - 1].lnum == a:line
                                            let l:index -= 1
                                        endwhile
                            
                                        " Find the last problem on or before this column.
                                        while l:index < l:max&& a:loclist[l:index + 1].bufnr == a:buffer&& a:loclist[l:index + 1].lnum == a:line&& a:loclist[l:index + 1].col <= a:column
                                            let l:index += 1
                                        endwhile
                            
                                        " Scan forwards to find the last item on the column for the item
                                        " we found, which will have the most serious problem.
                                        let l:item_column = a:loclist[l:index].col
                            
                                        while l:index < l:max&& a:loclist[l:index + 1].bufnr == a:buffer&& a:loclist[l:index + 1].lnum == a:line&& a:loclist[l:index + 1].col == l:item_column
                                            let l:index += 1
                                        endwhile
                            
                                        return l:index
                                    endif
                                endwhile

FUNCTION  coc#ui#update_signs()
    Defined: ~/.vimgo/plugged/coc.nvim/autoload/coc/ui.vim:407
Called 1 time
Total time:   0.000090
 Self time:   0.000090

count  total (s)   self (s)
    1              0.000006   if !s:sign_api || !bufloaded(a:bufnr)
                                return
    1              0.000001   endif
    1              0.000009   call sign_unplace(a:group, {'buffer': a:bufnr})
    4              0.000006   for def in a:signs
    3              0.000010     let opts = {'lnum': def['lnum']}
    3              0.000007     if has_key(def, 'priority')
    3              0.000010       let opts['priority'] = def['priority']
    3              0.000001     endif
    3              0.000021     call sign_place(0, a:group, def['name'], a:bufnr, opts)
    4              0.000002   endfor

FUNCTION  yats#IsLineComment()
    Defined: ~/.vimgo/plugged/yats.vim/autoload/yats.vim:13
Called 2 times
Total time:   0.000040
 Self time:   0.000040

count  total (s)   self (s)
    2              0.000039   return synIDattr(synID(a:lnum, a:col, 1), 'name') =~ s:syng_linecom

FUNCTION  airline#parts#readonly()
    Defined: ~/.vimgo/plugged/vim-airline/autoload/airline/parts.vim:177
Called 97 times
Total time:   0.002320
 Self time:   0.000999

count  total (s)   self (s)
                              " only consider regular buffers (e.g. ones that represent actual files,
                              " but not special ones like e.g. NERDTree)
   97   0.001691   0.000370   if !empty(&buftype) || airline#util#ignore_buf(bufname('%'))
                                return ''
   97              0.000038   endif
   97              0.000137   if &readonly && !filereadable(bufname('%'))
                                return '[noperm]'
   97              0.000028   else
   97              0.000131     return &readonly ? g:airline_symbols.readonly : ''
                              endif

FUNCTION  fugitive#Head()
    Defined: ~/.vimgo/plugged/vim-fugitive/autoload/fugitive.vim:1016
Called 101 times
Total time:   0.008278
 Self time:   0.004256

count  total (s)   self (s)
  101              0.000301   let dir = a:0 > 1 ? a:2 : s:Dir()
  101              0.000112   if empty(dir)
                                return ''
  101              0.000029   endif
  101   0.004329   0.000307   let file = FugitiveActualDir() . '/HEAD'
  101              0.000804   let ftime = getftime(file)
  101              0.000088   if ftime == -1
                                return ''
  101              0.000370   elseif ftime != get(s:head_cache, file, [-1])[0]
                                let s:head_cache[file] = [ftime, readfile(file)[0]]
  101              0.000034   endif
  101              0.000218   let head = s:head_cache[file][1]
  101              0.000146   let len = a:0 ? a:1 : 0
  101              0.000213   if head =~# '^ref: '
  101              0.000081     if len < 0
                                  return strpart(head, 5)
  101              0.000046     else
  101              0.000807       return substitute(head, '\C^ref: \%(refs/\%(heads/\|remotes/\|tags/\)\=\)\=', '', '')
                                endif
                              elseif head =~# '^\x\{40,\}$'
                                return len < 0 ? head : strpart(head, 0, len)
                              else
                                return ''
                              endif

FUNCTION  ale#engine#RunLinters()
    Defined: ~/.vimgo/plugged/ale/autoload/ale/engine.vim:689
Called 1 time
Total time:   0.381556
 Self time:   0.000075

count  total (s)   self (s)
                                " Initialise the buffer information if needed.
    1   0.000041   0.000012     let l:new_buffer = ale#engine#InitBufferInfo(a:buffer)
                            
    1   0.381508   0.000056     call s:GetLintFileValues(   s:GetLintFileSlots(a:buffer, a:linters),   {       slots -> s:RunLinters(           a:buffer,           a:linters,           slots,           a:should_lint_file,           l:new_buffer,       )   })

FUNCTION  GetTypescriptIndent()
    Defined: ~/.vimgo/plugged/yats.vim/indent/typescript.vim:270
Called 1 time
Total time:   0.001797
 Self time:   0.000521

count  total (s)   self (s)
                              " 3.1. Setup {{{2
                              " ----------
                            
                              " Set up variables for restoring position in file.  Could use v:lnum here.
    1              0.000024   let vcol = col('.')
                            
                              " 3.2. Work on the current line {{{2
                              " -----------------------------
                            
    1              0.000004   let ind = -1
                              " Get the current line.
    1              0.000007   let line = getline(v:lnum)
                              " previous nonblank line number
    1              0.000007   let prevline = prevnonblank(v:lnum - 1)
                            
                              " If we got a closing bracket on an empty line, find its match and indent
                              " according to it.  For parentheses we indent to its column - 1, for the
                              " others we indent to the containing line's MSL's level.  Return -1 if fail.
    1              0.000013   let col = matchend(line, '^\s*[],})]')
    1              0.000014   if col > 0 && !s:IsInStringOrComment(v:lnum, col)
                                call cursor(v:lnum, col)
                            
                                let lvar = s:InMultiVarStatement(v:lnum)
                                if lvar
                                  let prevline_contents = s:RemoveTrailingComments(getline(prevline))
                            
                                  " check for comma first
                                  if (line[col - 1] =~ ',')
                                    " if the previous line ends in comma or semicolon don't indent
                                    if (prevline_contents =~ '[;,]\s*$')
                                      return indent(s:GetMSL(line('.'), 0))
                                    " get previous line indent, if it's comma first return prevline indent
                                    elseif (prevline_contents =~ s:comma_first)
                                      return indent(prevline)
                                    " otherwise we indent 1 level
                                    else
                                      return indent(lvar) + shiftwidth()
                                    endif
                                  endif
                                endif
                            
                            
                                let bs = strpart('(){}[]', stridx(')}]', line[col - 1]) * 2, 2)
                                if searchpair(escape(bs[0], '\['), '', bs[1], 'bW', s:skip_expr) > 0
                                  if line[col-1]==')' && col('.') != col('$') - 1
                                    let ind = virtcol('.')-1
                                  else
                                    let ind = indent(s:GetMSL(line('.'), 0))
                                  endif
                                endif
                                return ind
    1              0.000001   endif
                            
                              " If the line is comma first, dedent 1 level
    1              0.000009   if (getline(prevline) =~ s:comma_first)
                                return indent(prevline) - shiftwidth()
    1              0.000001   endif
                            
    1              0.000005   if (line =~ s:ternary)
                                if (getline(prevline) =~ s:ternary_q)
                                  return indent(prevline)
                                else
                                  return indent(prevline) + shiftwidth()
                                endif
    1              0.000000   endif
                            
                              " If we are in a multi-line comment, cindent does the right thing.
    1   0.000288   0.000192   if yats#IsInMultilineComment(v:lnum, 1) && !yats#IsLineComment(v:lnum, 1)
                                return cindent(v:lnum)
    1              0.000001   endif
                            
                              " Check for multiple var assignments
                            "  let var_indent = s:GetVarIndent(v:lnum)
                            "  if var_indent >= 0
                            "    return var_indent
                            "  endif
                            
                              " 3.3. Work on the previous line. {{{2
                              " -------------------------------
                            
                              " If the line is empty and the previous nonblank line was a multi-line
                              " comment, use that comment's indent. Deduct one char to account for the
                              " space in ' */'.
    1   0.000039   0.000008   if line =~ '^\s*$' && yats#IsInMultilineComment(prevline, 1)
                                return indent(prevline) - 1
    1              0.000001   endif
                            
                              " Find a non-blank, non-multi-line string line above the current line.
    1   0.000150   0.000010   let lnum = s:PrevNonBlankNonString(v:lnum - 1)
                            
                              " If the line is empty and inside a string, use the previous line.
    1              0.000004   if line =~ '^\s*$' && lnum != prevline
                                return indent(prevnonblank(v:lnum))
    1              0.000000   endif
                            
                              " At the start of the file use zero indent.
    1              0.000001   if lnum == 0
                                return 0
    1              0.000000   endif
                            
                              " Set up variables for current line.
    1              0.000003   let line = getline(lnum)
    1              0.000003   let ind = indent(lnum)
                            
                              " If the previous line ended with a block opening, add a level of indent.
    1   0.000034   0.000008   if s:Match(lnum, s:block_regex)
                                return indent(s:GetMSL(lnum, 0)) + shiftwidth()
    1              0.000001   endif
                            
                              " If the previous line contained an opening bracket, and we are still in it,
                              " add indent depending on the bracket type.
    1              0.000003   if line =~ '[[({]'
                                let counts = s:LineHasOpeningBrackets(lnum)
                                if counts[0] == '1' && searchpair('(', '', ')', 'bW', s:skip_expr) > 0
                                  if col('.') + 1 == col('$')
                                    return ind + shiftwidth()
                                  else
                                    return virtcol('.')
                                  endif
                                elseif counts[1] == '1' || counts[2] == '1'
                                  return ind + shiftwidth()
                                else
                                  call cursor(v:lnum, vcol)
                                end
    1              0.000001   endif
                            
                              " 3.4. Work on the MSL line. {{{2
                              " --------------------------
                            
    1              0.000002   let ind_con = ind
    1   0.000307   0.000009   let ind = s:IndentWithContinuation(lnum, ind_con, shiftwidth())
                            
                              " }}}2
                              "
                              "
    1   0.000225   0.000005   let ols = s:InOneLineScope(lnum)
    1              0.000002   if ols > 0
                                let ind = ind + shiftwidth()
    1              0.000001   else
    1   0.000470   0.000005     let ols = s:ExitingOneLineScope(lnum)
    1              0.000002     while ols > 0 && ind > 0
                                  let ind = ind - shiftwidth()
                                  let ols = s:InOneLineScope(ols - 1)
    1              0.000002     endwhile
    1              0.000001   endif
                            
    1              0.000001   return ind

FUNCTION  <SNR>169_check_defined_section()
    Defined: ~/.vimgo/plugged/vim-airline/autoload/airline/extensions.vim:48
Called 4 times
Total time:   0.000062
 Self time:   0.000062

count  total (s)   self (s)
    4              0.000029   if !exists('w:airline_section_{a:name}')
    4              0.000026     let w:airline_section_{a:name} = g:airline_section_{a:name}
    4              0.000004   endif

FUNCTION  ale#handlers#deno#GetExecutable()
    Defined: ~/.vimgo/plugged/ale/autoload/ale/handlers/deno.vim:10
Called 1 time
Total time:   0.000008
 Self time:   0.000002

count  total (s)   self (s)
    1   0.000008   0.000002     return ale#Var(a:buffer, 'deno_executable')

FUNCTION  <SNR>227_evaluate_tabline()
    Defined: ~/.vimgo/plugged/vim-airline/autoload/airline/extensions/tabline/builder.vim:209
Called 5 times
Total time:   0.000255
 Self time:   0.000117

count  total (s)   self (s)
    5              0.000007   let tabline = a:tabline
    5   0.000166   0.000028   let tabline = substitute(tabline, '%{\([^}]\+\)}', '\=eval(submatch(1))', 'g')
    5              0.000015   let tabline = substitute(tabline, '%#[^#]\+#', '', 'g')
    5              0.000015   let tabline = substitute(tabline, '%(\([^)]\+\)%)', '\1', 'g')
    5              0.000011   let tabline = substitute(tabline, '%\d\+[TX]', '', 'g')
    5              0.000007   let tabline = substitute(tabline, '%=', '', 'g')
    5              0.000011   let tabline = substitute(tabline, '%\d*\*', '', 'g')
    5              0.000010   if has('tablineat')
                                let tabline = substitute(tabline, '%@[^@]\+@', '', 'g')
    5              0.000005   endif
    5              0.000001   return tabline

FUNCTION  ale#path#FindNearestFile()
    Defined: ~/.vimgo/plugged/ale/autoload/ale/path.vim:37
Called 18 times
Total time:   0.001273
 Self time:   0.001273

count  total (s)   self (s)
   18              0.000145     let l:buffer_filename = fnamemodify(bufname(a:buffer), ':p')
   18              0.000129     let l:buffer_filename = fnameescape(l:buffer_filename)
                            
   18              0.000918     let l:relative_path = findfile(a:filename, l:buffer_filename . ';')
                            
   18              0.000024     if !empty(l:relative_path)
    2              0.000004         return fnamemodify(l:relative_path, ':p')
   16              0.000006     endif
                            
   16              0.000009     return ''

FUNCTION  ale#path#FindNearestDirectory()
    Defined: ~/.vimgo/plugged/ale/autoload/ale/path.vim:52
Called 2 times
Total time:   0.000091
 Self time:   0.000091

count  total (s)   self (s)
    2              0.000005     let l:buffer_filename = fnamemodify(bufname(a:buffer), ':p')
    2              0.000010     let l:buffer_filename = fnameescape(l:buffer_filename)
                            
    2              0.000068     let l:relative_path = finddir(a:directory_name, l:buffer_filename . ';')
                            
    2              0.000002     if !empty(l:relative_path)
                                    return fnamemodify(l:relative_path, ':p')
    2              0.000000     endif
                            
    2              0.000002     return ''

FUNCTION  271()
    Defined: ~/.vimgo/plugged/vim-airline/autoload/airline/builder.vim:8
Called 5 times
Total time:   0.000023
 Self time:   0.000023

count  total (s)   self (s)
    5              0.000022   call add(self._sections, ['|', a:0 ? a:1 : '%='])

FUNCTION  <SNR>179_update_hg_branch()
    Defined: ~/.vimgo/plugged/vim-airline/autoload/airline/extensions/branch.vim:148
Called 101 times
Total time:   0.004146
 Self time:   0.003650

count  total (s)   self (s)
  101   0.000694   0.000198   if airline#util#has_lawrencium()
                                let cmd='LC_ALL=C hg qtop'
                                let stl=lawrencium#statusline()
                                let file=expand('%:p')
                                if !empty(stl) && get(b:, 'airline_do_mq_check', 1)
                                  if g:airline#init#vim_async
                                    noa call airline#async#get_mq_async(cmd, file)
                                  elseif has("nvim")
                                    noa call airline#async#nvim_get_mq_async(cmd, file)
                                  else
                                    " remove \n at the end of the command
                                    let output=system(cmd)[0:-2]
                                    noa call airline#async#mq_output(output, file)
                                  endif
                                endif
                                " do not do mq check anymore
                                let b:airline_do_mq_check = 0
                                if exists("b:mq") && !empty(b:mq)
                                  if stl is# 'default'
                                    " Shorten default a bit
                                    let stl='def'
                                  endif
                                  let stl.=' ['.b:mq.']'
                                endif
                                let s:vcs_config['mercurial'].branch = stl
  101              0.000045   else
  101              0.000157     let s:vcs_config['mercurial'].branch = ''
  101              0.000034   endif

FUNCTION  <SNR>198_GetCounts()
    Defined: ~/.vimgo/plugged/ale/autoload/ale/statusline.vim:97
Called 8 times
Total time:   0.000112
 Self time:   0.000050

count  total (s)   self (s)
    8   0.000044   0.000014     if !s:BufferCacheExists(a:buffer)
                                    return s:CreateCountDict()
    8              0.000004     endif
                            
    8   0.000046   0.000014     call s:UpdateCacheIfNecessary(a:buffer)
                            
    8              0.000009     return g:ale_buffer_info[a:buffer].count

FUNCTION  <SNR>197_StopCurrentJobs()
    Defined: ~/.vimgo/plugged/ale/autoload/ale/engine.vim:459
Called 1 time
Total time:   0.000345
 Self time:   0.000141

count  total (s)   self (s)
    1              0.000009     let l:info = get(g:ale_buffer_info, a:buffer, {})
    1   0.000215   0.000011     call ale#command#StopJobs(a:buffer, 'linter')
                            
                                " Update the active linter list, clearing out anything not running.
    1              0.000004     if a:clear_lint_file_jobs
                                    call ale#command#StopJobs(a:buffer, 'file_linter')
                                    let l:info.active_linter_list = []
    1              0.000001     else
    1              0.000004         let l:lint_file_map = {}
                            
                                    " Use a previously computed map of `lint_file` values to find
                                    " linters that are used for linting files.
    9              0.000023         for [l:lint_file, l:linter] in a:linter_slots
    8              0.000017             if l:lint_file is 1
                                            let l:lint_file_map[l:linter.name] = 1
    8              0.000007             endif
    9              0.000010         endfor
                            
                                    " Keep jobs for linting files when we're only linting buffers.
    1              0.000011         call filter(l:info.active_linter_list, 'get(l:lint_file_map, v:val.name)')
    1              0.000002     endif

FUNCTION  airline#extensions#tabline#formatters#default#format()
    Defined: ~/.vimgo/plugged/vim-airline/autoload/airline/extensions/tabline/formatters/default.vim:7
Called 80 times
Total time:   0.003375
 Self time:   0.002361

count  total (s)   self (s)
   80              0.000132     let fnametruncate = get(g:, 'airline#extensions#tabline#fnametruncate', 0)
   80              0.000142     let fmod = get(g:, 'airline#extensions#tabline#fnamemod', ':~:.')
   80              0.000049     let _ = ''
                            
   80              0.000112     let name = bufname(a:bufnr)
   80              0.000070     if empty(name)
                                  let _ = '[No Name]'
   80              0.000138     elseif name =~ 'term://'
                                  " Neovim Terminal
                                  let _ = substitute(name, '\(term:\)//.*:\(.*\)', '\1 \2', '')
   80              0.000025     else
   80              0.000112       if get(g:, 'airline#extensions#tabline#fnamecollapse', 1)
                                    " Does not handle non-ascii characters like Cyrillic: 'D//t.c'
                                    "let _ .= substitute(fnamemodify(name, fmod), '\v\w\zs.{-}\ze(\\|/)', '', 'g')
   80              0.000389         let _ = pathshorten(fnamemodify(name, fmod))
                                  else
                                    let _ = fnamemodify(name, fmod)
   80              0.000026       endif
   80              0.000167       if a:bufnr != bufnr('%') && fnametruncate && strlen(_) > fnametruncate
                                    let _ = airline#util#strcharpart(_, 0, fnametruncate)
   80              0.000022       endif
   80              0.000024     endif
                            
   80   0.001373   0.000359     return airline#extensions#tabline#formatters#default#wrap_name(a:bufnr, _)

FUNCTION  <SNR>222_ShouldOpen()
    Defined: ~/.vimgo/plugged/ale/autoload/ale/list.vim:41
Called 1 time
Total time:   0.000011
 Self time:   0.000006

count  total (s)   self (s)
    1   0.000007   0.000002     let l:val = ale#Var(a:buffer, 'open_list')
    1              0.000002     let l:saved = getbufvar(a:buffer, 'ale_save_event_fired', 0)
                            
    1              0.000002     return l:val > 0 ? a:loclist_len >= l:val : l:val is# 'on_save' && l:saved

FUNCTION  <SNR>102_ExitingOneLineScope()
    Defined: ~/.vimgo/plugged/yats.vim/indent/typescript.vim:251
Called 1 time
Total time:   0.000465
 Self time:   0.000031

count  total (s)   self (s)
    1   0.000199   0.000004   let msl = s:GetMSL(a:lnum, 1)
    1              0.000002   if msl > 0
                                " if the current line is in a one line scope ..
    1   0.000020   0.000005     if s:Match(msl, s:one_line_scope_regex)
                                  return 0
    1              0.000000     else
    1   0.000213   0.000006       let prev_msl = s:GetMSL(msl - 1, 1)
    1   0.000021   0.000004       if s:Match(prev_msl, s:one_line_scope_regex)
                                    return prev_msl
    1              0.000001       endif
    1              0.000001     endif
    1              0.000001   endif
    1              0.000001   return 0

FUNCTION  coc#pum#_close()
    Defined: ~/.vimgo/plugged/coc.nvim/autoload/coc/pum.vim:94
Called 11 times
Total time:   0.001892
 Self time:   0.000124

count  total (s)   self (s)
   11   0.000127   0.000038   if coc#float#valid(s:pum_winid)
    4   0.001690   0.000011     call s:close_pum()
    4              0.000004     if s:is_vim
    4              0.000021       call timer_start(0, { -> execute('redraw')})
    4              0.000001     endif
   11              0.000004   endif

FUNCTION  airline#builder#should_change_group()
    Defined: ~/.vimgo/plugged/vim-airline/autoload/airline/builder.vim:130
Called 25 times
Total time:   0.004393
 Self time:   0.000280

count  total (s)   self (s)
   25              0.000026   if a:group1 == a:group2
                                return 0
   25              0.000005   endif
   25   0.002287   0.000074   let color1 = airline#highlighter#get_highlight(a:group1)
   25   0.001968   0.000068   let color2 = airline#highlighter#get_highlight(a:group2)
   25              0.000074   return color1[1] != color2[1] || color1[0] != color2[0] ||  color1[2] != color2[2] || color1[3] != color2[3]

FUNCTION  airline#extensions#append_to_section()
    Defined: ~/.vimgo/plugged/vim-airline/autoload/airline/extensions.vim:54
Called 4 times
Total time:   0.000115
 Self time:   0.000053

count  total (s)   self (s)
    4   0.000091   0.000029   call <sid>check_defined_section(a:name)
    4              0.000023   let w:airline_section_{a:name} .= a:value

FUNCTION  ale#handlers#deno#GetProjectRoot()
    Defined: ~/.vimgo/plugged/ale/autoload/ale/handlers/deno.vim:24
Called 1 time
Total time:   0.000287
 Self time:   0.000041

count  total (s)   self (s)
    1   0.000012   0.000004     let l:project_root = ale#Var(a:buffer, 'deno_lsp_project_root')
                            
    1              0.000001     if !empty(l:project_root)
                                    return l:project_root
    1              0.000000     endif
                            
    1              0.000003     let l:possible_project_roots = [   'deno.json',   'deno.jsonc',   'tsconfig.json',   '.git',   bufname(a:buffer),]
                            
    3              0.000002     for l:possible_root in l:possible_project_roots
    3   0.000153   0.000006         let l:project_root = ale#path#FindNearestFile(a:buffer, l:possible_root)
                            
    3              0.000003         if empty(l:project_root)
    2   0.000095   0.000004             let l:project_root = ale#path#FindNearestDirectory(a:buffer, l:possible_root)
    3              0.000001         endif
                            
    3              0.000002         if !empty(l:project_root)
                                        " dir:p expands to /full/path/to/dir/ whereas
                                        " file:p expands to /full/path/to/file (no trailing slash)
                                        " Appending '/' ensures that :h:h removes the path's last segment
                                        " regardless of whether it is a directory or not.
    1              0.000003             return fnamemodify(l:project_root . '/', ':p:h:h')
    2              0.000000         endif
    2              0.000002     endfor
                            
                                return ''

FUNCTION  <SNR>197_RemoveProblemsForDisabledLinters()
    Defined: ~/.vimgo/plugged/ale/autoload/ale/engine.vim:487
Called 1 time
Total time:   0.000091
 Self time:   0.000091

count  total (s)   self (s)
                                " Figure out which linters are still enabled, and remove
                                " problems for linters which are no longer enabled.
                                " Problems from other sources will be kept.
    1              0.000004     let l:name_map = {}
                            
    9              0.000020     for l:linter in a:linters
    8              0.000034         let l:name_map[l:linter.name] = 1
    9              0.000010     endfor
                            
    1              0.000015     call filter(   get(g:ale_buffer_info[a:buffer], 'loclist', []),   'get(v:val, ''from_other_source'') || get(l:name_map, get(v:val, ''linter_name''))',)

FUNCTION  coc#pum#info()
    Defined: ~/.vimgo/plugged/coc.nvim/autoload/coc/pum.vim:195
Called 20 times
Total time:   0.000620
 Self time:   0.000620

count  total (s)   self (s)
   20              0.000035   let bufnr = winbufnr(s:pum_winid)
   20              0.000034   let words = getwinvar(s:pum_winid, 'words', [])
   20              0.000040   let word = s:pum_index < 0 ? '' : get(words, s:pum_index, '')
   20              0.000047   let pretext = strpart(getline('.'), 0, col('.') - 1)
   20              0.000087   let base = { 'word': word, 'index': s:pum_index, 'size': s:pum_size, 'startcol': s:start_col, 'inserted': s:inserted ? v:true : v:false, 'reversed': s:reversed ? v:true : v:false, }
   20              0.000010   if s:is_vim
   20              0.000042     let pos = popup_getpos(s:pum_winid)
   20              0.000157     let border = has_key(popup_getoptions(s:pum_winid), 'border')
   20              0.000032     let add = pos['scrollbar'] && border ? 1 : 0
   20              0.000111     return extend(base, { 'scrollbar': pos['scrollbar'], 'row': pos['line'] - 1, 'col': pos['col'] - 1, 'width': pos['width'] + add, 'height': pos['height'], 'border': border, })
                              else
                                let scrollbar = coc#float#get_related(s:pum_winid, 'scrollbar')
                                let winid = coc#float#get_related(s:pum_winid, 'border', s:pum_winid)
                                let pos = nvim_win_get_position(winid)
                                return extend(base, { 'scrollbar': scrollbar && nvim_win_is_valid(scrollbar) ? 1 : 0, 'row': pos[0], 'col': pos[1], 'width': nvim_win_get_width(winid), 'height': nvim_win_get_height(winid), 'border': winid != s:pum_winid, })
                              endif

FUNCTION  <SNR>230_get_tabnr()
    Defined: ~/.vimgo/plugged/coc.nvim/autoload/coc/api.vim:518
Called 37 times
Total time:   0.000549
 Self time:   0.000196

count  total (s)   self (s)
   37              0.000035   let ref = {}
   37   0.000465   0.000112   call s:win_execute(a:winid, 'tabpagenr()', ref)
   37              0.000043   return get(ref, 'out', 0)

FUNCTION  coc#cursor#screen_pos()
    Defined: ~/.vimgo/plugged/coc.nvim/autoload/coc/cursor.vim:4
Called 17 times
Total time:   0.000128
 Self time:   0.000128

count  total (s)   self (s)
   17              0.000028   let nr = winnr()
   17              0.000037   let [row, col] = win_screenpos(nr)
   17              0.000046   return [row + winline() - 2, col + wincol() - 2]

FUNCTION  airline#extensions#fzf#apply()
    Defined: ~/.vimgo/plugged/vim-airline/autoload/airline/extensions/fzf.vim:28
Called 4 times
Total time:   0.000043
 Self time:   0.000043

count  total (s)   self (s)
    4              0.000007   if &filetype ==# 'fzf'
                                let spc = g:airline_symbols.space
                                call a:1.add_section('airline_a', spc.'FZF'.spc)
                                call a:1.add_section('airline_c', '')
                                return 1
    4              0.000002   endif

FUNCTION  coc#float#close_related()
    Defined: ~/.vimgo/plugged/coc.nvim/autoload/coc/float.vim:722
Called 7 times
Total time:   0.000797
 Self time:   0.000192

count  total (s)   self (s)
    7   0.000089   0.000015   if !coc#float#valid(a:winid)
                                return
    7              0.000002   endif
    7   0.000337   0.000017   let timer = coc#window#get_var(a:winid, 'timer', 0)
    7              0.000006   if timer
                                call timer_stop(timer)
    7              0.000001   endif
    7              0.000010   let kind = get(a:, 1, '')
    7   0.000230   0.000019   let winids = coc#window#get_var(a:winid, 'related', [])
    7              0.000008   for id in winids
                                let curr = coc#window#get_var(id, 'kind', '')
                                if empty(kind) || curr ==# kind
                                  if curr == 'list'
                                    call coc#float#close(id, 1)
                                  elseif s:is_vim
                                    " vim doesn't throw
                                    noa call popup_close(id)
                                  else
                                    silent! noa call nvim_win_close(id, 1)
                                  endif
                                endif
    7              0.000006   endfor

FUNCTION  ale#handlers#xo#GetExecutable()
    Defined: ~/.vimgo/plugged/ale/autoload/ale/handlers/xo.vim:9
Called 1 time
Total time:   0.000202
 Self time:   0.000007

count  total (s)   self (s)
    1   0.000013   0.000002     let l:type = ale#handlers#xo#GetType(a:buffer)
                            
    1   0.000187   0.000003     return ale#path#FindExecutable(a:buffer, l:type . '_xo', [   'node_modules/xo/cli.js',   'node_modules/.bin/xo',])

FUNCTION  airline#extensions#coc#get_current_function()
    Defined: ~/.vimgo/plugged/vim-airline/autoload/airline/extensions/coc.vim:45
Called 101 times
Total time:   0.000188
 Self time:   0.000188

count  total (s)   self (s)
  101              0.000162   return get(b:, 'coc_current_function', '')

FUNCTION  299()
    Defined: ~/.vimgo/plugged/coc.nvim/autoload/coc/api.vim:142
Called 22 times
Total time:   0.000463
 Self time:   0.000420

count  total (s)   self (s)
   22   0.000439   0.000396   return eval(a:expr)

FUNCTION  <SNR>80_ulen()
    Defined: ~/.vimgo/plugged/auto-pairs/plugin/auto-pairs.vim:119
Called 1 time
Total time:   0.000006
 Self time:   0.000006

count  total (s)   self (s)
    1              0.000005   return len(split(a:s, '\zs'))

FUNCTION  airline#util#is_popup_window()
    Defined: ~/.vimgo/plugged/vim-airline/autoload/airline/util.vim:214
Called 4 times
Total time:   0.000048
 Self time:   0.000048

count  total (s)   self (s)
                               " Keep the statusline active if it's a popup window
    4              0.000015    if exists('*win_gettype')
    4              0.000026      return win_gettype(a:winnr) ==# 'popup' || win_gettype(a:winnr) ==# 'autocmd'
                               else
                                  return airline#util#getwinvar(a:winnr, '&buftype', '') ==# 'popup'
                              endif

FUNCTION  <SNR>178_get_hunks_empty()
    Defined: ~/.vimgo/plugged/vim-airline/autoload/airline/extensions/hunks.vim:65
Called 101 times
Total time:   0.000110
 Self time:   0.000110

count  total (s)   self (s)
  101              0.000087   return ''

FUNCTION  <SNR>102_IsInStringOrComment()
    Defined: ~/.vimgo/plugged/yats.vim/indent/typescript.vim:68
Called 5 times
Total time:   0.000125
 Self time:   0.000125

count  total (s)   self (s)
    5              0.000124   return synIDattr(synID(a:lnum, a:col, 1), 'name') =~ s:syng_strcom

FUNCTION  <SNR>178_coc_git_enabled()
    Defined: ~/.vimgo/plugged/vim-airline/autoload/airline/extensions/hunks.vim:18
Called 101 times
Total time:   0.000572
 Self time:   0.000572

count  total (s)   self (s)
  101              0.000321   if !exists("*CocAction") || !get(g:, 'airline#extensions#hunks#coc_git', 0)
                                 " coc-git extension is disabled by default
                                 " unless specifically being enabled by the user
                                 " (as requested from coc maintainer)
  101              0.000069     return 0
                              endif
                              return 1

FUNCTION  ale#sign#FindCurrentSigns()
    Defined: ~/.vimgo/plugged/ale/autoload/ale/sign.vim:250
Called 1 time
Total time:   0.000023
 Self time:   0.000006

count  total (s)   self (s)
    1              0.000002     if exists('*sign_getplaced')
    1   0.000021   0.000004         return ale#sign#ParseSignsWithGetPlaced(a:buffer)
                                else
                                    let l:line_list = ale#sign#ReadSigns(a:buffer)
                            
                                    return ale#sign#ParseSigns(l:line_list)
                                endif

FUNCTION  coc#util#all_state()
    Defined: ~/.vimgo/plugged/coc.nvim/autoload/coc/util.vim:315
Called 3 times
Total time:   0.000053
 Self time:   0.000053

count  total (s)   self (s)
    3              0.000052   return { 'bufnr': bufnr('%'), 'winid': win_getid(), 'bufnrs': map(getbufinfo({'bufloaded': 1}),'v:val["bufnr"]'), 'winids': map(getwininfo(),'v:val["winid"]'), }

FUNCTION  airline#extensions#searchcount#apply()
    Defined: ~/.vimgo/plugged/vim-airline/autoload/airline/extensions/searchcount.vim:15
Called 4 times
Total time:   0.000148
 Self time:   0.000033

count  total (s)   self (s)
    4   0.000146   0.000031   call airline#extensions#append_to_section('y', '%{v:hlsearch ? airline#extensions#searchcount#status() : ""}')

FUNCTION  airline#parts#spell()
    Defined: ~/.vimgo/plugged/vim-airline/autoload/airline/parts.vim:145
Called 97 times
Total time:   0.003088
 Self time:   0.003088

count  total (s)   self (s)
   97              0.000759   let spelllang = g:airline_detect_spelllang ? printf(" [%s]", toupper(substitute(&spelllang, ',', '/', 'g'))) : ''
   97              0.000371   if g:airline_detect_spell && (&spell || (exists('g:airline_spell_check_command') && eval(g:airline_spell_check_command)))
                            
                                if g:airline_detect_spelllang !=? '0' && g:airline_detect_spelllang ==? 'flag'
                                  let spelllang = tolower(&spelllang)
                                  if has_key(s:flags, spelllang)
                                    return s:flags[spelllang]
                                  elseif has_key(s:flags_noregion, spelllang)
                                    return s:flags_noregion[spelllang]
                                  endif
                                endif
                            
                                let winwidth = airline#util#winwidth()
                                if winwidth >= 90
                                  return g:airline_symbols.spell . spelllang
                                elseif winwidth >= 70
                                  return g:airline_symbols.spell
                                elseif !empty(g:airline_symbols.spell)
                                  return split(g:airline_symbols.spell, '\zs')[0]
                                endif
   97              0.000032   endif
   97              0.000057   return ''

FUNCTION  ale#linter#GetAll()
    Defined: ~/.vimgo/plugged/ale/autoload/ale/linter.vim:277
Called 1 time
Total time:   0.000139
 Self time:   0.000112

count  total (s)   self (s)
                                " Don't return linters in the sandbox.
                                " Otherwise a sandboxed script could modify them.
    1   0.000034   0.000007     if ale#util#InSandbox()
                                    return []
    1              0.000001     endif
                            
    1              0.000006     let l:combined_linters = []
                            
    2              0.000009     for l:filetype in a:filetypes
                                    " Load linters from runtimepath if we haven't done that yet.
    1              0.000008         if !has_key(s:runtime_loaded_map, l:filetype)
                                        execute 'silent! runtime! ale_linters/' . l:filetype . '/*.vim'
                            
                                        let s:runtime_loaded_map[l:filetype] = 1
    1              0.000001         endif
                            
    1              0.000021         call extend(l:combined_linters, get(s:linters, l:filetype, []))
    2              0.000004     endfor
                            
    1              0.000004     return l:combined_linters

FUNCTION  <SNR>171_invoke_funcrefs()
    Defined: ~/.vimgo/plugged/vim-airline/autoload/airline.vim:205
Called 4 times
Total time:   0.024315
 Self time:   0.000151

count  total (s)   self (s)
    4   0.000163   0.000026   let builder = airline#builder#new(a:context)
    4   0.005295   0.000055   let err = airline#util#exec_funcrefs(a:funcrefs + s:core_funcrefs, builder, a:context)
    4              0.000004   if err == 1
    4   0.018808   0.000021     let a:context.line = builder.build()
    4              0.000009     let s:contexts[a:context.winnr] = a:context
    4              0.000007     let option = get(g:, 'airline_statusline_ontop', 0) ? '&tabline' : '&statusline'
    4              0.000023     call setwinvar(a:context.winnr, option, '%!airline#statusline('.a:context.winnr.')')
    4              0.000001   endif

FUNCTION  ale#util#FindItemAtCursor()
    Defined: ~/.vimgo/plugged/ale/autoload/ale/util.vim:485
Called 4 times
Total time:   0.000076
 Self time:   0.000052

count  total (s)   self (s)
    4              0.000010     let l:info = get(g:ale_buffer_info, a:buffer, {})
    4              0.000007     let l:loclist = get(l:info, 'loclist', [])
    4              0.000007     let l:pos = getpos('.')
    4   0.000038   0.000014     let l:index = ale#util#BinarySearch(l:loclist, a:buffer, l:pos[1], l:pos[2])
    4              0.000007     let l:loc = l:index >= 0 ? l:loclist[l:index] : {}
                            
    4              0.000006     return [l:info, l:loc]

FUNCTION  272()
    Defined: ~/.vimgo/plugged/vim-airline/autoload/airline/builder.vim:12
Called 2 times
Total time:   0.000038
 Self time:   0.000027

count  total (s)   self (s)
    2              0.000012   let spc = empty(a:contents) ? '' : g:airline_symbols.space
    2   0.000026   0.000015   call self.add_section(a:group, spc.a:contents.spc)

FUNCTION  <SNR>179_update_branch()
    Defined: ~/.vimgo/plugged/vim-airline/autoload/airline/extensions/branch.vim:183
Called 101 times
Total time:   0.024530
 Self time:   0.003628

count  total (s)   self (s)
  303              0.000504   for vcs in keys(s:vcs_config)
  202   0.021908   0.001006     call {s:vcs_config[vcs].update_branch}()
  202              0.000459     if b:buffer_vcs_config[vcs].branch != s:vcs_config[vcs].branch
                                  let b:buffer_vcs_config[vcs].branch = s:vcs_config[vcs].branch
                                  unlet! b:airline_head
  202              0.000089     endif
  303              0.000209   endfor

FUNCTION  ale#linter#ResolveFiletype()
    Defined: ~/.vimgo/plugged/ale/autoload/ale/linter.vim:326
Called 1 time
Total time:   0.000163
 Self time:   0.000033

count  total (s)   self (s)
    1   0.000148   0.000018     let l:filetype = s:GetAliasedFiletype(a:original_filetype)
                            
    1              0.000007     if type(l:filetype) isnot v:t_list
    1              0.000004         return [l:filetype]
                                endif
                            
                                return l:filetype

FUNCTION  <SNR>222_CloseWindowIfNeeded()
    Defined: ~/.vimgo/plugged/ale/autoload/ale/list.vim:242
Called 1 time
Total time:   0.000017
 Self time:   0.000004

count  total (s)   self (s)
    1   0.000016   0.000003     if ale#Var(a:buffer, 'keep_list_window_open') || s:ShouldClose(a:buffer)
    1              0.000001         return
                                endif
                            
                                let l:did_close_any_list = 0
                            
                                try
                                    " Only close windows if the quickfix list or loclist is completely empty,
                                    " including errors set through other means.
                                    if g:ale_set_quickfix
                                        if empty(getqflist())
                                            cclose
                                            let l:did_close_any_list = 1
                                        endif
                                    else
                                        let l:win_ids = s:WinFindBuf(a:buffer)
                            
                                        for l:win_id in l:win_ids
                                            if g:ale_set_loclist && empty(getloclist(l:win_id))
                                                lclose
                                                let l:did_close_any_list = 1
                                            endif
                                        endfor
                                    endif
                                " Ignore 'Cannot close last window' errors.
                                catch /E444/
                                endtry
                            
                                if l:did_close_any_list
                                    call s:RestoreViewIfNeeded(a:buffer)
                                endif

FUNCTION  <SNR>73_HandleWinScrolled()
    Defined: ~/.vimgo/plugged/coc.nvim/plugin/coc.vim:297
Called 1 time
Total time:   0.000035
 Self time:   0.000005

count  total (s)   self (s)
    1              0.000002   if getwinvar(a:winid, 'float', 0)
                                call coc#float#nvim_scrollbar(a:winid)
    1              0.000000   endif
    1   0.000032   0.000002   call s:Autocmd('WinScrolled', a:winid)

FUNCTION  ale#util#Mode()
    Defined: ~/.vimgo/plugged/ale/autoload/ale/util.vim:5
Called 5 times
Total time:   0.000023
 Self time:   0.000023

count  total (s)   self (s)
    5              0.000021     return call('mode', a:000)

FUNCTION  coc#util#synname()
    Defined: ~/.vimgo/plugged/coc.nvim/autoload/coc/util.vim:82
Called 16 times
Total time:   0.071162
 Self time:   0.071162

count  total (s)   self (s)
   16              0.071160   return synIDattr(synID(line('.'), col('.') - 1, 1), 'name')

FUNCTION  coc#dict#pick()
    Defined: ~/.vimgo/plugged/coc.nvim/autoload/coc/dict.vim:24
Called 17 times
Total time:   0.000311
 Self time:   0.000311

count  total (s)   self (s)
   17              0.000016   let res = {}
   68              0.000071   for key in keys(a:dict)
   51              0.000073     if index(a:keys, key) != -1
   17              0.000031       let res[key] = a:dict[key]
   51              0.000011     endif
   68              0.000030   endfor
   17              0.000010   return res

FUNCTION  ale#list#SetLists()
    Defined: ~/.vimgo/plugged/ale/autoload/ale/list.vim:207
Called 1 time
Total time:   0.000020
 Self time:   0.000013

count  total (s)   self (s)
    1              0.000003     if get(g:, 'ale_set_lists_synchronously') == 1|| getbufvar(a:buffer, 'ale_save_event_fired', 0)
                                    " Update lists immediately if running a test synchronously, or if the
                                    " buffer was saved.
                                    "
                                    " The lists need to be updated immediately when saving a buffer so
                                    " that we can reliably close window automatically, if so configured.
                                    call s:SetListsImpl(-1, a:buffer, a:loclist)
    1              0.000000     else
    1   0.000013   0.000006         call ale#util#StartPartialTimer(   0,   function('s:SetListsImpl'),   [a:buffer, a:loclist],)
    1              0.000001     endif

FUNCTION  ale#util#InSandbox()
    Defined: ~/.vimgo/plugged/ale/autoload/ale/util.vim:290
Called 6 times
Total time:   0.000129
 Self time:   0.000126

count  total (s)   self (s)
    6              0.000011     try
    6   0.000047   0.000044         let &l:equalprg=&l:equalprg
                                catch /E48/
                                    " E48 is the sandbox error.
                                    return 1
    6              0.000007     endtry
                            
    6              0.000007     return 0

FUNCTION  <SNR>200_Lint()
    Defined: ~/.vimgo/plugged/ale/autoload/ale.vim:99
Called 1 time
Total time:   0.383314
 Self time:   0.000170

count  total (s)   self (s)
                                " Use the filetype from the buffer
    1              0.000010     let l:filetype = getbufvar(a:buffer, '&filetype')
    1   0.001502   0.000034     let l:linters = ale#linter#Get(l:filetype)
    1   0.000130   0.000024     let l:linters = ale#linter#RemoveIgnored(a:buffer, l:filetype, l:linters)
                            
                                " Tell other sources that they can start checking the buffer now.
    1              0.000006     let g:ale_want_results_buffer = a:buffer
    1   0.000044   0.000030     silent doautocmd <nomodeline> User ALEWantResults
    1              0.000005     unlet! g:ale_want_results_buffer
                            
                                " Don't set up buffer data and so on if there are no linters to run.
    1              0.000012     if !has_key(g:ale_buffer_info, a:buffer) && empty(l:linters)
                                    return
    1              0.000002     endif
                            
                                " Clear lint_file linters, or only run them if the file exists.
    1              0.000015     let l:lint_file = empty(l:linters)   || (a:should_lint_file && filereadable(expand('#' . a:buffer . ':p')))
                            
    1   0.381571   0.000015     call ale#engine#RunLinters(a:buffer, l:linters, l:lint_file)

FUNCTION  yats#IsInMultilineComment()
    Defined: ~/.vimgo/plugged/yats.vim/autoload/yats.vim:8
Called 2 times
Total time:   0.000078
 Self time:   0.000038

count  total (s)   self (s)
    2   0.000078   0.000038   return !yats#IsLineComment(a:lnum, a:col) && synIDattr(synID(a:lnum, a:col, 1), 'name') =~ s:syng_multiline

FUNCTION  airline#parts#crypt()
    Defined: ~/.vimgo/plugged/vim-airline/autoload/airline/parts.vim:59
Called 97 times
Total time:   0.000400
 Self time:   0.000400

count  total (s)   self (s)
   97              0.000363   return g:airline_detect_crypt && exists("+key") && !empty(&key) ? g:airline_symbols.crypt : ''

FUNCTION  airline#extensions#keymap#status()
    Defined: ~/.vimgo/plugged/vim-airline/autoload/airline/extensions/keymap.vim:10
Called 97 times
Total time:   0.002616
 Self time:   0.002616

count  total (s)   self (s)
   97              0.000454   if (get(g:, 'airline#extensions#keymap#enabled', 1) && has('keymap'))
   97              0.000259     let short_codes = get(g:, 'airline#extensions#keymap#short_codes', {})
   97              0.000238     let label = get(g:, 'airline#extensions#keymap#label', g:airline_symbols.keymap)
   97              0.000205     let default = get(g:, 'airline#extensions#keymap#default', '')
   97              0.000112     if (label !=# '')
   97              0.000203       let label .= ' '
   97              0.000037     endif
   97              0.000104     let keymap = &keymap
   97              0.000177     if has_key(short_codes, keymap)
                                  let keymap = short_codes[keymap]
   97              0.000044     endif
   97              0.000454     return printf('%s', (!empty(keymap) && &iminsert ? (label . keymap) : (!empty(default) ? label . default : default)))
                              else
                                return ''
                              endif

FUNCTION  <SNR>66_Slash()
    Defined: ~/.vimgo/plugged/vim-fugitive/plugin/fugitive.vim:502
Called 4 times
Total time:   0.000005
 Self time:   0.000005

count  total (s)   self (s)
    4              0.000004     return a:path

FUNCTION  airline#extensions#branch#head()
    Defined: ~/.vimgo/plugged/vim-airline/autoload/airline/extensions/branch.vim:249
Called 101 times
Total time:   0.032636
 Self time:   0.001959

count  total (s)   self (s)
  101              0.000207   if !exists('b:buffer_vcs_config')
                                call s:init_buffer()
  101              0.000039   endif
                            
  101   0.024819   0.000289   call s:update_branch()
  101   0.006205   0.000312   call s:update_untracked()
                            
  101              0.000256   if exists('b:airline_head') && !empty(b:airline_head)
   97              0.000080     return b:airline_head
    4              0.000002   endif
                            
    4              0.000005   let b:airline_head = ''
    4              0.000011   let vcs_priority = get(g:, "airline#extensions#branch#vcs_priority", ["git", "mercurial"])
                            
    4              0.000005   let heads = []
   12              0.000010   for vcs in vcs_priority
    8              0.000013     if !empty(b:buffer_vcs_config[vcs].branch)
    4              0.000008       let heads += [vcs]
    8              0.000002     endif
   12              0.000009   endfor
                            
    8              0.000005   for vcs in heads
    4              0.000005     if !empty(b:airline_head)
                                  let b:airline_head .= ' | '
    4              0.000001     endif
    4              0.000006     if len(heads) > 1
                                  let b:airline_head .= s:vcs_config[vcs].exe .':'
    4              0.000000     endif
    4   0.000289   0.000035     let b:airline_head .= s:format_name({s:vcs_config[vcs].display_branch}())
    4              0.000008     let additional = b:buffer_vcs_config[vcs].untracked
    4              0.000013     if empty(additional) && has_key(b:buffer_vcs_config[vcs], 'dirty') && b:buffer_vcs_config[vcs].dirty
                                  let additional = g:airline_symbols['dirty']
    4              0.000003     endif
    4              0.000007     let b:airline_head .= additional
    8              0.000005   endfor
                            
    4              0.000005   if empty(heads)
                                if airline#util#has_vcscommand()
                                  noa call VCSCommandEnableBufferSetup()
                                  if exists('b:VCSCommandBufferInfo')
                                    let b:airline_head = s:format_name(get(b:VCSCommandBufferInfo, 0, ''))
                                  endif
                                endif
    4              0.000004   endif
                            
    4              0.000004   if empty(heads)
                                if airline#util#has_custom_scm()
                                  try
                                    let Fn = function(g:airline#extensions#branch#custom_head)
                                    let b:airline_head = Fn()
                                  endtry
                                endif
    4              0.000003   endif
                            
    4              0.000010   if exists("g:airline#extensions#branch#displayed_head_limit")
                                let w:displayed_head_limit = g:airline#extensions#branch#displayed_head_limit
                                if strwidth(b:airline_head) > w:displayed_head_limit - 1
                                  let b:airline_head = airline#util#strcharpart(b:airline_head, 0, w:displayed_head_limit - 1) . (&encoding ==? 'utf-8' ?  '' : '.')
                                endif
    4              0.000002   endif
                            
    4              0.000003   return b:airline_head

FUNCTION  <SNR>243_close_pum()
    Defined: ~/.vimgo/plugged/coc.nvim/autoload/coc/pum.vim:133
Called 4 times
Total time:   0.001679
 Self time:   0.000070

count  total (s)   self (s)
    4   0.000045   0.000009   call s:clear_virtual_text()
    4   0.001266   0.000011   call coc#float#close(s:pum_winid, 1)
    4              0.000004   let s:pum_winid = 0
    4              0.000004   let s:pum_size = 0
    4   0.000044   0.000017   let winid = coc#float#get_float_by_kind('pumdetail')
    4              0.000002   if winid
    1   0.000271   0.000003     call coc#float#close(winid, 1)
    4              0.000000   endif
    4   0.000033   0.000010   call s:restore_indentkeys()

FUNCTION  <SNR>222_WinFindBuf()
    Defined: ~/.vimgo/plugged/ale/autoload/ale/list.vim:96
Called 1 time
Total time:   0.000004
 Self time:   0.000004

count  total (s)   self (s)
    1              0.000003     return exists('*win_findbuf') ? win_findbuf(str2nr(a:buffer)) : [0]

FUNCTION  ale#handlers#eslint#GetExecutable()
    Defined: ~/.vimgo/plugged/ale/autoload/ale/handlers/eslint.vim:38
Called 1 time
Total time:   0.000322
 Self time:   0.000003

count  total (s)   self (s)
    1   0.000322   0.000003     return ale#path#FindExecutable(a:buffer, 'javascript_eslint', s:executables)

FUNCTION  <SNR>233_get_borderchars()
    Defined: ~/.vimgo/plugged/coc.nvim/autoload/coc/float.vim:1415
Called 7 times
Total time:   0.000044
 Self time:   0.000044

count  total (s)   self (s)
    7              0.000012   let borderchars = get(a:config, 'borderchars', [])
    7              0.000006   if !empty(borderchars)
                                return borderchars
    7              0.000002   endif
    7              0.000016   return get(a:config, 'rounded', 0) ? s:rounded_borderchars : s:borderchars

FUNCTION  ale#lsp_linter#FindProjectRoot()
    Defined: ~/.vimgo/plugged/ale/autoload/ale/lsp_linter.vim:223
Called 2 times
Total time:   0.000411
 Self time:   0.000065

count  total (s)   self (s)
    2              0.000008     let l:buffer_ale_root = getbufvar(   a:buffer,   'ale_root',   getbufvar(a:buffer, 'ale_lsp_root', {}))
                            
    2              0.000004     if type(l:buffer_ale_root) is v:t_string
                                    return l:buffer_ale_root
    2              0.000000     endif
                            
                                " Try to get a buffer-local setting for the root
    2              0.000003     if has_key(l:buffer_ale_root, a:linter.name)
                                    let l:Root = l:buffer_ale_root[a:linter.name]
                            
                                    if type(l:Root) is v:t_func
                                        return l:Root(a:buffer)
                                    else
                                        return l:Root
                                    endif
    2              0.000001     endif
                            
    2              0.000003     let l:global_root = g:ale_root
                            
    2              0.000004     if empty(g:ale_root) && exists('g:ale_lsp_root')
                                    let l:global_root = g:ale_lsp_root
    2              0.000000     endif
                            
                                " Try to get a global setting for the root
    2              0.000003     if has_key(l:global_root, a:linter.name)
                                    let l:Root = l:global_root[a:linter.name]
                            
                                    if type(l:Root) is v:t_func
                                        return l:Root(a:buffer)
                                    else
                                        return l:Root
                                    endif
    2              0.000000     endif
                            
                                " Fall back to the linter-specific configuration
    2              0.000002     if has_key(a:linter, 'project_root')
    2              0.000005         let l:Root = a:linter.project_root
                            
    2   0.000355   0.000009         return type(l:Root) is v:t_func ? l:Root(a:buffer) : l:Root
                                endif
                            
                                return ale#util#GetFunction(a:linter.project_root_callback)(a:buffer)

FUNCTION  <SNR>102_InOneLineScope()
    Defined: ~/.vimgo/plugged/yats.vim/indent/typescript.vim:243
Called 1 time
Total time:   0.000220
 Self time:   0.000014

count  total (s)   self (s)
    1   0.000193   0.000004   let msl = s:GetMSL(a:lnum, 1)
    1   0.000023   0.000006   if msl > 0 && s:Match(msl, s:one_line_scope_regex)
                                return msl
    1              0.000001   endif
    1              0.000001   return 0

FUNCTION  <SNR>67_airline_refresh()
    Defined: ~/.vimgo/plugged/vim-airline/plugin/airline.vim:224
Called 4 times
Total time:   0.025885
 Self time:   0.000285

count  total (s)   self (s)
                              " a:1, fast refresh, do not reload the theme
    4              0.000024   let fast=!empty(get(a:000, 0, 0))
    4              0.000010   if !exists("#airline")
                                " disabled
                                return
    4              0.000003   endif
    4   0.000383   0.000116   call airline#util#doautocmd('AirlineBeforeRefresh')
    4   0.000182   0.000045   call airline#highlighter#reset_hlcache()
    4              0.000006   if !fast
                                call airline#load_theme()
    4              0.000003   endif
    4   0.025224   0.000039   call airline#update_statusline()
    4   0.000021   0.000010   call airline#update_tabline()

FUNCTION  coc#util#change_info()
    Defined: ~/.vimgo/plugged/coc.nvim/autoload/coc/util.vim:61
Called 36 times
Total time:   0.000283
 Self time:   0.000283

count  total (s)   self (s)
   36              0.000264   return {'lnum': line('.'), 'col': col('.'), 'line': getline('.'), 'changedtick': b:changedtick}

FUNCTION  coc#compat#buf_line_count()
    Defined: ~/.vimgo/plugged/coc.nvim/autoload/coc/compat.vim:22
Called 1 time
Total time:   0.000016
 Self time:   0.000016

count  total (s)   self (s)
    1              0.000004   if exists('*nvim_buf_line_count')
                                return nvim_buf_line_count(a:bufnr)
    1              0.000001   endif
    1              0.000003   if bufnr('%') == a:bufnr
    1              0.000002     return line('$')
                              endif
                              if exists('*getbufinfo')
                                let info = getbufinfo(a:bufnr)
                                if empty(info)
                                  return 0
                                endif
                                " vim 8.1 has getbufinfo but no linecount
                                if has_key(info[0], 'linecount')
                                  return info[0]['linecount']
                                endif
                              endif
                              if exists('*getbufline')
                                let lines = getbufline(a:bufnr, 1, '$')
                                return len(lines)
                              endif
                              let curr = bufnr('%')
                              execute 'noa buffer '.a:bufnr
                              let n = line('$')
                              execute 'noa buffer '.curr
                              return n

FUNCTION  airline#parts#mode()
    Defined: ~/.vimgo/plugged/vim-airline/autoload/airline/parts.vim:55
Called 101 times
Total time:   0.002837
 Self time:   0.000555

count  total (s)   self (s)
  101   0.002777   0.000495   return airline#util#shorten(get(w:, 'airline_current_mode', ''), 79, 1)

FUNCTION  coc#cursor#position()
    Defined: ~/.vimgo/plugged/coc.nvim/autoload/coc/cursor.vim:16
Called 3 times
Total time:   0.000028
 Self time:   0.000022

count  total (s)   self (s)
    3              0.000004   let line = getline('.')
    3   0.000021   0.000015   return [line('.') - 1, coc#string#character_index(line, col('.') - 1)]

FUNCTION  airline#highlighter#exec()
    Defined: ~/.vimgo/plugged/vim-airline/autoload/airline/highlighter.vim:219
Called 221 times
Total time:   0.031342
 Self time:   0.009266

count  total (s)   self (s)
  221              0.000195     if pumvisible()
                                  return
  221              0.000075     endif
  221              0.000162     let colors = a:colors
  221              0.000204     if len(colors) == 4
  111              0.000130       call add(colors, '')
  221              0.000081     endif
                                " colors should always be string values
  221              0.001988     let colors = map(copy(colors), 'type(v:val) != type("") ? string(v:val) : v:val')
  221              0.000143     if s:is_win32term
                                  let colors[2] = s:gui2cui(get(colors, 0, ''), get(colors, 2, ''))
                                  let colors[3] = s:gui2cui(get(colors, 1, ''), get(colors, 3, ''))
  221              0.000060     endif
  221   0.016450   0.000539     let old_hi = airline#highlighter#get_highlight(a:group)
  221              0.000816     let new_hi = [colors[0], colors[1], printf('%s', colors[2]), printf('%s', colors[3]), colors[4]]
  221   0.002952   0.000464     let colors = s:CheckDefined(colors)
  221   0.001655   0.000464     if old_hi != new_hi || !s:hl_group_exists(a:group)
   39   0.002609   0.000123       let cmd = printf('hi %s%s', a:group, s:GetHiCmd(colors))
   39              0.000019       try
   39              0.000237         exe cmd
                                  catch /^Vim\%((\a\+)\)\=:E421:/ " color definition not found
                                    let group=matchstr(v:exception, '\w\+\ze=')
                                    let color=matchstr(v:exception, '=\zs\w\+')
                                    let cmd=substitute(cmd, color, 'grey', 'g')
                                    exe cmd
                                    call airline#util#warning('color definition for group ' . a:group . ' not found, using grey as fallback')
                                  catch
                                    call airline#util#warning('Error when running command: '. cmd)
   39              0.000020       endtry
   39              0.000061       if has_key(s:hl_groups, a:group)
   39              0.000049         let s:hl_groups[a:group] = colors
   39              0.000007       endif
  221              0.000059     endif

FUNCTION  coc#highlight#update_highlights()
    Defined: ~/.vimgo/plugged/coc.nvim/autoload/coc/highlight.vim:47
Called 1 time
Total time:   0.001420
 Self time:   0.000557

count  total (s)   self (s)
    1              0.000005   let bufnr = a:bufnr == 0 ? bufnr('%') : a:bufnr
    1              0.000003   if !bufloaded(bufnr)
                                return
    1              0.000000   endif
    1              0.000003   let start = get(a:, 1, 0)
    1              0.000003   let end = get(a:, 2, -1)
    1              0.000002   if end == 0
                                return
    1              0.000000   endif
    1   0.000030   0.000014   let linecount = coc#compat#buf_line_count(a:bufnr)
    1              0.000002   if end >= linecount
                                let end = -1
    1              0.000001   endif
    1              0.000002   if empty(a:highlights)
                                call coc#highlight#clear_highlight(bufnr, a:key, start, end)
                                return
    1              0.000001   endif
    1              0.000216   let priority = get(a:, 3, v:null)
    1              0.000005   let total = len(a:highlights)
                              " index list that exists with current highlights
    1              0.000002   let exists = []
    1   0.000020   0.000007   let ns = coc#highlight#create_namespace(a:key)
    1              0.000010   if has('nvim-0.5.0') || exists('*prop_list')
    1              0.000004     let endLnum = end < 0 ? linecount - 1 : end - 1
    1              0.000004     let firstLnum = a:highlights[0]['lnum']
    1              0.000002     if firstLnum > start
    1   0.000147   0.000006       call coc#highlight#clear_highlight(bufnr, a:key, start, firstLnum)
    1              0.000002       let start = firstLnum
    1              0.000001     endif
    1              0.000004     let lastLnum = a:highlights[total - 1]['lnum']
    1              0.000002     if lastLnum < endLnum
                                  call coc#highlight#clear_highlight(bufnr, a:key, lastLnum + 1, endLnum + 1)
                                  let endLnum = lastLnum
    1              0.000001     endif
    1   0.000120   0.000013     let current = coc#highlight#get_highlights(bufnr, a:key, start, endLnum)
    1              0.000002     let currIndex = 0
    1              0.000002     if !empty(current)
                                  for [lnum, items] in s:to_group(current)
                                    let indexes = []
                                    let currIndexes = range(0, len(items) - 1)
                                    let removeIndexes = []
                                    while currIndex != total
                                      let hi = a:highlights[currIndex]
                                      if hi['lnum'] == lnum
                                        let findIndex = -1
                                        for idx in currIndexes
                                          let item = items[idx]
                                          if hi['hlGroup'] ==# item[0] && hi['colStart'] == item[2] && hi['colEnd'] == item[3]
                                            call add(indexes, currIndex)
                                            let findIndex = idx
                                            break
                                          elseif item[2] > hi['colStart']
                                            break
                                          endif
                                        endfor
                                        if findIndex != -1
                                          call filter(currIndexes, 'v:val != '.findIndex)
                                        endif
                                      elseif hi['lnum'] > lnum
                                        break
                                      endif
                                      let currIndex = currIndex + 1
                                    endwhile
                                    for idx in currIndexes
                                      if s:is_vim
                                        call prop_remove({'bufnr': bufnr, 'id': items[idx][4]})
                                      else
                                        call nvim_buf_del_extmark(bufnr, ns, items[idx][4])
                                      endif
                                    endfor
                                    call extend(exists, indexes)
                                  endfor
    1              0.000000     endif
                              else
                                call coc#highlight#clear_highlight(bufnr, a:key, start, end)
    1              0.000001   endif
    1              0.000004   let indexes = range(0, total - 1)
    1              0.000002   if !empty(exists)
                                let indexes = filter(indexes, 'index(exists, v:val) == -1')
    1              0.000000   endif
    5              0.000005   for idx in indexes
    4              0.000010     let hi = a:highlights[idx]
    4              0.000028     let opts = { 'combine': get(hi, 'combine', 0), 'start_incl': get(hi, 'start_incl', 0), 'end_incl': get(hi, 'end_incl', 0), }
    4              0.000028     if type(priority) == 0
    4   0.000092   0.000030       let opts['priority'] = s:get_priority(a:key, hi['hlGroup'], priority)
    4              0.000003     endif
    4   0.000555   0.000031     call coc#highlight#add_highlight(bufnr, ns, hi['hlGroup'], hi['lnum'], hi['colStart'], hi['colEnd'], opts)
    5              0.000004   endfor

FUNCTION  airline#extensions#quickfix#apply()
    Defined: ~/.vimgo/plugged/vim-airline/autoload/airline/extensions/quickfix.vim:14
Called 4 times
Total time:   0.000059
 Self time:   0.000059

count  total (s)   self (s)
    4              0.000018   if &buftype == 'quickfix'
                                let w:airline_section_a = airline#extensions#quickfix#get_type()
                                let w:airline_section_b = '%{get(w:, "quickfix_title", "")}'
                                let w:airline_section_c = ''
                                let w:airline_section_x = ''
    4              0.000004   endif

FUNCTION  ale#engine#SetResults()
    Defined: ~/.vimgo/plugged/ale/autoload/ale/engine.vim:184
Called 1 time
Total time:   0.005066
 Self time:   0.000047

count  total (s)   self (s)
    1   0.000012   0.000003     let l:linting_is_done = !ale#engine#IsCheckingBuffer(a:buffer)
                            
                                " Set signs first. This could potentially fix some line numbers.
                                " The List could be sorted again here by SetSigns.
    1              0.000002     if g:ale_set_signs
    1   0.000155   0.000003         call ale#sign#SetSigns(a:buffer, a:loclist)
    1              0.000000     endif
                            
    1              0.000001     if g:ale_set_quickfix || g:ale_set_loclist
    1   0.000023   0.000003         call ale#list#SetLists(a:buffer, a:loclist)
    1              0.000000     endif
                            
    1              0.000002     if exists('*ale#statusline#Update')
                                    " Don't load/run if not already loaded.
    1   0.000043   0.000002         call ale#statusline#Update(a:buffer, a:loclist)
    1              0.000001     endif
                            
    1              0.000001     if g:ale_set_highlights
                                    call ale#highlight#SetHighlights(a:buffer, a:loclist)
    1              0.000000     endif
                            
    1              0.000000     if g:ale_virtualtext_cursor == 2
                                    call ale#virtualtext#SetTexts(a:buffer, a:loclist)
    1              0.000001     endif
                            
    1              0.000000     if l:linting_is_done
    1              0.000001         if g:ale_echo_cursor
                                        " Try and echo the warning now.
                                        " This will only do something meaningful if we're in normal mode.
    1   0.000110   0.000002             call ale#cursor#EchoCursorWarning()
    1              0.000001         endif
                            
    1              0.000001         if g:ale_virtualtext_cursor == 1
                                        " Try and show the warning now.
                                        " This will only do something meaningful if we're in normal mode.
                                        call ale#virtualtext#ShowCursorWarning()
    1              0.000000         endif
                            
                                    " Reset the save event marker, used for opening windows, etc.
    1              0.000002         call setbufvar(a:buffer, 'ale_save_event_fired', 0)
                                    " Set a marker showing how many times a buffer has been checked.
    1              0.000003         call setbufvar(   a:buffer,   'ale_linted',   getbufvar(a:buffer, 'ale_linted', 0) + 1)
                            
                                    " Automatically remove all managed temporary files and directories
                                    " now that all jobs have completed.
    1   0.000017   0.000004         call ale#command#RemoveManagedFiles(a:buffer)
                            
                                    " Call user autocommands. This allows users to hook into ALE's lint cycle.
    1   0.004681   0.000005         silent doautocmd <nomodeline> User ALELintPost
    1              0.000001     endif

FUNCTION  airline#util#strchars()
    Defined: ~/.vimgo/plugged/vim-airline/autoload/airline/util.vim:121
Called 5 times
Total time:   0.000013
 Self time:   0.000013

count  total (s)   self (s)
    5              0.000003   if s:has_strchars
    5              0.000007     return strchars(a:str)
                              else
                                return strlen(substitute(a:str, '.', 'a', 'g'))
                              endif

FUNCTION  coc#util#get_changeinfo()
    Defined: ~/.vimgo/plugged/coc.nvim/autoload/coc/util.vim:591
Called 2 times
Total time:   0.000011
 Self time:   0.000011

count  total (s)   self (s)
    2              0.000010   return { 'bufnr': bufnr('%'), 'lnum': line('.'), 'line': getline('.'), 'changedtick': b:changedtick,}

FUNCTION  <SNR>198_UpdateCacheIfNecessary()
    Defined: ~/.vimgo/plugged/ale/autoload/ale/statusline.vim:78
Called 8 times
Total time:   0.000032
 Self time:   0.000032

count  total (s)   self (s)
                                " Cache is cold, so manually ask for an update.
    8              0.000012     if !has_key(g:ale_buffer_info[a:buffer], 'count')
                                    call ale#statusline#Update(   a:buffer,   g:ale_buffer_info[a:buffer].loclist)
    8              0.000002     endif

FUNCTION  airline#extensions#wordcount#apply()
    Defined: ~/.vimgo/plugged/vim-airline/autoload/airline/extensions/wordcount.vim:93
Called 4 times
Total time:   0.000220
 Self time:   0.000220

count  total (s)   self (s)
    4              0.000041   let filetypes = get(g:, 'airline#extensions#wordcount#filetypes', ['asciidoc', 'help', 'mail', 'markdown', 'rmd', 'nroff', 'org', 'rst', 'plaintex', 'tex', 'text'])
                              " export current filetypes settings to global namespace
    4              0.000013   let g:airline#extensions#wordcount#filetypes = filetypes
                            
                              " Check if filetype needs testing
    4              0.000010   if did_filetype()
                                " correctly test for compound filetypes (e.g. markdown.pandoc)
                                let ft = substitute(&filetype, '\.', '\\|', 'g')
                            
                                " Select test based on type of "filetypes": new=list, old=string
                                if type(filetypes) == get(v:, 't_list', type([])) ? match(filetypes, '\<'. ft. '\>') > -1 || index(filetypes, 'all') > -1 : match(&filetype, filetypes) > -1
                                  let b:airline_changedtick = -1
                                  call s:update_wordcount(1) " force update: ensures initial worcount exists
                                elseif exists('b:airline_wordcount') " cleanup when filetype is removed
                                  unlet b:airline_wordcount
                                endif
    4              0.000003   endif
                            
    4              0.000016   if exists('b:airline_wordcount')
                                call airline#extensions#prepend_to_section( 'z', '%{airline#extensions#wordcount#get()}')
    4              0.000001   endif

FUNCTION  <SNR>227_get_separator_change()
    Defined: ~/.vimgo/plugged/vim-airline/autoload/airline/extensions/tabline/builder.vim:68
Called 2 times
Total time:   0.000342
 Self time:   0.000009

count  total (s)   self (s)
    2   0.000341   0.000008   return s:get_separator_change_with_end(a:new_group, a:old_group, a:end_group, a:end_group, a:sep_size, a:alt_sep_size)

FUNCTION  coc#util#suggest_variables()
    Defined: ~/.vimgo/plugged/coc.nvim/autoload/coc/util.vim:38
Called 16 times
Total time:   0.000122
 Self time:   0.000122

count  total (s)   self (s)
   16              0.000111   return { 'disable': getbufvar(a:bufnr, 'coc_suggest_disable', 0), 'disabled_sources': getbufvar(a:bufnr, 'coc_disabled_sources', []), 'blacklist': getbufvar(a:bufnr, 'coc_suggest_blacklist', []), }

FUNCTION  <SNR>230_generate_id()
    Defined: ~/.vimgo/plugged/coc.nvim/autoload/coc/api.vim:650
Called 1115 times
Total time:   0.003933
 Self time:   0.003933

count  total (s)   self (s)
 1115              0.001474   let max = get(s:buffer_id, a:bufnr, s:prop_offset)
 1115              0.000661   let id = max + 1
 1115              0.001057   let s:buffer_id[a:bufnr] = id
 1115              0.000451   return id

FUNCTION  <SNR>197_RunLinters()
    Defined: ~/.vimgo/plugged/ale/autoload/ale/engine.vim:648
Called 1 time
Total time:   0.380532
 Self time:   0.000205

count  total (s)   self (s)
    1   0.000360   0.000015     call s:StopCurrentJobs(a:buffer, a:should_lint_file, a:slots)
    1   0.000107   0.000016     call s:RemoveProblemsForDisabledLinters(a:buffer, a:linters)
                            
                                " We can only clear the results if we aren't checking the buffer.
    1   0.000034   0.000012     let l:can_clear_results = !ale#engine#IsCheckingBuffer(a:buffer)
                            
    1   0.000020   0.000016     silent doautocmd <nomodeline> User ALELintPre
                            
    9              0.000023     for [l:lint_file, l:linter] in a:slots
                                    " Only run lint_file linters if we should.
    8              0.000013         if !l:lint_file || a:should_lint_file
    8   0.374847   0.000048             if s:RunLinter(a:buffer, l:linter, l:lint_file)
                                            " If a single linter ran, we shouldn't clear everything.
                                            let l:can_clear_results = 0
    8              0.000003             endif
                                    else
                                        " If we skipped running a lint_file linter still in the list,
                                        " we shouldn't clear everything.
                                        let l:can_clear_results = 0
    8              0.000005         endif
    9              0.000005     endfor
                            
                                " Clear the results if we can. This needs to be done when linters are
                                " disabled, or ALE itself is disabled.
    1              0.000001     if l:can_clear_results
    1   0.005071   0.000005         call ale#engine#SetResults(a:buffer, [])
                                elseif a:new_buffer
                                    call s:AddProblemsFromOtherBuffers(   a:buffer,   map(copy(a:slots), 'v:val[1]'))
    1              0.000001     endif

FUNCTION  <SNR>88_Highlight_Matching_Pair()
    Defined: /usr/share/vim/vim90/plugin/matchparen.vim:39
Called 76 times
Total time:  13.906823
 Self time:  13.906170

count  total (s)   self (s)
                              " Remove any previous match.
   76   0.000864   0.000211   call s:Remove_Matches()
                            
                              " Avoid that we remove the popup menu.
                              " Return when there are no colors (looks like the cursor jumps).
   76              0.000313   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
                                return
   76              0.000031   endif
                            
                              " Get the character under the cursor and check if it's in 'matchpairs'.
   76              0.000137   let c_lnum = line('.')
   76              0.000117   let c_col = col('.')
   76              0.000063   let before = 0
                            
   76              0.000157   let text = getline(c_lnum)
   76              0.000810   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
   76              0.000112   if empty(matches)
                                let [c_before, c] = ['', '']
   76              0.000036   else
   76              0.000260     let [c_before, c] = matches[1:2]
   76              0.000046   endif
   76              0.000469   let plist = split(&matchpairs, '.\zs[:,]')
   76              0.000188   let i = index(plist, c)
   76              0.000078   if i < 0
                                " not found, in Insert mode try character before the cursor
   30              0.000085     if c_col > 1 && (mode() == 'i' || mode() == 'R')
   27              0.000059       let before = strlen(c_before)
   27              0.000024       let c = c_before
   27              0.000038       let i = index(plist, c)
   30              0.000012     endif
   30              0.000018     if i < 0
                                  " not found, nothing to do
   30              0.000019       return
                                endif
   46              0.000016   endif
                            
                              " Figure out the arguments for searchpairpos().
   46              0.000040   if i % 2 == 0
                                let s_flags = 'nW'
                                let c2 = plist[i + 1]
   46              0.000017   else
   46              0.000047     let s_flags = 'nbW'
   46              0.000050     let c2 = c
   46              0.000089     let c = plist[i - 1]
   46              0.000017   endif
   46              0.000055   if c == '['
                                let c = '\['
                                let c2 = '\]'
   46              0.000016   endif
                            
                              " Find the match.  When it was just before the cursor move it there for a
                              " moment.
   46              0.000036   if before > 0
                                let has_getcurpos = exists("*getcurpos")
                                if has_getcurpos
                                  " getcurpos() is more efficient but doesn't exist before 7.4.313.
                                  let save_cursor = getcurpos()
                                else
                                  let save_cursor = winsaveview()
                                endif
                                call cursor(c_lnum, c_col - before)
   46              0.000019   endif
                            
   46              0.000279   if !has("syntax") || !exists("g:syntax_on")
                                let s_skip = "0"
   46              0.000017   else
                                " Build an expression that detects whether the current cursor position is
                                " in certain syntax types (string, comment, etc.), for use as
                                " searchpairpos()'s skip argument.
                                " We match "escape" for special items, such as lispEscapeSpecial, and
                                " match "symbol" for lispBarSymbol.
   46              0.000127     let s_skip = '!empty(filter(map(synstack(line("."), col(".")), ''synIDattr(v:val, "name")''), ' . '''v:val =~? "string\\|character\\|singlequote\\|escape\\|symbol\\|comment"''))'
                                " If executing the expression determines that the cursor is currently in
                                " one of the syntax types, then we want searchpairpos() to find the pair
                                " within those syntax types (i.e., not skip).  Otherwise, the cursor is
                                " outside of the syntax types and s_skip should keep its value so we skip
                                " any matching pair inside the syntax types.
                                " Catch if this throws E363: pattern uses more memory than 'maxmempattern'.
   46              0.000037     try
   46             13.227414       execute 'if ' . s_skip . ' | let s_skip = "0" | endif'
                                catch /^Vim\%((\a\+)\)\=:E363/
                                  " We won't find anything, so skip searching, should keep Vim responsive.
                                  return
   46              0.000030     endtry
   46              0.000018   endif
                            
                              " Limit the search to lines visible in the window.
   46              0.000120   let stoplinebottom = line('w$')
   46              0.000082   let stoplinetop = line('w0')
   46              0.000056   if i % 2 == 0
                                let stopline = stoplinebottom
   46              0.000014   else
   46              0.000070     let stopline = stoplinetop
   46              0.000022   endif
                            
                              " Limit the search time to 300 msec to avoid a hang on very long lines.
                              " This fails when a timeout is not supported.
   46              0.000118   if mode() == 'i' || mode() == 'R'
   46              0.000188     let timeout = exists("b:matchparen_insert_timeout") ? b:matchparen_insert_timeout : g:matchparen_insert_timeout
                              else
                                let timeout = exists("b:matchparen_timeout") ? b:matchparen_timeout : g:matchparen_timeout
   46              0.000020   endif
   46              0.000027   try
   46              0.668425     let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline, timeout)
                              catch /E118/
                                " Can't use the timeout, restrict the stopline a bit more to avoid taking
                                " a long time on closed folds and long lines.
                                " The "viewable" variables give a range in which we can scroll while
                                " keeping the cursor at the same position.
                                " adjustedScrolloff accounts for very large numbers of scrolloff.
                                let adjustedScrolloff = min([&scrolloff, (line('w$') - line('w0')) / 2])
                                let bottom_viewable = min([line('$'), c_lnum + &lines - adjustedScrolloff - 2])
                                let top_viewable = max([1, c_lnum-&lines+adjustedScrolloff + 2])
                                " one of these stoplines will be adjusted below, but the current values are
                                " minimal boundaries within the current window
                                if i % 2 == 0
                                  if has("byte_offset") && has("syntax_items") && &smc > 0
                            	let stopbyte = min([line2byte("$"), line2byte(".") + col(".") + &smc * 2])
                            	let stopline = min([bottom_viewable, byte2line(stopbyte)])
                                  else
                            	let stopline = min([bottom_viewable, c_lnum + 100])
                                  endif
                                  let stoplinebottom = stopline
                                else
                                  if has("byte_offset") && has("syntax_items") && &smc > 0
                            	let stopbyte = max([1, line2byte(".") + col(".") - &smc * 2])
                            	let stopline = max([top_viewable, byte2line(stopbyte)])
                                  else
                            	let stopline = max([top_viewable, c_lnum - 100])
                                  endif
                                  let stoplinetop = stopline
                                endif
                                let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline)
   46              0.000028   endtry
                            
   46              0.000040   if before > 0
                                if has_getcurpos
                                  call setpos('.', save_cursor)
                                else
                                  call winrestview(save_cursor)
                                endif
   46              0.000013   endif
                            
                              " If a match is found setup match highlighting.
   46              0.000092   if m_lnum > 0 && m_lnum >= stoplinetop && m_lnum <= stoplinebottom 
   46              0.000097     if exists('*matchaddpos')
   46              0.000940       call matchaddpos('MatchParen', [[c_lnum, c_col - before], [m_lnum, m_col]], 10, 3)
                                else
                                  exe '3match MatchParen /\(\%' . c_lnum . 'l\%' . (c_col - before) . 'c\)\|\(\%' . m_lnum . 'l\%' . m_col . 'c\)/'
   46              0.000016     endif
   46              0.000062     let w:paren_hl_on = 1
   46              0.000015   endif

FUNCTION  <SNR>73_HandleCharInsert()
    Defined: ~/.vimgo/plugged/coc.nvim/plugin/coc.vim:287
Called 44 times
Total time:   0.006464
 Self time:   0.001083

count  total (s)   self (s)
   44              0.000320   if get(g:, 'coc_disable_space_report', 0)
                                let g:coc_disable_space_report = 0
                                if a:char ==# ' '
                                  return
                                endif
   44              0.000024   endif
   44   0.005665   0.000284   call s:Autocmd('InsertCharPre', a:char, a:bufnr)

FUNCTION  polyglot#init#is_disabled()
    Defined: ~/.vimgo/plugged/vim-polyglot/autoload/polyglot/init.vim:23
Called 3 times
Total time:   0.000042
 Self time:   0.000042

count  total (s)   self (s)
    3              0.000004   if !g:polyglot_initialized
                                if a:path[0:7] == "autoload"
                                  let g:polyglot_initialized = 1
                            
                                  for p in globpath(&rtp, a:path, 0, 1)
                                    if p != a:caller
                                      exe "source " . p
                                    endif
                                  endfor
                                endif
    3              0.000001   endif
                            
    3              0.000008   return has_key(g:polyglot_is_disabled, a:name)

FUNCTION  <lambda>3()
    Defined: ~/.vimgo/plugged/ale/ale_linters/typescript/tsserver.vim:8
Called 1 time
Total time:   0.000167
 Self time:   0.000002

count  total (s)   self (s)
                            return ale#path#FindExecutable(b, 'typescript_tsserver', [       '.yarn/sdks/typescript/bin/tsserver',       'node_modules/.bin/tsserver',   ])

FUNCTION  <SNR>233_popup_cursor()
    Defined: ~/.vimgo/plugged/coc.nvim/autoload/coc/float.vim:1211
Called 34 times
Total time:   0.000108
 Self time:   0.000108

count  total (s)   self (s)
   34              0.000027   if a:n == 0
                                return 'cursor'
   34              0.000004   endif
   34              0.000017   if a:n < 0
   34              0.000031     return 'cursor'.a:n
                              endif
                              return 'cursor+'.a:n

FUNCTION  airline#extensions#tabline#get_buffer_name()
    Defined: ~/.vimgo/plugged/vim-airline/autoload/airline/extensions/tabline.vim:228
Called 80 times
Total time:   0.004073
 Self time:   0.000606

count  total (s)   self (s)
   80   0.000245   0.000153     let buffers = a:0 ? a:1 : airline#extensions#tabline#buflist#list()
   80              0.000142     let formatter = get(g:, 'airline#extensions#tabline#formatter', 'default')
   80   0.003656   0.000281     return airline#extensions#tabline#formatters#{formatter}#format(a:nr, buffers)

FUNCTION  ale_linters#typescript#standard#GetExecutable()
    Defined: ~/.vimgo/plugged/ale/ale_linters/typescript/standard.vim:8
Called 1 time
Total time:   0.000250
 Self time:   0.000004

count  total (s)   self (s)
    1   0.000249   0.000003     return ale#path#FindExecutable(a:buffer, 'typescript_standard', [   'node_modules/standardx/bin/cmd.js',   'node_modules/standard/bin/cmd.js',   'node_modules/.bin/standard',])

FUNCTION  coc#window#get_cursor()
    Defined: ~/.vimgo/plugged/coc.nvim/autoload/coc/window.vim:26
Called 1 time
Total time:   0.000034
 Self time:   0.000034

count  total (s)   self (s)
    1              0.000006   if exists('*nvim_win_get_cursor')
                                return nvim_win_get_cursor(a:winid)
    1              0.000001   endif
    1              0.000009   if has('patch-8.2.1727')
    1              0.000005     let pos = getcurpos(a:winid)
    1              0.000008     return [pos[1], pos[2] - 1]
                              endif
                              return coc#api#exec('win_get_cursor', [a:winid])

FUNCTION  coc#math#min()
    Defined: ~/.vimgo/plugged/coc.nvim/autoload/coc/math.vim:3
Called 9 times
Total time:   0.000090
 Self time:   0.000090

count  total (s)   self (s)
    9              0.000007   let val = a:first
   18              0.000027   for i in range(0, len(a:000) - 1)
    9              0.000016     if a:000[i] < val
    5              0.000004       let val = a:000[i]
    9              0.000004     endif
   18              0.000007   endfor
    9              0.000003   return val

FUNCTION  airline#extensions#apply()
    Defined: ~/.vimgo/plugged/vim-airline/autoload/airline/extensions.vim:72
Called 4 times
Total time:   0.000541
 Self time:   0.000297

count  total (s)   self (s)
    4              0.000021   let filetype_overrides = get(s:, 'filetype_overrides', {})
    4              0.000024   call extend(filetype_overrides, get(g:, 'airline_filetype_overrides', {}), 'force')
                            
    4   0.000265   0.000021   if s:is_excluded_window()
                                return -1
    4              0.000003   endif
                            
    4              0.000006   if &buftype == 'terminal'
                                let w:airline_section_x = ''
                                let w:airline_section_y = ''
    4              0.000002   endif
                            
    4              0.000014   if &previewwindow && empty(get(w:, 'airline_section_a', ''))
                                let w:airline_section_a = 'Preview'
                                let w:airline_section_b = ''
                                let w:airline_section_c = bufname(winbufnr(winnr()))
    4              0.000004   endif
                            
    4              0.000038   if has_key(filetype_overrides, &ft) && ((&filetype == 'help' && &buftype == 'help') || &filetype !~ 'help')
                                " for help files only override it, if the buftype is also of type 'help',
                                " else it would trigger when editing Vim help files
                                let args = filetype_overrides[&ft]
                                call airline#extensions#apply_left_override(args[0], args[1])
    4              0.000003   endif
                            
    4              0.000007   if &buftype == 'help'
                                let w:airline_section_x = ''
                                let w:airline_section_y = ''
                                let w:airline_render_right = 1
    4              0.000002   endif
                            
    4              0.000018   for item in items(s:filetype_regex_overrides)
                                if match(&ft, item[0]) >= 0
                                  call airline#extensions#apply_left_override(item[1][0], item[1][1])
                                endif
    4              0.000004   endfor

FUNCTION  coc#highlight#clear_highlight()
    Defined: ~/.vimgo/plugged/coc.nvim/autoload/coc/highlight.vim:313
Called 22 times
Total time:   0.001099
 Self time:   0.000384

count  total (s)   self (s)
   22              0.000040   let bufnr = a:bufnr == 0 ? bufnr('%') : a:bufnr
   22              0.000030   if !bufloaded(bufnr)
                                return
   22              0.000005   endif
   22   0.000115   0.000063   let src_id = coc#highlight#create_namespace(a:key)
   22              0.000054   if has('nvim')
                                call nvim_buf_clear_namespace(a:bufnr, src_id, a:start_line, a:end_line)
   22              0.000004   else
   22   0.000746   0.000083     call coc#api#exec('buf_clear_namespace', [a:bufnr, src_id, a:start_line, a:end_line])
   22              0.000007   endif

FUNCTION  <SNR>80_matchend()
    Defined: ~/.vimgo/plugged/auto-pairs/plugin/auto-pairs.vim:162
Called 8 times
Total time:   0.000060
 Self time:   0.000060

count  total (s)   self (s)
    8              0.000037     let m = matchstr(a:text, '\V'.a:open.'\v$')
    8              0.000007     if m == ""
    7              0.000005       return []
    1              0.000000     end
    1              0.000005     return [a:text, strpart(a:text, 0, len(a:text)-len(m)), m]

FUNCTION  <SNR>179_display_git_branch()
    Defined: ~/.vimgo/plugged/vim-airline/autoload/airline/extensions/branch.vim:121
Called 4 times
Total time:   0.000248
 Self time:   0.000208

count  total (s)   self (s)
    4              0.000007   let name = b:buffer_vcs_config['git'].branch
    4              0.000003   try
    4   0.000118   0.000078     let commit = matchstr(FugitiveParse()[0], '^\x\+')
                            
    4              0.000009     if has_key(s:names, commit)
                                  let name = get(s:names, commit)."(".name.")"
    4              0.000006     elseif !empty(commit)
                                  if exists('*FugitiveExecute')
                                    let ref = FugitiveExecute(['describe', '--all', '--exact-match', commit], bufnr('')).stdout[0]
                                  else
                                    noautocmd let ref = fugitive#repo().git_chomp('describe', '--all', '--exact-match', commit)
                                    if ref =~# ':'
                                      let ref = ''
                                    endif
                                  endif
                                  if !empty(ref)
                                    let name = s:format_name(substitute(ref, '\v\C^%(heads/|remotes/|tags/)=','',''))."(".name.")"
                                  else
                                    let name = matchstr(commit, '.\{'.s:sha1size.'}')."(".name.")"
                                  endif
    4              0.000002     endif
                              catch
    4              0.000003   endtry
    4              0.000003   return name

FUNCTION  <SNR>73_AsyncRequest()
    Defined: ~/.vimgo/plugged/coc.nvim/plugin/coc.vim:143
Called 3 times
Total time:   0.000834
 Self time:   0.000197

count  total (s)   self (s)
    3              0.000069   let Cb = empty(a:args)? v:null : a:args[len(a:args) - 1]
    3              0.000024   if type(Cb) == 2
                                if !coc#rpc#ready()
                                  call Cb('service not started', v:null)
                                else
                                  call coc#rpc#request_async(a:name, a:args[0:-2], Cb)
                                endif
                                return ''
    3              0.000003   endif
    3   0.000664   0.000027   call coc#rpc#notify(a:name, a:args)
    3              0.000005   return ''

FUNCTION  <SNR>181_airline_ale_get_line_number()
    Defined: ~/.vimgo/plugged/vim-airline/autoload/airline/extensions/ale.vim:68
Called 8 times
Total time:   0.000051
 Self time:   0.000034

count  total (s)   self (s)
                              " Use the new ALE statusline API function if it is available.
    8              0.000011   if exists("*ale#statusline#FirstProblem")
    8   0.000035   0.000018     return s:new_airline_ale_get_line_number(a:cnt, a:type)
                              endif
                            
                              return s:legacy_airline_ale_get_line_number(a:cnt, a:type)

FUNCTION  ale#cursor#EchoCursorWarning()
    Defined: ~/.vimgo/plugged/ale/autoload/ale/cursor.vim:72
Called 4 times
Total time:   0.000499
 Self time:   0.000158

count  total (s)   self (s)
    4              0.000015     let l:buffer = bufnr('')
                            
    4              0.000006     if !g:ale_echo_cursor && !g:ale_cursor_detail
                                    return
    4              0.000003     endif
                            
                                " Only echo the warnings in normal mode, otherwise we will get problems.
    4              0.000006     if mode(1) isnot# 'n'
                                    return
    4              0.000001     endif
                            
    4   0.000276   0.000011     if ale#ShouldDoNothing(l:buffer)
                                    return
    4              0.000002     endif
                            
    4   0.000088   0.000012     let [l:info, l:loc] = ale#util#FindItemAtCursor(l:buffer)
                            
    4              0.000003     if g:ale_echo_cursor
    4              0.000004         if !empty(l:loc)
                                        let l:format = ale#Var(l:buffer, 'echo_msg_format')
                                        let l:msg = ale#GetLocItemMessage(l:loc, l:format)
                                        call ale#cursor#TruncatedEcho(l:msg)
                                        let l:info.echoed = 1
    4              0.000005         elseif get(l:info, 'echoed')
                                        " We'll only clear the echoed message when moving off errors once,
                                        " so we don't continually clear the echo line.
                                        "
                                        " no-custom-checks
                                        echo
                                        let l:info.echoed = 0
    4              0.000000         endif
    4              0.000002     endif
                            
    4              0.000001     if g:ale_cursor_detail
                                    if !empty(l:loc)
                                        call s:ShowCursorDetailForItem(l:loc, {'stay_here': 1})
                                    else
                                        call ale#preview#CloseIfTypeMatches('ale-preview')
                                    endif
    4              0.000001     endif

FUNCTION  <SNR>169_is_excluded_window()
    Defined: ~/.vimgo/plugged/vim-airline/autoload/airline/extensions.vim:112
Called 4 times
Total time:   0.000244
 Self time:   0.000244

count  total (s)   self (s)
    4              0.000011   for matchft in g:airline_exclude_filetypes
                                if matchft ==# &ft
                                  return 1
                                endif
    4              0.000005   endfor
                            
   16              0.000023   for matchw in g:airline_exclude_filenames
   12              0.000071     if matchstr(expand('%'), matchw) ==# matchw
                                  return 1
   12              0.000007     endif
   16              0.000015   endfor
                            
    4              0.000011   if g:airline_exclude_preview && &previewwindow
                                return 1
    4              0.000002   endif
                            
    4              0.000003   return 0

FUNCTION  airline#util#has_lawrencium()
    Defined: ~/.vimgo/plugged/vim-airline/autoload/airline/util.vim:160
Called 101 times
Total time:   0.000496
 Self time:   0.000496

count  total (s)   self (s)
  101              0.000195   if !exists("s:has_lawrencium")
                                let s:has_lawrencium  = exists('*lawrencium#statusline')
  101              0.000049   endif
  101              0.000090   return s:has_lawrencium

FUNCTION  airline#highlighter#get_highlight()
    Defined: ~/.vimgo/plugged/vim-airline/autoload/airline/highlighter.vim:68
Called 485 times
Total time:   0.034258
 Self time:   0.012757

count  total (s)   self (s)
                                " only check for the cterm reverse attribute
                                " TODO: do we need to check all modes (gui, term, as well)?
  485              0.001554     let reverse = synIDattr(synIDtrans(hlID(a:group)), 'reverse', 'cterm')
  485              0.000819     if get(g:, 'airline_highlighting_cache', 0) && has_key(s:hl_groups, a:group)
                                  let res = s:hl_groups[a:group]
                                  return reverse ? [ res[1], res[0], res[3], res[2], res[4] ] : res
  485              0.000163     else
  485   0.006580   0.000971       let ctermfg = s:get_syn(a:group, 'fg', 'cterm')
  485   0.005954   0.000956       let ctermbg = s:get_syn(a:group, 'bg', 'cterm')
  485   0.005698   0.000884       let guifg = s:get_syn(a:group, 'fg', 'gui')
  485   0.005532   0.000829       let guibg = s:get_syn(a:group, 'bg', 'gui')
  485              0.001239       let bold = synIDattr(synIDtrans(hlID(a:group)), 'bold')
  485              0.000255       if reverse
                                    let res = s:get_array(guibg, guifg, ctermbg, ctermfg, bold ? ['bold'] : a:000)
  485              0.000170       else
  485   0.002715   0.001338         let res = s:get_array(guifg, guibg, ctermfg, ctermbg, bold ? ['bold'] : a:000)
  485              0.000160       endif
  485              0.000134     endif
  485              0.000640     let s:hl_groups[a:group] = res
  485              0.000225     return res

FUNCTION  <SNR>216_StartIfExecutable()
    Defined: ~/.vimgo/plugged/ale/autoload/ale/lsp_linter.vim:409
Called 2 times
Total time:   0.092262
 Self time:   0.000019

count  total (s)   self (s)
    2   0.000010   0.000004     if ale#command#IsDeferred(a:executable)
                                    let a:executable.result_callback = {   executable -> s:StartIfExecutable(a:options, executable)}
                            
                                    return 1
    2              0.000000     endif
                            
    2   0.092243   0.000006     if !ale#engine#IsExecutable(a:options.buffer, a:executable)
    2              0.000002         return 0
                                endif
                            
                                let l:command = ale#linter#GetCommand(a:options.buffer, a:options.linter)
                            
                                return s:StartWithCommand(a:options, a:executable, l:command)

FUNCTION  <SNR>243_clear_virtual_text()
    Defined: ~/.vimgo/plugged/coc.nvim/autoload/coc/pum.vim:579
Called 4 times
Total time:   0.000036
 Self time:   0.000036

count  total (s)   self (s)
    4              0.000004   if s:virtual_text_support
    4              0.000003     if s:is_vim
    4              0.000005       if s:prop_id != 0
                                    call prop_remove({'id': s:prop_id})
    4              0.000002       endif
                                else
                                  call nvim_buf_clear_namespace(bufnr('%'), s:virtual_text_ns, 0, -1)
    4              0.000001     endif
    4              0.000001   endif

FUNCTION  <SNR>193_get_transitioned_seperator()
    Defined: ~/.vimgo/plugged/vim-airline/autoload/airline/builder.vim:140
Called 29 times
Total time:   0.010931
 Self time:   0.000514

count  total (s)   self (s)
   29              0.000025   let line = ''
   29              0.000080   if get(a:self._context, 'tabline', 0) && get(g:, 'airline#extensions#tabline#alt_sep', 0) && a:group ==# 'airline_tabsel' && a:side
                                call airline#highlighter#add_separator(a:prev_group, a:group, 0)
                                let line .= '%#'.a:prev_group.'_to_'.a:group.'#'
                                let line .=  a:self._context.right_sep.'%#'.a:group.'#'
   29              0.000013   else
   29   0.010500   0.000083     call airline#highlighter#add_separator(a:prev_group, a:group, a:side)
   29              0.000060     let line .= '%#'.a:prev_group.'_to_'.a:group.'#'
   29              0.000062     let line .= a:side ? a:self._context.left_sep : a:self._context.right_sep
   29              0.000033     let line .= '%#'.a:group.'#'
   29              0.000015   endif
   29              0.000017   return line

FUNCTION  ale#history#Add()
    Defined: ~/.vimgo/plugged/ale/autoload/ale/history.vim:12
Called 8 times
Total time:   0.000228
 Self time:   0.000228

count  total (s)   self (s)
    8              0.000010     if g:ale_max_buffer_history_size <= 0
                                    " Don't save anything if the history isn't a positive number.
                                    call setbufvar(a:buffer, 'ale_history', [])
                            
                                    return
    8              0.000005     endif
                            
    8              0.000063     let l:history = getbufvar(a:buffer, 'ale_history', [])
                            
                                " Remove the first item if we hit the max history size.
    8              0.000016     if len(l:history) >= g:ale_max_buffer_history_size
                                    let l:history = l:history[1:]
    8              0.000003     endif
                            
    8              0.000039     call add(l:history, {   'status': a:status,   'job_id': a:job_id,   'command': a:command,})
                            
    8              0.000025     call setbufvar(a:buffer, 'ale_history', l:history)

FUNCTION  <SNR>176_GetHiCmd()
    Defined: ~/.vimgo/plugged/vim-airline/autoload/airline/highlighter.vim:140
Called 39 times
Total time:   0.002486
 Self time:   0.002486

count  total (s)   self (s)
                                " a:list needs to have 5 items!
   39              0.000032     let res = ''
   39              0.000029     let i = -1
  234              0.000114     while i < 4
  195              0.000119       let i += 1
  195              0.000243       let item = get(a:list, i, '')
  195              0.000109       if item is ''
   13              0.000008         continue
  182              0.000054       endif
  182              0.000078       if i == 0
   39              0.000054         let res .= ' guifg='.item
  143              0.000064       elseif i == 1
   39              0.000038         let res .= ' guibg='.item
  104              0.000046       elseif i == 2
   39              0.000041         let res .= ' ctermfg='.item
   65              0.000031       elseif i == 3
   39              0.000036         let res .= ' ctermbg='.item
   26              0.000007       elseif i == 4
   26              0.000060         let res .= printf(' gui=%s cterm=%s term=%s', item, item, item)
  182              0.000050       endif
  221              0.000081     endwhile
   39              0.000027     return res

FUNCTION  AutoPairsInsert()
    Defined: ~/.vimgo/plugged/auto-pairs/plugin/auto-pairs.vim:198
Called 1 time
Total time:   0.000545
 Self time:   0.000425

count  total (s)   self (s)
    1              0.000003   if !b:autopairs_enabled
                                return a:key
    1              0.000001   end
                            
    1              0.000015   let b:autopairs_saved_pair = [a:key, getpos('.')]
                            
    1   0.000057   0.000008   let [before, after, afterline] = s:getline()
                            
                              " Ignore auto close if prev character is \
    1              0.000005   if before[-1:-1] == '\'
                                return a:key
    1              0.000000   end
                            
                              " check open pairs
    8              0.000019   for [open, close, opt] in b:AutoPairsList
    8   0.000088   0.000028     let ms = s:matchend(before.a:key, open)
    8              0.000028     let m = matchstr(afterline, '^\v\s*\zs\V'.close)
    8              0.000013     if len(ms) > 0
                                  " process the open pair
                                  
                                  " remove inserted pair
                                  " eg: if the pairs include < > and  <!-- --> 
                                  " when <!-- is detected the inserted pair < > should be clean up 
    1              0.000002       let target = ms[1]
    1              0.000002       let openPair = ms[2]
    1              0.000003       if len(openPair) == 1 && m == openPair
                                    break
    1              0.000001       end
    1              0.000001       let bs = ''
    1              0.000001       let del = ''
    1              0.000002       while len(before) > len(target)
                                    let found = 0
                                    " delete pair
                                    for [o, c, opt] in b:AutoPairsList
                                      let os = s:matchend(before, o)
                                      if len(os) && len(os[1]) < len(target)
                                        " any text before openPair should not be deleted
                                        continue
                                      end
                                      let cs = s:matchbegin(afterline, c)
                                      if len(os) && len(cs)
                                        let found = 1
                                        let before = os[1]
                                        let afterline = cs[2]
                                        let bs = bs.s:backspace(os[2])
                                        let del = del.s:delete(cs[1])
                                        break
                                      end
                                    endfor
                                    if !found
                                      " delete charactor
                                      let ms = s:matchend(before, '\v.')
                                      if len(ms)
                                        let before = ms[1]
                                        let bs = bs.s:backspace(ms[2])
                                      end
                                    end
    1              0.000000       endwhile
    1   0.000016   0.000005       return bs.del.openPair.close.s:left(close)
    7              0.000004     end
    7              0.000006   endfor
                            
                              " check close pairs
                              for [open, close, opt] in b:AutoPairsList
                                if close == ''
                                  continue
                                end
                                if a:key == g:AutoPairsWildClosedPair || opt['mapclose'] && opt['key'] == a:key
                                  " the close pair is in the same line
                                  let m = matchstr(afterline, '^\v\s*\V'.close)
                                  if m != ''
                                    if before =~ '\V'.open.'\v\s*$' && m[0] =~ '\v\s'
                                      " remove the space we inserted if the text in pairs is blank
                                      return "\<DEL>".s:right(m[1:])
                                    else
                                      return s:right(m)
                                    end
                                  end
                                  let m = matchstr(after, '^\v\s*\zs\V'.close)
                                  if m != ''
                                    if a:key == g:AutoPairsWildClosedPair || opt['multiline']
                                      if b:autopairs_return_pos == line('.') && getline('.') =~ '\v^\s*$'
                                        normal! ddk$
                                      end
                                      call search(m, 'We')
                                      return "\<Right>"
                                    else
                                      break
                                    end
                                  end
                                end
                              endfor
                            
                            
                              " Fly Mode, and the key is closed-pairs, search closed-pair and jump
                              if g:AutoPairsFlyMode &&  a:key =~ '\v[\}\]\)]'
                                if search(a:key, 'We')
                                  return "\<Right>"
                                endif
                              endif
                            
                              return a:key

FUNCTION  airline#util#shorten()
    Defined: ~/.vimgo/plugged/vim-airline/autoload/airline/util.vim:30
Called 303 times
Total time:   0.005511
 Self time:   0.003294

count  total (s)   self (s)
  303   0.003287   0.001070   if airline#util#winwidth() < a:winwidth && len(split(a:text, '\zs')) > a:minwidth
                                if get(a:000, 0, 0)
                                  " shorten from tail
                                  return ''.matchstr(a:text, '.\{'.a:minwidth.'}$')
                                else
                                  " shorten from beginning of string
                                  return matchstr(a:text, '^.\{'.a:minwidth.'}').''
                                endif
  303              0.000110   else
  303              0.000243     return a:text
                              endif

FUNCTION  273()
    Defined: ~/.vimgo/plugged/vim-airline/autoload/airline/builder.vim:17
Called 37 times
Total time:   0.000146
 Self time:   0.000146

count  total (s)   self (s)
   37              0.000144   call add(self._sections, [a:group, a:contents])

FUNCTION  275()
    Defined: ~/.vimgo/plugged/vim-airline/autoload/airline/builder.vim:25
Called 1 time
Total time:   0.000003
 Self time:   0.000003

count  total (s)   self (s)
    1              0.000002   call insert(self._sections, [a:group, a:contents], a:position)

FUNCTION  277()
    Defined: ~/.vimgo/plugged/vim-airline/autoload/airline/builder.vim:33
Called 1 time
Total time:   0.000004
 Self time:   0.000004

count  total (s)   self (s)
    1              0.000003   return len(self._sections)

FUNCTION  278()
    Defined: ~/.vimgo/plugged/vim-airline/autoload/airline/builder.vim:62
Called 6 times
Total time:   0.025523
 Self time:   0.002659

count  total (s)   self (s)
    6              0.000006   let side = 1
    6              0.000007   let line = ''
    6              0.000007   let i = 0
    6              0.000015   let length = len(self._sections)
    6              0.000008   let split = 0
    6              0.000006   let is_empty = 0
    6              0.000009   let prev_group = ''
                            
   55              0.000047   while i < length
   49              0.000086     let section = self._sections[i]
   49              0.000065     let group = section[0]
   49              0.000066     let contents = section[1]
   49              0.000049     let pgroup = prev_group
   49   0.000539   0.000176     let prev_group = airline#builder#get_prev_group(self._sections, i)
   49              0.000084     if group ==# 'airline_c' && &buftype ==# 'terminal' && self._context.active
                                  let group = 'airline_term'
   49              0.000103     elseif group ==# 'airline_c' && !self._context.active && has_key(self._context, 'bufnr')
                                  let group = 'airline_c'. self._context.bufnr
   49              0.000085     elseif prev_group ==# 'airline_c' && !self._context.active && has_key(self._context, 'bufnr')
                                  let prev_group = 'airline_c'. self._context.bufnr
   49              0.000021     endif
   49              0.000031     if is_empty
    8              0.000004       let prev_group = pgroup
   49              0.000017     endif
   49   0.006380   0.000173     let is_empty = s:section_is_empty(self, contents)
                            
   49              0.000031     if is_empty
                                  " need to fix highlighting groups, since we
                                  " have skipped a section, we actually need
                                  " the previous previous group and so the
                                  " seperator goes from the previous previous group
                                  " to the current group
   12              0.000004       let pgroup = group
   49              0.000015     endif
                            
   49              0.000037     if group == ''
                                  let line .= contents
   49              0.000034     elseif group == '|'
    6              0.000004       let side = 0
    6              0.000007       let line .= contents
    6              0.000005       let split = 1
   43              0.000020     else
   43              0.000033       if prev_group == ''
    6              0.000017         let line .= '%#'.group.'#'
   37              0.000020       elseif split
    6              0.000002         if !is_empty
    6   0.002210   0.000022           let line .= s:get_transitioned_seperator(self, prev_group, group, side)
    6              0.000003         endif
    6              0.000003         let split = 0
   31              0.000008       else
   31              0.000020         if !is_empty
   23   0.013097   0.000100           let line .= s:get_seperator(self, prev_group, group, side)
   31              0.000011         endif
   43              0.000017       endif
   43   0.001314   0.000205       let line .= is_empty ? '' : s:get_accented_line(self, group, contents)
   49              0.000018     endif
                            
   49              0.000045     let i = i + 1
   55              0.000029   endwhile
                            
    6              0.000006   if !self._context.active
                                "let line = substitute(line, '%#airline_c#', '%#airline_c'.self._context.bufnr.'#', '')
                                let line = substitute(line, '%#.\{-}\ze#', '\0_inactive', 'g')
    6              0.000002   endif
    6              0.000007   return line

FUNCTION  279()
    Defined: ~/.vimgo/plugged/vim-airline/autoload/airline/extensions/tabline/builder.vim:18
Called 1 time
Total time:   0.000024
 Self time:   0.000020

count  total (s)   self (s)
    1              0.000003   let self._first_title = a:first " lowest index
    1              0.000003   let self._last_title = a:last " highest index
    1              0.000003   let self._left_title = a:current " next index to add on the left
    1              0.000003   let self._right_title = a:current + 1 " next index to add on the right
    1   0.000009   0.000005   let self._left_position = self.get_position() " left end of titles
    1              0.000003   let self._right_position = self._left_position " right end of the titles

FUNCTION  ale#linter#GetExecutable()
    Defined: ~/.vimgo/plugged/ale/autoload/ale/linter.vim:430
Called 8 times
Total time:   0.001877
 Self time:   0.000084

count  total (s)   self (s)
    8              0.000027     let l:Executable = a:linter.executable
                            
    8   0.001846   0.000053     return type(l:Executable) is v:t_func   ? l:Executable(a:buffer)   : l:Executable

FUNCTION  airline#highlighter#highlight_modified_inactive()
    Defined: ~/.vimgo/plugged/vim-airline/autoload/airline/highlighter.vim:205
Called 6 times
Total time:   0.002493
 Self time:   0.000188

count  total (s)   self (s)
    6              0.000027     if getbufvar(a:bufnr, '&modified')
    3              0.000021       let colors = exists('g:airline#themes#{g:airline_theme}#palette.inactive_modified.airline_c') ? g:airline#themes#{g:airline_theme}#palette.inactive_modified.airline_c : []
    3              0.000002     else
    3              0.000033       let colors = exists('g:airline#themes#{g:airline_theme}#palette.inactive.airline_c') ? g:airline#themes#{g:airline_theme}#palette.inactive.airline_c : []
    6              0.000003     endif
                            
    6              0.000010     if !empty(colors)
    6   0.002355   0.000050       call airline#highlighter#exec('airline_c'.(a:bufnr).'_inactive', colors)
    6              0.000002     endif

FUNCTION  airline#extensions#branch#get_head()
    Defined: ~/.vimgo/plugged/vim-airline/autoload/airline/extensions/branch.vim:318
Called 101 times
Total time:   0.036653
 Self time:   0.002045

count  total (s)   self (s)
  101   0.032890   0.000254   let head = airline#extensions#branch#head()
  101   0.000587   0.000369   let winwidth = get(airline#parts#get('branch'), 'minwidth', 120)
  101              0.000253   let minwidth = empty(get(b:, 'airline_hunks', '')) ? 14 : 7
  101   0.002043   0.000289   let head = airline#util#shorten(head, winwidth, minwidth)
  101              0.000254   let symbol = get(g:, 'airline#extensions#branch#symbol', g:airline_symbols.branch)
  101              0.000514   return empty(head) ? get(g:, 'airline#extensions#branch#empty_message', '') : printf('%s%s', empty(symbol) ? '' : symbol.(g:airline_symbols.space), head)

FUNCTION  airline#extensions#tabline#new_builder()
    Defined: ~/.vimgo/plugged/vim-airline/autoload/airline/extensions/tabline.vim:234
Called 1 time
Total time:   0.000104
 Self time:   0.000052

count  total (s)   self (s)
    1              0.000018     let builder_context = { 'active'        : 1, 'tabline'       : 1, 'right_sep'     : get(g:, 'airline#extensions#tabline#right_sep'    , g:airline_right_sep), 'right_alt_sep' : get(g:, 'airline#extensions#tabline#right_alt_sep', g:airline_right_alt_sep), }
    1              0.000003     if get(g:, 'airline_powerline_fonts', 0)
                                  let builder_context.left_sep     = get(g:, 'airline#extensions#tabline#left_sep'     , g:airline_left_sep)
                                  let builder_context.left_alt_sep = get(g:, 'airline#extensions#tabline#left_alt_sep' , g:airline_left_alt_sep)
    1              0.000001     else
    1              0.000006       let builder_context.left_sep     = get(g:, 'airline#extensions#tabline#left_sep'     , ' ')
    1              0.000005       let builder_context.left_alt_sep = get(g:, 'airline#extensions#tabline#left_alt_sep' , '|')
    1              0.000000     endif
                            
    1   0.000059   0.000007     return airline#extensions#tabline#builder#new(builder_context)

FUNCTION  281()
    Defined: ~/.vimgo/plugged/vim-airline/autoload/airline/extensions/tabline/builder.vim:96
Called 1 time
Total time:   0.007571
 Self time:   0.000119

count  total (s)   self (s)
    1              0.000005   if has_key(self, '_left_position') && self._first_title <= self._last_title
    1   0.004107   0.000010     let self._remaining_space = &columns - s:tabline_evaluated_length(self._build())
                            
    1              0.000002     let center_active = get(g:, 'airline#extensions#tabline#center_active', 0)
                            
    1   0.000030   0.000004     let sep_size = s:tabline_evaluated_length(self._context.left_sep)
    1   0.000025   0.000003     let alt_sep_size = s:tabline_evaluated_length(self._context.left_alt_sep)
                            
    1   0.000009   0.000003     let outer_left_group = airline#builder#get_prev_group(self._sections, self._left_position)
    1   0.000014   0.000002     let outer_right_group = airline#builder#get_next_group(self._sections, self._right_position)
                            
    1              0.000003     let overflow_marker = get(g:, 'airline#extensions#tabline#overflow_marker', g:airline_symbols.ellipsis)
    1   0.000023   0.000003     let overflow_marker_size = s:tabline_evaluated_length(overflow_marker)
                                " Allow space for the markers before we begin filling in titles.
    1              0.000001     if self._left_title > self._first_title
                                  let self._remaining_space -= overflow_marker_size + s:get_separator_change(self.overflow_group, "", outer_left_group, sep_size, alt_sep_size)
    1              0.000001     endif
    1              0.000000     if self._left_title < self._last_title
                                  let self._remaining_space -= overflow_marker_size + s:get_separator_change(self.overflow_group, "", outer_right_group, sep_size, alt_sep_size)
    1              0.000001     endif
                            
                                " Add the current title
    1   0.000023   0.000003     let group = self.get_group(self._left_title)
    1              0.000001     if self._left_title == self._first_title
    1   0.000188   0.000004       let sep_change = s:get_separator_change(group, "", outer_left_group, sep_size, alt_sep_size)
                                else
                                  let sep_change = s:get_separator_change(group, "", self.overflow_group, sep_size, alt_sep_size)
    1              0.000000     endif
    1              0.000001     if self._left_title == self._last_title
    1   0.000162   0.000004       let sep_change += s:get_separator_change(group, "", outer_right_group, sep_size, alt_sep_size)
                                else
                                  let sep_change += s:get_separator_change(group, "", self.overflow_group, sep_size, alt_sep_size)
    1              0.000000     endif
    1              0.000000     let left_group = group
    1              0.000001     let right_group = group
    1   0.000157   0.000004     let self._left_title -= self.try_insert_title(self._left_title, group, self._left_position, sep_change, 1)
                            
    1              0.000001     if get(g:, 'airline#extensions#tabline#current_first', 0)
                                  " always have current title first
                                  let self._left_position += 1
    1              0.000000     endif
                            
    1              0.000002     if !center_active && self._right_title <= self._last_title
                                  " Add the title to the right
                                  let group = self.get_group(self._right_title)
                                  if self._right_title == self._last_title
                                    let sep_change = s:get_separator_change_with_end(group, right_group, outer_right_group, self.overflow_group, sep_size, alt_sep_size) - overflow_marker_size
                                  else
                                    let sep_change = s:get_separator_change(group, right_group, self.overflow_group, sep_size, alt_sep_size)
                                  endif
                                  let right_group = group
                                  let self._right_title += self.try_insert_title(self._right_title, group, self._right_position, sep_change, 1)
    1              0.000000     endif
                            
    1              0.000001     while self._remaining_space > 0
    1              0.000001       let done = 0
    1              0.000001       if self._left_title >= self._first_title
                                    " Insert next title to the left
                                    let group = self.get_group(self._left_title)
                                    if self._left_title == self._first_title
                                      let sep_change = s:get_separator_change_with_end(group, left_group, outer_left_group, self.overflow_group, sep_size, alt_sep_size) - overflow_marker_size
                                    else
                                      let sep_change = s:get_separator_change(group, left_group, self.overflow_group, sep_size, alt_sep_size)
                                    endif
                                    let left_group = group
                                    let done = self.try_insert_title(self._left_title, group, self._left_position, sep_change, 0)
                                    let self._left_title -= done
    1              0.000000       endif
                                  " If center_active is set, this |if| operates as an independent |if|,
                                  " otherwise as an |elif|.
    1              0.000001       if self._right_title <= self._last_title && (center_active || !done)
                                    " Insert next title to the right
                                    let group = self.get_group(self._right_title)
                                    if self._right_title == self._last_title
                                      let sep_change = s:get_separator_change_with_end(group, right_group, outer_right_group, self.overflow_group, sep_size, alt_sep_size) - overflow_marker_size
                                    else
                                      let sep_change = s:get_separator_change(group, right_group, self.overflow_group, sep_size, alt_sep_size)
                                    endif
                                    let right_group = group
                                    let done = self.try_insert_title(self._right_title, group, self._right_position, sep_change, 0)
                                    let self._right_title += done
    1              0.000001       endif
    1              0.000000       if !done
    1              0.000001         break
                                  endif
    1              0.000001     endwhile
                            
    1              0.000001     if self._left_title >= self._first_title
                                  if get(g:, 'airline#extensions#tabline#current_first', 0)
                                    let self._left_position -= 1
                                  endif
                                  call self.insert_section(self.overflow_group, overflow_marker, self._left_position)
                                  let self._right_position += 1
    1              0.000001     endif
                            
    1              0.000000     if self._right_title <= self._last_title
                                  call self.insert_section(self.overflow_group, overflow_marker, self._right_position)
    1              0.000000     endif
    1              0.000000   endif
                            
    1   0.002758   0.000004   return self._build()

FUNCTION  ale#lsp_linter#CheckWithLSP()
    Defined: ~/.vimgo/plugged/ale/autoload/ale/lsp_linter.vim:498
Called 2 times
Total time:   0.092928
 Self time:   0.000018

count  total (s)   self (s)
    2   0.092927   0.000017     return ale#lsp_linter#StartLSP(a:buffer, a:linter, function('s:CheckWithLSP'))

FUNCTION  airline#extensions#ctrlp#apply()
    Defined: ~/.vimgo/plugged/vim-airline/autoload/airline/extensions/ctrlp.vim:70
Called 4 times
Total time:   0.000057
 Self time:   0.000057

count  total (s)   self (s)
                              " disable statusline overwrite if ctrlp already did it
    4              0.000050   return match(&statusline, 'CtrlPwhite') >= 0 ? -1 : 0

FUNCTION  coc#rpc#notify()
    Defined: ~/.vimgo/plugged/coc.nvim/autoload/coc/rpc.vim:104
Called 170 times
Total time:   0.015569
 Self time:   0.002135

count  total (s)   self (s)
  170   0.001856   0.000570   if !coc#rpc#ready()
                                return ''
  170              0.000077   endif
  170   0.013243   0.001095   call s:client['notify'](a:method, a:args)
  170              0.000159   return ''

FUNCTION  coc#window#visible_range()
    Defined: ~/.vimgo/plugged/coc.nvim/autoload/coc/window.vim:216
Called 2 times
Total time:   0.000119
 Self time:   0.000119

count  total (s)   self (s)
    2              0.000054   let winid = bufwinid(a:bufnr)
    2              0.000011   if winid == -1
                                return v:null
    2              0.000003   endif
    2              0.000033   let info = getwininfo(winid)[0]
    2              0.000010   return [info['topline'], info['botline']]

FUNCTION  coc#float#valid()
    Defined: ~/.vimgo/plugged/coc.nvim/autoload/coc/float.vim:36
Called 68 times
Total time:   0.000742
 Self time:   0.000742

count  total (s)   self (s)
   68              0.000058   if a:winid <= 0
    7              0.000006     return 0
   61              0.000017   endif
   61              0.000036   if !s:is_vim
                                if !nvim_win_is_valid(a:winid)
                                  return 0
                                endif
                                return !empty(nvim_win_get_config(a:winid)['relative'])
   61              0.000014   endif
   61              0.000018   try
   61              0.000212     return !empty(popup_getpos(a:winid))
                              catch /^Vim\%((\a\+)\)\=:E993/
                                " not a popup window
                                return 0
   61              0.000026   endtry

FUNCTION  coc#highlight#highlight_lines()
    Defined: ~/.vimgo/plugged/coc.nvim/autoload/coc/highlight.vim:370
Called 3 times
Total time:   0.032983
 Self time:   0.000165

count  total (s)   self (s)
    3              0.000002   let region_id = 1
    3              0.000000   let defined = []
    3              0.000003   let cmds = []
    6              0.000004   for config in a:blocks
    3              0.000003     let start = config['startLine'] + 1
    3              0.000008     let end = config['endLine'] == -1 ? len(getbufline(winbufnr(a:winid), 1, '$')) + 1 : config['endLine'] + 1
    3              0.000006     let filetype = get(config, 'filetype', '')
    3              0.000003     let hlGroup = get(config, 'hlGroup', '')
    3              0.000003     if !empty(hlGroup)
                                  call add(cmds, 'syntax region '.hlGroup.' start=/\%'.start.'l/ end=/\%'.end.'l/')
    3              0.000002     else
    3              0.000009       let filetype = matchstr(filetype, '\v^\w+')
    3              0.000011       if empty(filetype) || filetype == 'txt' || index(get(g:, 'coc_markdown_disabled_languages', []), filetype) != -1
                                    continue
    3              0.000002       endif
    3              0.000003       if index(defined, filetype) == -1
    3              0.000010         call add(cmds, 'syntax include @'.toupper(filetype).' syntax/'.filetype.'.vim')
    3              0.000003         call add(cmds, 'unlet! b:current_syntax')
    3              0.000004         call add(defined, filetype)
    3              0.000002       endif
    3              0.000012       call add(cmds, 'syntax region CodeBlock'.region_id.' start=/\%'.start.'l/ end=/\%'.end.'l/ contains=@'.toupper(filetype).' keepend')
    3              0.000003       let region_id = region_id + 1
    3              0.000000     endif
    6              0.000003   endfor
    3              0.000003   if !empty(cmds)
    3   0.032827   0.000009     call coc#compat#execute(a:winid, cmds, 'silent!')
    3              0.000001   endif

FUNCTION  292()
    Defined: ~/.vimgo/plugged/coc.nvim/autoload/coc/api.vim:96
Called 2 times
Total time:   0.002169
 Self time:   0.000264

count  total (s)   self (s)
    2              0.000009   let res = []
    9              0.000030   for i in range(len(a:calls))
    7              0.000034     let [key, arglist] = a:calls[i]
    7              0.000021     let name = key[5:]
    7              0.000008     try
    7   0.001972   0.000067       call add(res, call(s:funcs[name], arglist))
                                catch /.*/
                                  return [res, [i, "VimException(".s:inspect_type(v:exception).")", v:exception . ' on '.v:throwpoint]]
    7              0.000008     endtry
    9              0.000006   endfor
    2              0.000005   return [res, v:null]

FUNCTION  ale#command#RemoveManagedFiles()
    Defined: ~/.vimgo/plugged/ale/autoload/ale/command.vim:83
Called 1 time
Total time:   0.000013
 Self time:   0.000013

count  total (s)   self (s)
    1              0.000002     let l:info = get(s:buffer_data, a:buffer, {})
                            
    1              0.000002     if !empty(l:info) && empty(l:info.jobs)
                                    " We can't delete anything in a sandbox, so wait until we escape from
                                    " it to delete temporary files and directories.
                                    if ale#util#InSandbox()
                                        return
                                    endif
                            
                                    " Delete files with a call akin to a plan `rm` command.
                                    for l:filename in l:info.file_list
                                        call delete(l:filename)
                                    endfor
                            
                                    " Delete directories like `rm -rf`.
                                    " Directories are handled differently from files, so paths that are
                                    " intended to be single files can be set up for automatic deletion
                                    " without accidentally deleting entire directories.
                                    for l:directory in l:info.directory_list
                                        call delete(l:directory, 'rf')
                                    endfor
                            
                                    call remove(s:buffer_data, a:buffer)
    1              0.000000     endif

FUNCTION  coc#api#notify()
    Defined: ~/.vimgo/plugged/coc.nvim/autoload/coc/api.vim:697
Called 67 times
Total time:   0.108786
 Self time:   0.001016

count  total (s)   self (s)
   67              0.000160   try
   67   0.108300   0.000530     call call(s:funcs[a:method], a:args)
                              catch /.*/
                                let g:b = v:exception
                                call coc#rpc#notify('nvim_error_event', [0, v:exception.' on api "'.a:method.'" '.json_encode(a:args)])
   67              0.000030   endtry

FUNCTION  FugitiveParse()
    Defined: ~/.vimgo/plugged/vim-fugitive/plugin/fugitive.vim:89
Called 4 times
Total time:   0.000040
 Self time:   0.000035

count  total (s)   self (s)
    4   0.000023   0.000018   let path = s:Slash(a:0 ? a:1 : @%)
    4              0.000010   if path !~# '^fugitive://'
    4              0.000005     return ['', '']
                              endif
                              let [rev, dir] = fugitive#Parse(path)
                              if !empty(dir)
                                return [rev, dir]
                              endif
                              throw 'fugitive: invalid Fugitive URL ' . path

FUNCTION  coc#util#diagnostic_info()
    Defined: ~/.vimgo/plugged/coc.nvim/autoload/coc/util.vim:122
Called 1 time
Total time:   0.000149
 Self time:   0.000091

count  total (s)   self (s)
    1   0.000033   0.000009   let checked = coc#util#check_refresh(a:bufnr)
    1              0.000002   if !checked
                                return v:null
    1              0.000000   endif
    1              0.000011   if a:checkInsert && mode() =~# '^i'
                                return v:null
    1              0.000000   endif
    1              0.000002   let locationlist = ''
    1              0.000002   let winid = -1
    1              0.000013   for info in getwininfo()
    1              0.000004     if info['bufnr'] == a:bufnr
    1              0.000003       let winid = info['winid']
    1              0.000013       let locationlist = get(getloclist(winid, {'title': 1}), 'title', '')
    1              0.000002       break
                                endif
    1              0.000002   endfor
    1   0.000052   0.000018   return { 'bufnr': bufnr('%'), 'winid': winid, 'lnum': winid == -1 ? -1 : coc#window#get_cursor(winid)[0], 'locationlist': locationlist }

FUNCTION  airline#highlighter#reset_hlcache()
    Defined: ~/.vimgo/plugged/vim-airline/autoload/airline/highlighter.vim:64
Called 4 times
Total time:   0.000137
 Self time:   0.000137

count  total (s)   self (s)
    4              0.000133     let s:hl_groups = {}

FUNCTION  airline#util#prepend()
    Defined: ~/.vimgo/plugged/vim-airline/autoload/airline/util.vim:65
Called 606 times
Total time:   0.002186
 Self time:   0.002186

count  total (s)   self (s)
  606              0.000697   if a:minwidth > 0 && airline#util#winwidth() < a:minwidth
                                return ''
  606              0.000193   endif
  606              0.000913   return empty(a:text) ? '' : a:text.s:spc.g:airline_right_alt_sep.s:spc

FUNCTION  ale#path#FindNearestExecutable()
    Defined: ~/.vimgo/plugged/ale/autoload/ale/path.vim:82
Called 6 times
Total time:   0.001438
 Self time:   0.000254

count  total (s)   self (s)
   20              0.000024     for l:path in a:path_list
   14   0.000147   0.000036         if ale#path#IsAbsolute(l:path)
                                        let l:executable = filereadable(l:path) ? l:path : ''
   14              0.000006         else
   14   0.001125   0.000052             let l:executable = ale#path#FindNearestFile(a:buffer, l:path)
   14              0.000005         endif
                            
   14              0.000018         if !empty(l:executable)
                                        return l:executable
   14              0.000003         endif
   20              0.000013     endfor
                            
    6              0.000003     return ''

FUNCTION  ale#sign#SetSigns()
    Defined: ~/.vimgo/plugged/ale/autoload/ale/sign.vim:442
Called 1 time
Total time:   0.000152
 Self time:   0.000036

count  total (s)   self (s)
    1              0.000002     if !bufexists(str2nr(a:buffer))
                                    " Stop immediately when attempting to set signs for a buffer which
                                    " does not exist.
                                    return
    1              0.000000     endif
                            
                                " Find the current markers
    1   0.000030   0.000007     let [l:is_dummy_sign_set, l:current_sign_list] =   ale#sign#FindCurrentSigns(a:buffer)
                            
                                " Update the line numbers for items from before which may have moved.
    1   0.000018   0.000004     call s:UpdateLineNumbers(a:buffer, l:current_sign_list, a:loclist)
                            
                                " Group items after updating the line numbers.
    1   0.000013   0.000004     let l:grouped_items = s:GroupLoclistItems(a:buffer, a:loclist)
                            
                                " Build a map of current and new signs, with the lines as the keys.
    1   0.000044   0.000003     let l:sign_map = s:BuildSignMap(   a:buffer,   l:current_sign_list,   l:grouped_items,)
                            
    1   0.000033   0.000004     let l:command_list = ale#sign#GetSignCommands(   a:buffer,   l:is_dummy_sign_set,   l:sign_map,)
                            
                                " Change the sign column color if the option is on.
    1              0.000001     if g:ale_change_sign_column_color && !empty(a:loclist)
                                    highlight clear SignColumn
                                    highlight link SignColumn ALESignColumnWithErrors
    1              0.000001     endif
                            
    1              0.000000     for l:command in l:command_list
                                    silent! execute l:command
    1              0.000001     endfor
                            
                                " Reset the sign column color when there are no more errors.
    1              0.000001     if g:ale_change_sign_column_color && empty(a:loclist)
                                    highlight clear SignColumn
                                    highlight link SignColumn ALESignColumnWithoutErrors
    1              0.000000     endif

FUNCTION  ale#cursor#EchoCursorWarningWithDelay()
    Defined: ~/.vimgo/plugged/ale/autoload/ale/cursor.vim:115
Called 5 times
Total time:   0.000379
 Self time:   0.000315

count  total (s)   self (s)
    5              0.000024     let l:buffer = bufnr('')
                            
    5              0.000016     if !g:ale_echo_cursor && !g:ale_cursor_detail
                                    return
    5              0.000006     endif
                            
                                " Only echo the warnings in normal mode, otherwise we will get problems.
    5              0.000022     if mode(1) isnot# 'n'
                                    return
    5              0.000004     endif
                            
    5   0.000076   0.000030     call s:StopCursorTimer()
                            
    5              0.000048     let l:pos = getpos('.')[0:2]
                            
    5              0.000019     if !exists('w:last_pos')
                                    let w:last_pos = [0, 0, 0]
    5              0.000004     endif
                            
                                " Check the current buffer, line, and column number against the last
                                " recorded position. If the position has actually changed, *then*
                                " we should echo something. Otherwise we can end up doing processing
                                " the echo message far too frequently.
    5              0.000017     if l:pos != w:last_pos
    2   0.000024   0.000006         let l:delay = ale#Var(l:buffer, 'echo_delay')
                            
    2              0.000002         let w:last_pos = l:pos
    2              0.000007         let s:cursor_timer = timer_start(   l:delay,   function('ale#cursor#EchoCursorWarning'))
    5              0.000002     endif

FUNCTION  coc#dialog#create_pum_float()
    Defined: ~/.vimgo/plugged/coc.nvim/autoload/coc/dialog.vim:12
Called 3 times
Total time:   0.036574
 Self time:   0.000487

count  total (s)   self (s)
    3   0.000071   0.000016   let winid = coc#float#get_float_by_kind('pumdetail')
    3   0.000026   0.000011   if empty(a:lines) || !coc#pum#visible()
                                if winid
                                  call coc#float#close(winid)
                                endif
                                return
    3              0.000001   endif
    3   0.000122   0.000009   let pumbounding = coc#pum#info()
    3              0.000006   let border = get(a:config, 'border', [])
    3              0.000006   let pw = pumbounding['width'] + (pumbounding['border'] ? 0 : get(pumbounding, 'scrollbar', 0))
    3              0.000007   let rp = &columns - pumbounding['col'] - pw
    3              0.000005   let showRight = pumbounding['col'] > rp ? 0 : 1
    3   0.000184   0.000123   let maxWidth = showRight ? coc#math#min(rp - 1, a:config['maxWidth']) : coc#math#min(pumbounding['col'] - 1, a:config['maxWidth'])
    3              0.000006   let bh = get(border, 0 ,0) + get(border, 2, 0)
    3              0.000006   let maxHeight = &lines - pumbounding['row'] - &cmdheight - 1 - bh
    3              0.000004   if maxWidth <= 2 || maxHeight < 1
                                return v:null
    3              0.000001   endif
    3              0.000002   let width = 0
   18              0.000008   for line in a:lines
   15              0.000025     let dw = max([1, strdisplaywidth(line)])
   15              0.000018     let width = max([width, dw + 2])
   18              0.000005   endfor
    3   0.000034   0.000009   let width = float2nr(coc#math#min(maxWidth, width))
    3   0.000745   0.000009   let ch = coc#string#content_height(a:lines, width - 2)
    3   0.000032   0.000010   let height = float2nr(coc#math#min(maxHeight, ch))
    3   0.000064   0.000033   let lines = map(a:lines, {_, s -> s =~# '^' ? repeat('', width - 2 + (s:is_vim && ch > height ? -1 : 0)) : s})
    3              0.000025   let opts = { 'lines': lines, 'highlights': get(a:config, 'highlights', []), 'relative': 'editor', 'col': showRight ? pumbounding['col'] + pw : pumbounding['col'] - width, 'row': pumbounding['row'], 'height': height, 'width': width - 2 + (s:is_vim && ch > height ? -1 : 0), 'scrollinside': showRight ? 0 : 1, 'codes': get(a:config, 'codes', []), }
   24              0.000015   for key in ['border', 'highlight', 'borderhighlight', 'winblend', 'focusable', 'shadow', 'rounded']
   21              0.000021     if has_key(a:config, key)
    9              0.000010       let opts[key] = a:config[key]
   21              0.000005     endif
   24              0.000006   endfor
    3   0.000222   0.000010   call s:close_auto_hide_wins(winid)
    3   0.034829   0.000012   let result = coc#float#create_float_win(winid, s:detail_bufnr, opts)
    3              0.000003   if empty(result)
                                return
    3              0.000002   endif
    3              0.000006   let s:detail_bufnr = result[1]
    3              0.000006   call setwinvar(result[0], 'kind', 'pumdetail')
    3              0.000002   if !s:is_vim
                                call coc#float#nvim_scrollbar(result[0])
    3              0.000002   endif

FUNCTION  airline#util#getbufvar()
    Defined: ~/.vimgo/plugged/vim-airline/autoload/airline/util.vim:73
Called 8 times
Total time:   0.000033
 Self time:   0.000033

count  total (s)   self (s)
    8              0.000033     return getbufvar(a:bufnr, a:key, a:def)

FUNCTION  <SNR>198_BufferCacheExists()
    Defined: ~/.vimgo/plugged/ale/autoload/ale/statusline.vim:88
Called 8 times
Total time:   0.000030
 Self time:   0.000030

count  total (s)   self (s)
    8              0.000019     if !exists('g:ale_buffer_info') || !has_key(g:ale_buffer_info, a:buffer)
                                    return 0
    8              0.000001     endif
                            
    8              0.000002     return 1

FUNCTION  <SNR>233_set_float_defaults()
    Defined: ~/.vimgo/plugged/coc.nvim/autoload/coc/float.vim:1321
Called 7 times
Total time:   0.000455
 Self time:   0.000441

count  total (s)   self (s)
    7              0.000004   if !s:is_vim
                                let hlgroup = get(a:config, 'highlight', 'CocFloating')
                                call setwinvar(a:winid, '&winhl', 'Normal:'.hlgroup.',FoldColumn:'.hlgroup)
                                call setwinvar(a:winid, 'border', get(a:config, 'border', []))
                                call setwinvar(a:winid, 'scrollinside', get(a:config, 'scrollinside', 0))
                                call setwinvar(a:winid, '&foldcolumn', s:nvim_get_foldcolumn(a:config))
                                call setwinvar(a:winid, '&signcolumn', 'no')
                                call setwinvar(a:winid, '&cursorcolumn', 0)
    7              0.000001   else
    7              0.000044     call setwinvar(a:winid, '&foldcolumn', 0)
    7              0.000009   endif
    7              0.000021   if !s:is_vim || !has("patch-8.2.3100")
                                call setwinvar(a:winid, '&number', 0)
                                call setwinvar(a:winid, '&relativenumber', 0)
                                call setwinvar(a:winid, '&cursorline', 0)
    7              0.000004   endif
    7              0.000015   call setwinvar(a:winid, '&foldenable', 0)
    7              0.000015   call setwinvar(a:winid, '&colorcolumn', '')
    7              0.000013   call setwinvar(a:winid, '&spell', 0)
    7              0.000013   call setwinvar(a:winid, '&linebreak', 1)
    7              0.000012   call setwinvar(a:winid, '&conceallevel', 0)
    7              0.000010   call setwinvar(a:winid, '&list', 0)
    7              0.000018   call setwinvar(a:winid, '&wrap', !get(a:config, 'cursorline', 0))
    7              0.000005   if s:is_vim || has('nvim-0.5.0')
    7              0.000013     call setwinvar(a:winid, '&scrolloff', 0)
    7              0.000001   endif
    7              0.000022   if has('nvim-0.6.0') || has("patch-8.1.2281")
    7              0.000013     call setwinvar(a:winid, '&showbreak', 'NONE')
    7              0.000002   endif
    7              0.000010   if exists('*win_execute')
    7   0.000093   0.000079     call win_execute(a:winid, 'setl fillchars+=eob:\ ')
    7              0.000005   endif
    7              0.000007   if get(a:config, 'autohide', 0)
                                call setwinvar(a:winid, 'autohide', 1)
    7              0.000002   endif
    7              0.000008   call setwinvar(a:winid, 'float', 1)

FUNCTION  airline#extensions#tabline#builder#new()
    Defined: ~/.vimgo/plugged/vim-airline/autoload/airline/extensions/tabline/builder.vim:227
Called 1 time
Total time:   0.000052
 Self time:   0.000019

count  total (s)   self (s)
    1   0.000039   0.000006   let builder = airline#builder#new(a:context)
    1              0.000004   let builder._build = builder.build
    1              0.000007   call extend(builder, s:prototype, 'force')
    1              0.000001   return builder

FUNCTION  coc#window#get_var()
    Defined: ~/.vimgo/plugged/coc.nvim/autoload/coc/window.vim:67
Called 37 times
Total time:   0.001448
 Self time:   0.000502

count  total (s)   self (s)
   37              0.000024   if !s:is_vim
                                try
                                  if a:name =~# '^&'
                                    return nvim_win_get_option(a:winid, a:name[1:])
                                  else
                                    return nvim_win_get_var(a:winid, a:name)
                                  endif
                                catch /E5555/
                                  return get(a:, 1, v:null)
                                endtry
   37              0.000010   else
   37              0.000012     try
   37   0.001084   0.000138       return coc#api#exec('win_get_var', [a:winid, a:name, get(a:, 1, v:null)])
                                catch /.*/
                                  return get(a:, 1, v:null)
   37              0.000019     endtry
                              endif

FUNCTION  airline#extensions#ale#get_warning()
    Defined: ~/.vimgo/plugged/vim-airline/autoload/airline/extensions/ale.vim:112
Called 4 times
Total time:   0.000301
 Self time:   0.000012

count  total (s)   self (s)
    4   0.000298   0.000009   return airline#extensions#ale#get('warning')

FUNCTION  airline#extensions#tabline#add_tab_label()
    Defined: ~/.vimgo/plugged/vim-airline/autoload/airline/extensions/tabline.vim:37
Called 1 time
Total time:   0.000025
 Self time:   0.000025

count  total (s)   self (s)
    1              0.000004   let show_tab_count = get(g:, 'airline#extensions#tabline#show_tab_count', 1)
    1              0.000002   if show_tab_count == 2
                                call a:dict.add_section_spaced('airline_tabmod', printf('%s %d/%d', "tab", tabpagenr(), tabpagenr('$')))
    1              0.000004   elseif show_tab_count == 1 && tabpagenr('$') > 1
                                call a:dict.add_section_spaced('airline_tabmod', printf('%s %d/%d', "tab", tabpagenr(), tabpagenr('$')))
    1              0.000001   endif

FUNCTION  <SNR>194_build_sections()
    Defined: ~/.vimgo/plugged/vim-airline/autoload/airline/extensions/default.vim:35
Called 8 times
Total time:   0.003105
 Self time:   0.000442

count  total (s)   self (s)
   40              0.000047   for key in a:keys
   32              0.000087     if (key == 'warning' || key == 'error') && !a:context.active
                                  continue
   32              0.000021     endif
   32   0.002832   0.000169     call s:add_section(a:builder, a:context, key)
   40              0.000032   endfor

FUNCTION  airline#extensions#get_loaded_extensions()
    Defined: ~/.vimgo/plugged/vim-airline/autoload/airline/extensions.vim:520
Called 101 times
Total time:   0.000192
 Self time:   0.000192

count  total (s)   self (s)
  101              0.000144   return s:loaded_ext

FUNCTION  <SNR>233_get_borderhighlight()
    Defined: ~/.vimgo/plugged/coc.nvim/autoload/coc/float.vim:1431
Called 20 times
Total time:   0.000098
 Self time:   0.000098

count  total (s)   self (s)
   20              0.000027   let hlgroup = get(a:config, 'highlight',  'CocFloating')
   20              0.000033   let borderhighlight = get(a:config, 'borderhighlight', v:null)
   20              0.000020   if empty(borderhighlight)
   20              0.000011     return hlgroup
                              endif
                              let highlight = type(borderhighlight) == 3 ? borderhighlight[0] : borderhighlight
                              return coc#highlight#compose_hlgroup(highlight, hlgroup)

FUNCTION  airline#builder#new()
    Defined: ~/.vimgo/plugged/vim-airline/autoload/airline/builder.vim:234
Called 5 times
Total time:   0.000170
 Self time:   0.000170

count  total (s)   self (s)
    5              0.000047   let builder = copy(s:prototype)
    5              0.000018   let builder._context = a:context
    5              0.000012   let builder._sections = []
                            
    5              0.000071   call extend(builder._context, { 'left_sep': g:airline_left_sep, 'left_alt_sep': g:airline_left_alt_sep, 'right_sep': g:airline_right_sep, 'right_alt_sep': g:airline_right_alt_sep, }, 'keep')
    5              0.000009   return builder

FUNCTIONS SORTED ON TOTAL TIME
count  total (s)   self (s)  function
   76  13.906823  13.906170  <SNR>88_Highlight_Matching_Pair()
    1   0.383836   0.000149  ale#Queue()
    1   0.383314   0.000170  <SNR>200_Lint()
    1   0.381556   0.000075  ale#engine#RunLinters()
    1   0.381044   0.000399  <SNR>197_GetLintFileValues()
    1   0.380532   0.000205  <SNR>197_RunLinters()
    8   0.374799   0.000107  <SNR>197_RunLinter()
    8   0.372117   0.371889  ale#engine#IsExecutable()
    6   0.280077   0.000176  <SNR>197_RunIfExecutable()
  109   0.179292   0.000624  296()
   67   0.108786   0.001016  coc#api#notify()
   20   0.094029   0.001867  coc#float#create_float_win()
    2   0.092928   0.000018  ale#lsp_linter#CheckWithLSP()
    2   0.092910   0.000047  ale#lsp_linter#StartLSP()
    2   0.092262   0.000019  <SNR>216_StartIfExecutable()
   20   0.088144   0.000324  <SNR>233_add_highlights()
   20   0.087820   0.007169  coc#highlight#add_highlights()
   85   0.074648   0.002012  coc#api#call()
   16   0.071162             coc#util#synname()
   18   0.065235   0.002183  coc#pum#create()

FUNCTIONS SORTED ON SELF TIME
count  total (s)   self (s)  function
   76  13.906823  13.906170  <SNR>88_Highlight_Matching_Pair()
    8   0.372117   0.371889  ale#engine#IsExecutable()
   16              0.071162  coc#util#synname()
   23              0.035368  <SNR>230_execute()
 1115   0.030039   0.026106  325()
 1940              0.020124  <SNR>176_get_syn()
 1115   0.046593   0.014196  coc#highlight#add_highlight()
  485   0.034258   0.012757  airline#highlighter#get_highlight()
  170   0.012148   0.011563  <SNR>76_notify()
  221   0.031342   0.009266  airline#highlighter#exec()
   97   0.052115   0.008020  airline#check_mode()
   20   0.087820   0.007169  coc#highlight#add_highlights()
  202              0.005712  FugitiveGitDir()
  805              0.005543  airline#util#winwidth()
    6   0.041376   0.005172  airline#highlighter#highlight()
  101   0.005893   0.004963  <SNR>179_update_untracked()
  101   0.009935   0.004847  airline#extensions#hunks#get_hunks()
  101   0.008278   0.004256  fugitive#Head()
  679              0.004155  airline#util#append()
 1115              0.003933  <SNR>230_generate_id()

